---
title: Migrations
description: Understanding how Moose manages database schema changes through code
---

import { Callout, FeatureCard, FeatureGrid, LanguageSwitcher, TypeScript, Python } from "@/components";
import { Tabs } from "nextra/components";

<LanguageSwitcher />

# Migrations

When you define database tables and streaming topics in your code, you need a way to synchronize those definitions with your actual infrastructure. As your application evolves, you'll add fields, change data types, and restructure tables. Migrations are the mechanism that makes these schema changes safely and reliably.

## What Are Migrations?

Migrations are operations that update your database schema to match your code definitions. Instead of manually writing SQL commands or managing schema changes through a database interface, you declare your desired schema in code, and Moose Migrate calculates what needs to change and applies those changes for you.

Think of migrations like version control for your database structure. Just as Git tracks changes to your code, migrations track changes to your schema, creating an audit trail and enabling safe, repeatable deployments.

### Why Migrations Matter

Database schema changes are risky. A mistaken column drop can lose customer data. An incorrectly applied change during high traffic can cause downtime. Manual SQL scripts are error-prone and hard to track across environments.

Moose Migrate solves these problems by:

- **Generating changes automatically** - You focus on your schema definition, not SQL syntax
- **Providing review workflows** - See exactly what will change before it happens
- **Detecting conflicts** - Know when someone else has modified the database
- **Preserving data** - Use rename operations instead of destructive drop-and-recreate
- **Creating audit trails** - Track every schema change through version control

## How Migrations Work

Moose Migrate operates through a comparison model. The system compares two states:

1. **Your code** - Tables and streams defined in your application
2. **Your database** - The actual schema in ClickHouse, Kafka, or Redpanda

When these states differ, Moose generates a set of operations to bring them into alignment. These operations might include:

- Adding or dropping tables
- Adding, removing, or renaming columns
- Changing data types
- Creating or modifying streaming topics

The key insight is that Moose handles the complexity of schema evolution so you can focus on your application logic.

## Core Concepts

Understanding migrations requires familiarity with three key decisions:

### Migration Modes: Planned vs Auto-Inferred

This determines **how** migration operations are generated and when you review them.

**Planned migrations** generate a migration plan file that you review and commit before execution. This is like a pull request for your databaseâ€”you see the exact changes, can edit them if needed, and approve them explicitly.

**Auto-inferred migrations** diff your code against the database on-the-fly and apply changes immediately. This is faster for development but riskier for production, since there's no review step.

### Deployment Models: Service vs Library

This determines **when** migrations execute.

**Service model** (`moose prod`) runs migrations automatically when your application starts. MooseStack manages the entire runtime, including the database and migration lifecycle.

**Library model** (`moose migrate`) lets you control migration timing through CLI commands. This is useful when integrating Moose into an existing application where you manage deployment workflows yourself.

### Lifecycle Modes: What Changes Are Allowed

This determines **which** operations Moose can perform on specific tables or streams.

**`FULLY_MANAGED`** allows all operations including drops (data loss possible)
**`DELETION_PROTECTED`** allows additions and modifications but blocks destructive operations
**`EXTERNALLY_MANAGED`** makes resources read-only (Moose will not modify them)

These three concepts combine to give you precise control over schema evolution.

## When to Use Each Migration Mode

Choosing the right migration mode depends on your environment and risk tolerance.

### Use Planned Migrations When:

**You're deploying to production** - Reviewing exact changes before execution prevents costly mistakes. If you're running a production system with real data, planned migrations are essential.

**Multiple systems touch your database** - If you use ClickPipes, PeerDB, Airbyte, or other data integration tools, you need drift detection. Planned migrations will abort if the database state doesn't match expectations.

**Your team requires approval workflows** - Many organizations require pull request reviews for infrastructure changes. Planned migrations create reviewable artifacts that fit naturally into this workflow.

**You need compliance audit trails** - SOC2, HIPAA, and similar frameworks often require documented approval for database changes. Committing migration plans to Git creates this trail automatically.

### Use Auto-Inferred Migrations When:

**You're in early development** - Rapid iteration matters more than safety when you're building a prototype or exploring design options. Auto-inferred migrations let you change your schema and see results immediately.

**Moose owns the entire database** - If no other systems write to your database and all changes flow through Moose, the risks of auto-inference are lower.

**You're comfortable with potential data loss** - Auto-inferred migrations can't distinguish renames from drop-and-recreate. If you remove a field, it will drop the column and lose data.

<Callout type="warning">
Auto-inferred migrations are primarily meant for development environments. For production, planned migrations provide review, drift detection, and audit trails that are difficult to replicate with auto-inference.
</Callout>

## When to Use Each Deployment Model

Your deployment model choice depends on how Moose integrates with your application.

### Use Service Model When:

You have a new MooseStack application and want to use the full managed server runtime. This is the default deployment model for new MooseStack applications. The MooseStack runtime deploys an admin service that manages the lifecycle of your entire analytical stack, including migrations, streaming consumers, workflows, and APIs.

### Use Library Model When:

You have an existing application and want to add Moose OLAP capabilities to it. This is the default deployment model for existing applications. The library model integrates with your existing application and allows you to control the timing of migrations via the CLI.

## Combining Modes for Safety

The safest approach combines planned migrations with DELETION_PROTECTED lifecycle mode:

- **Planned migrations** ensure you review changes before execution
- **DELETION_PROTECTED** prevents accidental data loss even if a destructive operation is approved

This combination protects against both human error (approving the wrong plan) and design mistakes (not realizing an operation is destructive).

## Common Scenarios

| Scenario | Recommended Setup | Why |
|----------|------------------|-----|
| Building a new data platform | Service model + planned migrations + DELETION_PROTECTED | Automatic deployment with maximum safety |
| Adding analytics to existing app | Library model + planned migrations + DELETION_PROTECTED | Explicit control with review workflow |
| Local development | Either model + auto-inferred + FULLY_MANAGED | Fast iteration with hot reload |
| Shared database with external tools | Either model + planned + EXTERNALLY_MANAGED | Drift detection prevents conflicts |
| Staging environment | Either model + planned + FULLY_MANAGED | Production-like workflow, allows drops for testing |

## Related Resources

### Getting Started
- [Add Moose to an existing app](/moose/getting-started/add-to-app) - Library model setup and configuration
- [Quick start guide](/moose/getting-started) - Service model basics

### Implementation Guides
- [How to use planned migrations (service model)](/moose/olap/planned-migrations) - Full MooseStack runtime workflow
- [How to use planned migrations (library model)](/moose/olap/planned-migrations-library) - Existing app integration workflow
- [How to develop locally](/moose/olap/apply-migrations) - Using auto-inferred migrations with moose dev

### Reference Documentation
- [Migration reference](/moose/migrate/reference) - Operations, data types, and plan structure
- [CLI commands](/moose/moose-cli#generate-migration-plan-olap) - moose migrate and related commands

### Advanced Topics
- [Lifecycle management](/moose/migrate/lifecycle) - Controlling allowed operations
- [Table versioning](/moose/olap/schema-versioning) - Blue/green deployments for ORDER BY changes
- [Troubleshooting migrations](/moose/olap/schema-change) - Fixing failed migrations and type mismatches
