---
title: Bring Your Own API Framework
description: Use Express, Koa, Fastify, or FastAPI with MooseStack
---

import { Callout, LanguageSwitcher, TypeScript, Python } from "@/components";
import { Tabs } from "nextra/components";

# Bring Your Own API Framework
<LanguageSwitcher />

## Overview

MooseStack provides flexible approaches for integrating with popular web frameworks:

<TypeScript>
**TypeScript** supports two integration patterns:

1. **WebApp**: Mount Express, Koa, Fastify, or raw Node.js handlers within your Moose project
2. **getMooseClients**: Use MooseStack database clients in external, non-Moose applications

This flexibility lets you leverage MooseStack's data infrastructure without being locked into a specific API pattern.
</TypeScript>

<Python>
**Python** supports FastAPI integration through WebApp:

- **WebApp**: Use FastAPI within a Moose project while accessing MooseStack infrastructure
- Access to database clients and JWT authentication
- Full FastAPI features including middleware, dependencies, and async/await
</Python>

## When to Use This Approach

Use this approach when you need:

- **Custom middleware**: Authentication, logging, rate limiting, request transformation
- **Framework-specific features**: Plugins, extensions, routing patterns from your preferred framework
- **Advanced HTTP features**: WebSockets, Server-Sent Events, file uploads, custom response handling
- **Existing codebase integration**: Migrate existing endpoints into MooseStack or add MooseStack to existing apps
- **Complex routing**: Dynamic routes, route groups, nested routers

Stick with standard Moose `Api` when you need:

- **Simple GET endpoints**: Query parameters with type validation and response formatting
- **Automatic OpenAPI documentation**: Generated specs for all your endpoints
- **Minimal setup**: Quick analytics endpoints without framework boilerplate

<TypeScript>
## When to Use Each Approach

### Use WebApp (Framework in Moose) When:

- You're building a new Moose project and want to use Express, Koa, or another framework
- You need custom middleware (authentication, logging, rate limiting)
- You want framework-specific features (Express plugins, Koa context, etc.)
- You want MooseStack to handle infrastructure lifecycle (database connections, containers)
- You need to combine framework APIs with standard Moose APIs

### Use getMooseClients (Moose in Framework) When:

- You have an existing Express, Fastify, or other Node.js application
- You want to add MooseStack's OLAP database to your current stack
- You manage your own infrastructure and containers
- You only need database query capabilities without other Moose features
- You want minimal integration with your existing codebase
</TypeScript>

---

## WebApp: Use Frameworks in Moose

<TypeScript>
The `WebApp` class lets you mount Express, Koa, Fastify, or raw Node.js handlers within your Moose project at custom paths. MooseStack automatically injects database clients and utilities into your request handlers.
</TypeScript>

<Python>
The `WebApp` class lets you mount FastAPI applications within your Moose project at custom paths. MooseStack automatically injects database clients and utilities into your request handlers.
</Python>

### Supported Frameworks

<TypeScript>
<Callout type="info">
WebApp supports any framework with one of these patterns:
- Express/Connect-style: `.handle(req, res, next)` method
- Koa-style: `.callback()` method
- Fastify-style: `.routing` property (after calling `.ready()`)
- Raw Node.js: `(req, res) => void` function
</Callout>
</TypeScript>

<Python>
<Callout type="info">
WebApp currently supports FastAPI applications. Pass your FastAPI app instance to the WebApp constructor.
</Callout>
</Python>

### Basic Setup

<TypeScript>
<Tabs items={["Express", "Koa", "Raw Node.js"]}>
<Tabs.Tab>
```ts filename="app/apis/myExpressApp.ts" copy
import express from "express";
import { WebApp, expressMiddleware, getMooseUtils } from "@514labs/moose-lib";
import { MyTable } from "../tables/MyTable";

// Create Express app
const app = express();

app.use(express.json());
app.use(expressMiddleware()); // Required for Express

// Define routes
app.get("/health", (req, res) => {
  res.json({ status: "ok" });
});

app.get("/data", async (req, res) => {
  const moose = getMooseUtils(req);
  if (!moose) {
    return res.status(500).json({ error: "Moose utilities not available" });
  }

  const { client, sql } = moose;

  const query = sql`SELECT * FROM ${MyTable} LIMIT 10`;
  const result = await client.query.execute(query);
  const data = await result.json();

  res.json(data);
});

// Mount the app at /myapi
export const myExpressApp = new WebApp("myExpress", app, {
  mountPath: "/myapi",
  metadata: {
    description: "Custom Express API with middleware"
  }
});
```

**Access your API:**
- `GET http://localhost:4000/myapi/health`
- `GET http://localhost:4000/myapi/data`
</Tabs.Tab>

<Tabs.Tab>
```ts filename="app/apis/myKoaApp.ts" copy
import Koa from "koa";
import Router from "@koa/router";
import bodyParser from "koa-bodyparser";
import { WebApp, getMooseUtils } from "@514labs/moose-lib";
import { MyTable } from "../tables/MyTable";

const app = new Koa();
const router = new Router();

app.use(bodyParser());

router.get("/health", (ctx) => {
  ctx.body = { status: "ok" };
});

router.get("/data", async (ctx) => {
  const moose = getMooseUtils(ctx.req);
  if (!moose) {
    ctx.status = 500;
    ctx.body = { error: "Moose utilities not available" };
    return;
  }

  const { client, sql } = moose;

  const query = sql`SELECT * FROM ${MyTable} LIMIT 10`;
  const result = await client.query.execute(query);
  const data = await result.json();

  ctx.body = data;
});

app.use(router.routes());
app.use(router.allowedMethods());

// Mount the app at /myapi
export const myKoaApp = new WebApp("myKoa", app, {
  mountPath: "/myapi",
  metadata: {
    description: "Custom Koa API"
  }
});
```

**Access your API:**
- `GET http://localhost:4000/myapi/health`
- `GET http://localhost:4000/myapi/data`
</Tabs.Tab>

<Tabs.Tab>
```ts filename="app/apis/myRawApp.ts" copy
import { WebApp, getMooseUtils } from "@514labs/moose-lib";
import { MyTable } from "../tables/MyTable";
import { IncomingMessage, ServerResponse } from "http";
import { parse as parseUrl } from "url";

const handler = async (req: IncomingMessage, res: ServerResponse) => {
  const url = parseUrl(req.url || "", true);
  const pathname = url.pathname || "/";

  if (pathname === "/health" && req.method === "GET") {
    res.writeHead(200, { "Content-Type": "application/json" });
    res.end(JSON.stringify({ status: "ok" }));
    return;
  }

  if (pathname === "/data" && req.method === "GET") {
    const moose = getMooseUtils(req);
    if (!moose) {
      res.writeHead(500, { "Content-Type": "application/json" });
      res.end(JSON.stringify({ error: "Moose utilities not available" }));
      return;
    }

    const { client, sql } = moose;

    try {
      const query = sql`SELECT * FROM ${MyTable} LIMIT 10`;
      const result = await client.query.execute(query);
      const data = await result.json();

      res.writeHead(200, { "Content-Type": "application/json" });
      res.end(JSON.stringify(data));
    } catch (error) {
      res.writeHead(500, { "Content-Type": "application/json" });
      res.end(JSON.stringify({ error: String(error) }));
    }
    return;
  }

  res.writeHead(404, { "Content-Type": "application/json" });
  res.end(JSON.stringify({ error: "Not found" }));
};

// Mount the handler at /myapi
export const myRawApp = new WebApp("myRaw", handler, {
  mountPath: "/myapi",
  metadata: {
    description: "Custom raw Node.js handler"
  }
});
```

**Access your API:**
- `GET http://localhost:4000/myapi/health`
- `GET http://localhost:4000/myapi/data`
</Tabs.Tab>
</Tabs>
</TypeScript>

<Python>
```python filename="app/apis/my_fastapi_app.py" copy
from fastapi import FastAPI, Request, HTTPException
from moose_lib.dmv2 import WebApp, WebAppConfig, WebAppMetadata
from moose_lib.dmv2.web_app_helpers import get_moose_utils
from app.tables.my_table import MyTable

# Create FastAPI app
app = FastAPI()

# Health check endpoint
@app.get("/health")
async def health():
    return {"status": "ok"}

# Data endpoint
@app.get("/data")
async def get_data(request: Request, limit: int = 10):
    moose = get_moose_utils(request)
    if not moose:
        raise HTTPException(
            status_code=500,
            detail="Moose utilities not available"
        )

    # Execute query using MooseClient
    query = """
        SELECT * FROM {table}
        LIMIT {limit}
    """

    result = moose.client.query.execute(query, {
        "table": MyTable,
        "limit": limit
    })

    return {
        "success": True,
        "count": len(result),
        "data": result
    }

# Register the FastAPI app as a WebApp
my_fastapi_app = WebApp(
    "myFastApi",
    app,
    WebAppConfig(
        mount_path="/myapi",
        metadata=WebAppMetadata(
            description="Custom FastAPI application"
        )
    )
)
```

**Access your API:**
- `GET http://localhost:4000/myapi/health`
- `GET http://localhost:4000/myapi/data?limit=10`
</Python>

### WebApp Configuration

<TypeScript>
The `WebApp` constructor accepts three parameters:

```ts
new WebApp(name, appOrHandler, config)
```

**Parameters:**
- `name` (string): Unique identifier for your WebApp
- `appOrHandler` (FrameworkApp | WebAppHandler): Your framework instance or handler function
- `config` (WebAppConfig): Configuration object

**WebAppConfig:**
```ts
interface WebAppConfig {
  // Required: URL path where your app will be mounted
  mountPath: string;

  // Optional: Metadata for documentation
  metadata?: {
    description?: string;
  };

  // Optional: Whether to inject Moose utilities (default: true)
  injectMooseUtils?: boolean;
}
```
</TypeScript>

<Python>
The `WebApp` constructor accepts three parameters:

```python
WebApp(name, app, config)
```

**Parameters:**
- `name` (str): Unique identifier for your WebApp
- `app` (FastAPI): Your FastAPI application instance
- `config` (WebAppConfig): Configuration object

**WebAppConfig:**
```python
@dataclass
class WebAppConfig:
    # Required: URL path where your app will be mounted
    mount_path: str

    # Optional: Metadata for documentation
    metadata: Optional[WebAppMetadata] = None

    # Optional: Whether to inject Moose utilities (default: True)
    inject_moose_utils: bool = True

@dataclass
class WebAppMetadata:
    description: Optional[str] = None
```
</Python>

### Mount Path Rules

<Callout type="warning">
Mount paths must follow these rules:
- Cannot be `/` (root path)
- Cannot end with a trailing slash (e.g., `/api/` is invalid)
- Cannot start with reserved paths: `/admin`, `/api`, `/consumption`, `/health`, `/ingest`, `/moose`, `/ready`, `/workflows`
- Must be unique across all WebApps in your project
</Callout>

**Valid mount paths:**
- `/myapi`
- `/v1/analytics`
- `/custom/endpoint`

**Invalid mount paths:**
- `/` (root path)
- `/myapi/` (trailing slash)
- `/api/myendpoint` (starts with reserved path)

### Accessing Moose Utilities

<TypeScript>
Use `getMooseUtils()` to access MooseStack clients and helpers from your request handler:

```ts
import { getMooseUtils } from "@514labs/moose-lib";

const moose = getMooseUtils(req);
if (!moose) {
  // Handle error: Moose utilities not available
  return;
}

const { client, sql, jwt } = moose;
```

**Available utilities:**
- `client`: MooseClient for database queries
- `sql`: Template tag for safe SQL queries
- `jwt`: Parsed JWT payload (when authentication is configured)

<Callout type="info" title="Express Middleware Required">
Express applications must use the `expressMiddleware()` to access Moose utilities:

```ts
import { expressMiddleware } from "@514labs/moose-lib";

app.use(expressMiddleware());
```

Koa and raw handlers access utilities directly from `req` without middleware.
</Callout>
</TypeScript>

<Python>
Use `get_moose_utils()` to access MooseStack clients and helpers from your request handler:

```python
from moose_lib.dmv2.web_app_helpers import get_moose_utils

@app.get("/data")
async def get_data(request: Request):
    moose = get_moose_utils(request)
    if not moose:
        raise HTTPException(
            status_code=500,
            detail="Moose utilities not available"
        )

    # Access utilities
    client = moose.client
    jwt = moose.jwt
```

**Available utilities:**
- `client`: MooseClient for database queries
- `jwt`: Parsed JWT payload (when authentication is configured)

<Callout type="info" title="FastAPI Dependency Pattern">
You can also use FastAPI's dependency injection with `get_moose_dependency()`:

```python
from moose_lib.dmv2.web_app_helpers import get_moose_dependency, ApiUtil
from fastapi import Depends

@app.get("/data")
async def get_data(moose: ApiUtil = Depends(get_moose_dependency())):
    # moose is automatically injected
    result = moose.client.query.execute(...)
    return result
```
</Callout>
</Python>

### Authentication with JWT

When JWT authentication is configured in `moose.config.toml`, WebApp automatically validates tokens and provides the decoded payload:

<TypeScript>
```ts
app.get("/protected", async (req, res) => {
  const moose = getMooseUtils(req);

  if (!moose?.jwt) {
    return res.status(401).json({ error: "Unauthorized" });
  }

  // Access JWT claims
  const userId = moose.jwt.sub;
  const customClaim = moose.jwt.customField;

  res.json({
    message: "Authenticated",
    userId,
    claims: moose.jwt
  });
});
```
</TypeScript>

<Python>
```python
from fastapi import HTTPException, Depends

# Option 1: Manual check
@app.get("/protected")
async def protected(request: Request):
    moose = get_moose_utils(request)

    if not moose or not moose.jwt:
        raise HTTPException(
            status_code=401,
            detail="Unauthorized - JWT token required"
        )

    # Access JWT claims
    user_id = moose.jwt.get("sub")
    custom_claim = moose.jwt.get("customField")

    return {
        "message": "Authenticated",
        "userId": user_id,
        "claims": moose.jwt
    }

# Option 2: Using a dependency function
async def require_auth(request: Request):
    moose = get_moose_utils(request)
    if not moose or not moose.jwt:
        raise HTTPException(
            status_code=401,
            detail="Unauthorized"
        )
    return moose

@app.get("/protected")
async def protected(moose=Depends(require_auth)):
    return {
        "message": "Authenticated",
        "user": moose.jwt.get("sub"),
        "claims": moose.jwt
    }
```
</Python>

See the [Authentication documentation](/moose/apis/auth) for JWT configuration details.

### Combining WebApp with Standard APIs

You can use WebApp alongside standard Moose `Api` in the same file:

<TypeScript>
```ts filename="app/apis/combined.ts" copy
import express from "express";
import { WebApp, Api, getMooseUtils, expressMiddleware } from "@514labs/moose-lib";

// Standard Moose API
interface Params {
  limit: number;
}

interface Result {
  id: number;
  name: string;
}

export const standardApi = new Api<Params, Result[]>(
  "standard",
  async ({ limit }, { client, sql }) => {
    // Standard Moose API implementation
    const query = sql`SELECT * FROM users LIMIT ${limit}`;
    const result = await client.query.execute(query);
    return result.json();
  }
);

// Custom Express WebApp
const app = express();
app.use(express.json());
app.use(expressMiddleware()); // Required for Express

app.get("/custom", async (req, res) => {
  const moose = getMooseUtils(req);
  // Custom Express implementation
  res.json({ message: "Custom endpoint" });
});

export const customApp = new WebApp("custom", app, {
  mountPath: "/custom"
});
```

**Access both APIs:**
- Standard: `GET http://localhost:4000/api/standard?limit=10`
- Custom: `GET http://localhost:4000/custom/custom`
</TypeScript>

<Python>
```python filename="app/apis/combined.py" copy
from fastapi import FastAPI, Request
from moose_lib.dmv2 import Api, WebApp, WebAppConfig
from moose_lib.dmv2.web_app_helpers import get_moose_utils
from pydantic import BaseModel

# Standard Moose API
class Params(BaseModel):
    limit: int

class Result(BaseModel):
    id: int
    name: str

def query_function(client, params: Params) -> list[Result]:
    query = "SELECT * FROM users LIMIT {limit}"
    return client.query.execute(query, {"limit": params.limit})

standard_api = Api[Params, Result]("standard", query_function)

# Custom FastAPI WebApp
app = FastAPI()

@app.get("/custom")
async def custom(request: Request):
    moose = get_moose_utils(request)
    # Custom FastAPI implementation
    return {"message": "Custom endpoint"}

custom_app = WebApp(
    "custom",
    app,
    WebAppConfig(mount_path="/custom")
)
```

**Access both APIs:**
- Standard: `GET http://localhost:4000/api/standard?limit=10`
- Custom: `GET http://localhost:4000/custom/custom`
</Python>

---

<TypeScript>
## getMooseClients: Use Moose in External Projects

The `getMooseClients()` function initializes MooseStack database clients for use in standalone, non-Moose projects. This lets you query MooseStack's ClickHouse database from any Node.js application.

### Basic Setup

<Tabs items={["Express", "Fastify", "Standalone"]}>
<Tabs.Tab>
```ts filename="server.ts" copy
import express from "express";
import { getMooseClients, sql } from "@514labs/moose-lib";

const app = express();

// Middleware to attach Moose client to all requests
app.use(async (req, res, next) => {
  try {
    const { client } = await getMooseClients({
      host: "localhost",
      port: "18123",
      database: "local",
      username: "panda",
      password: "pandapass"
    });

    (req as any).mooseClient = client;
    next();
  } catch (error) {
    console.error("Failed to initialize Moose client:", error);
    res.status(500).json({ error: "Database connection failed" });
  }
});

// Use client in routes
app.get("/users", async (req, res) => {
  const client = (req as any).mooseClient;

  const query = sql`SELECT * FROM users LIMIT 10`;
  const result = await client.query.execute(query);
  const data = await result.json();

  res.json(data);
});

app.listen(3000, () => {
  console.log("Server running on http://localhost:3000");
});
```
</Tabs.Tab>

<Tabs.Tab>
```ts filename="server.ts" copy
import Fastify from "fastify";
import { getMooseClients, sql } from "@514labs/moose-lib";

const fastify = Fastify({ logger: true });

// Initialize client once at startup
let mooseClient: any;

fastify.addHook("onRequest", async (request, reply) => {
  if (!mooseClient) {
    const { client } = await getMooseClients({
      host: "localhost",
      port: "18123",
      database: "local"
    });
    mooseClient = client;
  }

  (request as any).mooseClient = mooseClient;
});

fastify.get("/users", async (request, reply) => {
  const client = (request as any).mooseClient;

  const query = sql`SELECT * FROM users LIMIT 10`;
  const result = await client.query.execute(query);
  const data = await result.json();

  return data;
});

fastify.listen({ port: 3000 }, (err) => {
  if (err) throw err;
  console.log("Server running on http://localhost:3000");
});
```
</Tabs.Tab>

<Tabs.Tab>
```ts filename="query.ts" copy
import { getMooseClients, sql } from "@514labs/moose-lib";

async function queryData() {
  // Initialize client
  const { client } = await getMooseClients({
    host: "localhost",
    port: "18123",
    database: "local",
    username: "panda",
    password: "pandapass"
  });

  // Execute query
  const query = sql`SELECT COUNT(*) as count FROM users`;
  const result = await client.query.execute(query);
  const data = await result.json();

  console.log("User count:", data);
}

queryData().catch(console.error);
```
</Tabs.Tab>
</Tabs>

### Configuration Options

The `getMooseClients()` function accepts an optional configuration object. All parameters are optional and will use the configuration priority system described below.

```ts
interface RuntimeClickHouseConfig {
  host?: string;        // ClickHouse host (default: "localhost")
  port?: string;        // ClickHouse HTTP port (default: "18123")
  database?: string;    // Database name (default: "local")
  username?: string;    // Username (default: "default")
  password?: string;    // Password (default: "")
  useSSL?: boolean;     // Use SSL connection (default: false)
}
```

**Environment Variable Names:**
- `MOOSE_CLICKHOUSE_CONFIG__HOST`
- `MOOSE_CLICKHOUSE_CONFIG__HOST_PORT`
- `MOOSE_CLICKHOUSE_CONFIG__DB_NAME`
- `MOOSE_CLICKHOUSE_CONFIG__USER`
- `MOOSE_CLICKHOUSE_CONFIG__PASSWORD`
- `MOOSE_CLICKHOUSE_CONFIG__USE_SSL` (accepts: `true`, `false`, `1`, `0`, `yes`, `no`, `on`, `off`)

### Configuration Priority

Configuration values are resolved in this order (highest priority first):

1. **Function parameters**: Values passed directly to `getMooseClients()`
2. **Environment variables**: Standard Moose environment variables
3. **moose.config.toml**: Configuration from your Moose project (if available)
4. **Default values**: Hardcoded fallbacks

This allows `getMooseClients()` to work in multiple scenarios:
- **Inside a Moose project**: Automatically uses your project's `moose.config.toml`
- **Outside a Moose project**: Falls back to environment variables and defaults
- **Custom configuration**: Override any value via function parameters

**Example with multiple configuration sources:**

```bash
# Set in environment or .env file
export MOOSE_CLICKHOUSE_CONFIG__HOST=production-db.example.com
export MOOSE_CLICKHOUSE_CONFIG__HOST_PORT=8123
export MOOSE_CLICKHOUSE_CONFIG__DB_NAME=analytics
export MOOSE_CLICKHOUSE_CONFIG__USER=app_user
export MOOSE_CLICKHOUSE_CONFIG__PASSWORD=secure_password
export MOOSE_CLICKHOUSE_CONFIG__USE_SSL=true
```

```toml filename="moose.config.toml"
# If this file exists, these values are used as the third priority
[clickhouse_config]
host = "localhost"
host_port = 18123
db_name = "local"
user = "panda"
password = "pandapass"
use_ssl = false
```

```ts
// Scenario 1: Uses environment variables (overrides moose.config.toml)
const { client } = await getMooseClients();
// Result: production-db.example.com:8123

// Scenario 2: Override specific values (overrides everything else)
const { client } = await getMooseClients({
  database: "custom_db"  // Uses this for database
  // host, port, etc. come from env vars or moose.config.toml
});

// Scenario 3: Outside Moose project with no env vars (uses defaults)
const { client } = await getMooseClients();
// Result: localhost:18123 with default credentials
```

<Callout type="info">
The configuration gracefully handles missing `moose.config.toml` files, making `getMooseClients()` work seamlessly in standalone applications outside of Moose projects.
</Callout>

### Using the SQL Helper

The `sql` template tag provides safe query construction with automatic escaping:

```ts
import { sql } from "@514labs/moose-lib";

const userId = 123;
const status = "active";

// Safe interpolation
const query = sql`
  SELECT * FROM users
  WHERE id = ${userId}
  AND status = ${status}
`;

const result = await client.query.execute(query);
```

<Callout type="warning">
Always use the `sql` template tag for query construction. Never concatenate user input directly into query strings.
</Callout>

### Importing Table Types from Moose Projects

You can import table schemas from Moose projects to maintain type safety:

```ts filename="external-app/src/queries.ts" copy
// Import table definitions from your Moose project
import { UserTable } from "../../moose-project/app/tables/UserTable";
import { getMooseClients, sql } from "@514labs/moose-lib";

async function queryUsers() {
  const { client } = await getMooseClients();

  // Use imported table for type-safe queries
  const query = sql`
    SELECT
      ${UserTable.columns.id},
      ${UserTable.columns.name},
      ${UserTable.columns.email}
    FROM ${UserTable}
    WHERE ${UserTable.columns.isActive} = true
  `;

  const result = await client.query.execute(query);
  return result.json();
}
```

---
</TypeScript>

## Best Practices

### WebApp Best Practices

<TypeScript>
1. **Use expressMiddleware for Express**: Always add `expressMiddleware()` before accessing Moose utilities in Express apps

2. **Check for Moose utilities**: Always verify `getMooseUtils()` returns a value before using it
   ```ts
   const moose = getMooseUtils(req);
   if (!moose) {
     return res.status(500).json({ error: "Utilities not available" });
   }
   ```

3. **Choose unique mount paths**: Ensure mount paths don't conflict with other WebApps or Moose's reserved paths

4. **Handle errors gracefully**: Wrap database queries in try-catch blocks
   ```ts
   try {
     const result = await client.query.execute(query);
     res.json(await result.json());
   } catch (error) {
     res.status(500).json({ error: String(error) });
   }
   ```

5. **Combine with standard APIs**: Use WebApp for complex routing/middleware and standard `Api` for simple GET endpoints
</TypeScript>

<Python>
1. **Check for Moose utilities**: Always verify `get_moose_utils()` returns a value before using it
   ```python
   moose = get_moose_utils(request)
   if not moose:
       raise HTTPException(
           status_code=500,
           detail="Moose utilities not available"
       )
   ```

2. **Use FastAPI dependencies**: Leverage FastAPI's `Depends()` for cleaner authentication
   ```python
   async def require_auth(request: Request):
       moose = get_moose_utils(request)
       if not moose or not moose.jwt:
           raise HTTPException(status_code=401)
       return moose

   @app.get("/protected")
   async def protected(moose=Depends(require_auth)):
       return {"user": moose.jwt.get("sub")}
   ```

3. **Choose unique mount paths**: Ensure mount paths don't conflict with other WebApps or Moose's reserved paths

4. **Handle errors gracefully**: Use FastAPI's exception handling
   ```python
   from fastapi.responses import JSONResponse

   @app.exception_handler(Exception)
   async def global_exception_handler(request: Request, exc: Exception):
       return JSONResponse(
           status_code=500,
           content={"error": str(exc)}
       )
   ```

5. **Validate request data**: Use Pydantic models for automatic validation
   ```python
   class DataRequest(BaseModel):
       limit: int = Field(gt=0, le=100)
       order_by: str = Field(pattern="^(id|name|created_at)$")
   ```
</Python>

<TypeScript>
### getMooseClients Best Practices

1. **Initialize once**: Create the client once at application startup rather than per-request
   ```ts
   // Good: Initialize once
   const { client } = await getMooseClients();

   // Bad: Initialize per request
   app.get("/data", async (req, res) => {
     const { client } = await getMooseClients(); // Wasteful
   });
   ```

2. **Use environment variables**: Store connection details in environment variables for different environments

3. **Always use sql helper**: Use the `sql` template tag for all queries to prevent SQL injection

4. **Type your results**: Specify result types for better type safety
   ```ts
   interface User {
     id: number;
     name: string;
   }

   const result = await client.query.execute<User>(query);
   ```

5. **Handle connection errors**: Wrap client initialization in try-catch blocks
   ```ts
   try {
     const { client } = await getMooseClients();
   } catch (error) {
     console.error("Failed to connect:", error);
     process.exit(1);
   }
   ```
</TypeScript>

---

<TypeScript>
## Comparison: WebApp vs getMooseClients

| Feature | WebApp | getMooseClients |
|---------|--------|-----------------|
| **Use Case** | Framework within Moose project | Moose clients in external app |
| **Infrastructure** | Managed by MooseStack | Self-managed |
| **Setup Complexity** | Simple (built-in) | Moderate (manual config) |
| **Database Access** | Automatic injection | Manual initialization |
| **Workflows** | Full access | Not available |
| **Framework Choice** | Express, Koa, Fastify, Raw | Any Node.js framework |
| **Authentication** | Built-in JWT support | Manual implementation |
| **Best For** | New Moose projects | Existing applications |
</TypeScript>

---

## Troubleshooting

### WebApp Issues

<TypeScript>
**Problem: "MooseStack utilities not available"**

Solution: Ensure you're using `expressMiddleware()` for Express apps:
```ts
app.use(expressMiddleware());
```

**Problem: "mountPath cannot begin with a reserved path"**

Solution: Choose a mount path that doesn't start with `/api`, `/admin`, `/consumption`, etc.

**Problem: "WebApp with mountPath already exists"**

Solution: Ensure each WebApp has a unique `mountPath` value.
</TypeScript>

<Python>
**Problem: "Moose utilities not available"**

Solution: Verify that `inject_moose_utils` is enabled (default) in your WebAppConfig:
```python
WebAppConfig(
    mount_path="/myapi",
    inject_moose_utils=True  # This is the default
)
```

**Problem: "mountPath cannot begin with a reserved path"**

Solution: Choose a mount path that doesn't start with `/api`, `/admin`, `/consumption`, etc.

**Problem: "WebApp with mountPath already exists"**

Solution: Ensure each WebApp has a unique `mount_path` value in your Python code.

**Problem: FastAPI routes not responding**

Solution: Ensure you're passing the FastAPI app instance, not a router:
```python
# Good
app = FastAPI()
webapp = WebApp("name", app, config)

# Bad - don't pass a router directly
router = APIRouter()
webapp = WebApp("name", router, config)  # Won't work
```
</Python>

<TypeScript>
### getMooseClients Issues

**Problem: "Configuration registry not initialized"**

Solution: Ensure you've imported `@514labs/moose-lib` correctly and that Moose configuration is accessible.

**Problem: Connection timeouts**

Solution: Verify ClickHouse is running and accessible:
```bash
curl http://localhost:18123/ping
```

Check your connection parameters match your ClickHouse configuration.

**Problem: Authentication failed**

Solution: Verify your username and password match your ClickHouse setup in `moose.config.toml`.
</TypeScript>

---

## Next Steps

- [Authentication](/moose/apis/auth) - JWT configuration for securing APIs
- [Analytics APIs](/moose/apis/analytics-api) - Simple GET endpoints for data queries
- [Configuration](/moose/configuration) - Infrastructure and service configuration
