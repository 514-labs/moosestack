---
title: Bring Your Own Framework - TypeScript
description: Use Express, Koa, Fastify, or raw Node.js with MooseStack
---

import { Callout } from "@/components";
import { Tabs } from "nextra/components";

# Bring Your Own Framework - TypeScript

TypeScript developers can integrate MooseStack with popular frameworks in two ways:

1. **WebApp**: Mount Express, Koa, Fastify, or raw Node.js handlers within your Moose project
2. **getMooseClients**: Use MooseStack database clients in external, non-Moose applications

---

## WebApp: Use Frameworks in Moose

The `WebApp` class lets you mount web frameworks within your Moose project at custom paths. MooseStack automatically injects database clients and utilities into your request handlers.

### Supported Frameworks

<Callout type="info">
WebApp supports any framework with one of these patterns:
- Express/Connect-style: `.handle(req, res, next)` method
- Koa-style: `.callback()` method
- Fastify-style: `.routing` property (after calling `.ready()`)
- Raw Node.js: `(req, res) => void` function
</Callout>

### Basic Setup

<Tabs items={["Express", "Koa", "Raw Node.js"]}>
<Tabs.Tab>
```ts filename="app/apis/myExpressApp.ts" copy
import express from "express";
import { WebApp, expressMiddleware, getMooseUtils } from "@514labs/moose-lib";
import { MyTable } from "../tables/MyTable";

// Create Express app
const app = express();

app.use(express.json());
app.use(expressMiddleware()); // Required for Express

// Define routes
app.get("/health", (req, res) => {
  res.json({ status: "ok" });
});

app.get("/data", async (req, res) => {
  const moose = getMooseUtils(req);
  if (!moose) {
    return res.status(500).json({ error: "Moose utilities not available" });
  }

  const { client, sql } = moose;

  const query = sql`SELECT * FROM ${MyTable} LIMIT 10`;
  const result = await client.query.execute(query);
  const data = await result.json();

  res.json(data);
});

// Mount the app at /myapi
export const myExpressApp = new WebApp("myExpress", app, {
  mountPath: "/myapi",
  metadata: {
    description: "Custom Express API with middleware"
  }
});
```

**Access your API:**
- `GET http://localhost:4000/myapi/health`
- `GET http://localhost:4000/myapi/data`
</Tabs.Tab>

<Tabs.Tab>
```ts filename="app/apis/myKoaApp.ts" copy
import Koa from "koa";
import Router from "@koa/router";
import bodyParser from "koa-bodyparser";
import { WebApp, getMooseUtils } from "@514labs/moose-lib";
import { MyTable } from "../tables/MyTable";

const app = new Koa();
const router = new Router();

app.use(bodyParser());

router.get("/health", (ctx) => {
  ctx.body = { status: "ok" };
});

router.get("/data", async (ctx) => {
  const moose = getMooseUtils(ctx.req);
  if (!moose) {
    ctx.status = 500;
    ctx.body = { error: "Moose utilities not available" };
    return;
  }

  const { client, sql } = moose;

  const query = sql`SELECT * FROM ${MyTable} LIMIT 10`;
  const result = await client.query.execute(query);
  const data = await result.json();

  ctx.body = data;
});

app.use(router.routes());
app.use(router.allowedMethods());

// Mount the app at /myapi
export const myKoaApp = new WebApp("myKoa", app, {
  mountPath: "/myapi",
  metadata: {
    description: "Custom Koa API"
  }
});
```

**Access your API:**
- `GET http://localhost:4000/myapi/health`
- `GET http://localhost:4000/myapi/data`
</Tabs.Tab>

<Tabs.Tab>
```ts filename="app/apis/myRawApp.ts" copy
import { WebApp, getMooseUtils } from "@514labs/moose-lib";
import { MyTable } from "../tables/MyTable";
import { IncomingMessage, ServerResponse } from "http";
import { parse as parseUrl } from "url";

const handler = async (req: IncomingMessage, res: ServerResponse) => {
  const url = parseUrl(req.url || "", true);
  const pathname = url.pathname || "/";

  if (pathname === "/health" && req.method === "GET") {
    res.writeHead(200, { "Content-Type": "application/json" });
    res.end(JSON.stringify({ status: "ok" }));
    return;
  }

  if (pathname === "/data" && req.method === "GET") {
    const moose = getMooseUtils(req);
    if (!moose) {
      res.writeHead(500, { "Content-Type": "application/json" });
      res.end(JSON.stringify({ error: "Moose utilities not available" }));
      return;
    }

    const { client, sql } = moose;

    try {
      const query = sql`SELECT * FROM ${MyTable} LIMIT 10`;
      const result = await client.query.execute(query);
      const data = await result.json();

      res.writeHead(200, { "Content-Type": "application/json" });
      res.end(JSON.stringify(data));
    } catch (error) {
      res.writeHead(500, { "Content-Type": "application/json" });
      res.end(JSON.stringify({ error: String(error) }));
    }
    return;
  }

  res.writeHead(404, { "Content-Type": "application/json" });
  res.end(JSON.stringify({ error: "Not found" }));
};

// Mount the handler at /myapi
export const myRawApp = new WebApp("myRaw", handler, {
  mountPath: "/myapi",
  metadata: {
    description: "Custom raw Node.js handler"
  }
});
```

**Access your API:**
- `GET http://localhost:4000/myapi/health`
- `GET http://localhost:4000/myapi/data`
</Tabs.Tab>
</Tabs>

### WebApp Configuration

The `WebApp` constructor accepts three parameters:

```ts
new WebApp(name, appOrHandler, config)
```

**Parameters:**
- `name` (string): Unique identifier for your WebApp
- `appOrHandler` (FrameworkApp | WebAppHandler): Your framework instance or handler function
- `config` (WebAppConfig): Configuration object

**WebAppConfig:**
```ts
interface WebAppConfig {
  // Required: URL path where your app will be mounted
  mountPath: string;

  // Optional: Metadata for documentation
  metadata?: {
    description?: string;
  };

  // Optional: Whether to inject Moose utilities (default: true)
  injectMooseUtils?: boolean;
}
```

### Mount Path Rules

<Callout type="warning">
Mount paths must follow these rules:
- Cannot be `/` (root path)
- Cannot end with a trailing slash (e.g., `/api/` is invalid)
- Cannot start with reserved paths: `/admin`, `/api`, `/consumption`, `/health`, `/ingest`, `/moose`, `/ready`, `/workflows`
- Must be unique across all WebApps in your project
</Callout>

**Valid mount paths:**
- `/myapi`
- `/v1/analytics`
- `/custom/endpoint`

**Invalid mount paths:**
- `/` (root path)
- `/myapi/` (trailing slash)
- `/api/myendpoint` (starts with reserved path)

### Accessing Moose Utilities

Use `getMooseUtils()` to access MooseStack clients and helpers from your request handler:

```ts
import { getMooseUtils } from "@514labs/moose-lib";

const moose = getMooseUtils(req);
if (!moose) {
  // Handle error: Moose utilities not available
  return;
}

const { client, sql, jwt } = moose;
```

**Available utilities:**
- `client`: MooseClient for database queries
- `sql`: Template tag for safe SQL queries
- `jwt`: Parsed JWT payload (when authentication is configured)

<Callout type="info" title="Express Middleware Required">
Express applications must use the `expressMiddleware()` to access Moose utilities:

```ts
import { expressMiddleware } from "@514labs/moose-lib";

app.use(expressMiddleware());
```

Koa and raw handlers access utilities directly from `req` without middleware.
</Callout>

### Authentication with JWT

When JWT authentication is configured in `moose.config.toml`, WebApp automatically validates tokens and provides the decoded payload:

```ts
app.get("/protected", async (req, res) => {
  const moose = getMooseUtils(req);

  if (!moose?.jwt) {
    return res.status(401).json({ error: "Unauthorized" });
  }

  // Access JWT claims
  const userId = moose.jwt.sub;
  const customClaim = moose.jwt.customField;

  res.json({
    message: "Authenticated",
    userId,
    claims: moose.jwt
  });
});
```

See the [Authentication documentation](/moose/apis/auth) for JWT configuration details.

### Combining WebApp with Standard APIs

You can use WebApp alongside standard Moose `Api` in the same file:

```ts filename="app/apis/combined.ts" copy
import express from "express";
import { WebApp, Api, getMooseUtils } from "@514labs/moose-lib";

// Standard Moose API
interface Params {
  limit: number;
}

interface Result {
  id: number;
  name: string;
}

export const standardApi = new Api<Params, Result[]>(
  "standard",
  async ({ limit }, { client, sql }) => {
    // Standard Moose API implementation
    const query = sql`SELECT * FROM users LIMIT ${limit}`;
    const result = await client.query.execute(query);
    return result.json();
  }
);

// Custom Express WebApp
const app = express();
app.use(express.json());

app.get("/custom", async (req, res) => {
  const moose = getMooseUtils(req);
  // Custom Express implementation
  res.json({ message: "Custom endpoint" });
});

export const customApp = new WebApp("custom", app, {
  mountPath: "/custom"
});
```

**Access both APIs:**
- Standard: `GET http://localhost:4000/api/standard?limit=10`
- Custom: `GET http://localhost:4000/custom/custom`

---

## getMooseClients: Use Moose in External Projects

The `getMooseClients()` function initializes MooseStack database clients for use in standalone, non-Moose projects. This lets you query MooseStack's ClickHouse database from any Node.js application.

### Basic Setup

<Tabs items={["Express", "Fastify", "Standalone"]}>
<Tabs.Tab>
```ts filename="server.ts" copy
import express from "express";
import { getMooseClients, sql } from "@514labs/moose-lib";

const app = express();

// Middleware to attach Moose client to all requests
app.use(async (req, res, next) => {
  try {
    const { client } = await getMooseClients({
      host: "localhost",
      port: "18123",
      database: "local",
      username: "panda",
      password: "pandapass"
    });

    (req as any).mooseClient = client;
    next();
  } catch (error) {
    console.error("Failed to initialize Moose client:", error);
    res.status(500).json({ error: "Database connection failed" });
  }
});

// Use client in routes
app.get("/users", async (req, res) => {
  const client = (req as any).mooseClient;

  const query = sql`SELECT * FROM users LIMIT 10`;
  const result = await client.query.execute(query);
  const data = await result.json();

  res.json(data);
});

app.listen(3000, () => {
  console.log("Server running on http://localhost:3000");
});
```
</Tabs.Tab>

<Tabs.Tab>
```ts filename="server.ts" copy
import Fastify from "fastify";
import { getMooseClients, sql } from "@514labs/moose-lib";

const fastify = Fastify({ logger: true });

// Initialize client once at startup
let mooseClient: any;

fastify.addHook("onRequest", async (request, reply) => {
  if (!mooseClient) {
    const { client } = await getMooseClients({
      host: "localhost",
      port: "18123",
      database: "local"
    });
    mooseClient = client;
  }

  (request as any).mooseClient = mooseClient;
});

fastify.get("/users", async (request, reply) => {
  const client = (request as any).mooseClient;

  const query = sql`SELECT * FROM users LIMIT 10`;
  const result = await client.query.execute(query);
  const data = await result.json();

  return data;
});

fastify.listen({ port: 3000 }, (err) => {
  if (err) throw err;
  console.log("Server running on http://localhost:3000");
});
```
</Tabs.Tab>

<Tabs.Tab>
```ts filename="query.ts" copy
import { getMooseClients, sql } from "@514labs/moose-lib";

async function queryData() {
  // Initialize client
  const { client } = await getMooseClients({
    host: "localhost",
    port: "18123",
    database: "local",
    username: "panda",
    password: "pandapass"
  });

  // Execute query
  const query = sql`SELECT COUNT(*) as count FROM users`;
  const result = await client.query.execute(query);
  const data = await result.json();

  console.log("User count:", data);
}

queryData().catch(console.error);
```
</Tabs.Tab>
</Tabs>

### Configuration Options

The `getMooseClients()` function accepts an optional configuration object. All parameters are optional and will use the configuration priority system described below.

```ts
interface RuntimeClickHouseConfig {
  host?: string;        // ClickHouse host (default: "localhost")
  port?: string;        // ClickHouse HTTP port (default: "18123")
  database?: string;    // Database name (default: "local")
  username?: string;    // Username (default: "default")
  password?: string;    // Password (default: "")
  useSSL?: boolean;     // Use SSL connection (default: false)
}
```

**Environment Variable Names:**
- `MOOSE_CLICKHOUSE_CONFIG__HOST`
- `MOOSE_CLICKHOUSE_CONFIG__HOST_PORT`
- `MOOSE_CLICKHOUSE_CONFIG__DB_NAME`
- `MOOSE_CLICKHOUSE_CONFIG__USER`
- `MOOSE_CLICKHOUSE_CONFIG__PASSWORD`
- `MOOSE_CLICKHOUSE_CONFIG__USE_SSL` (accepts: `true`, `false`, `1`, `0`, `yes`, `no`, `on`, `off`)

### Configuration Priority

Configuration values are resolved in this order (highest priority first):

1. **Function parameters**: Values passed directly to `getMooseClients()`
2. **Environment variables**: Standard Moose environment variables
3. **moose.config.toml**: Configuration from your Moose project (if available)
4. **Default values**: Hardcoded fallbacks

This allows `getMooseClients()` to work in multiple scenarios:
- **Inside a Moose project**: Automatically uses your project's `moose.config.toml`
- **Outside a Moose project**: Falls back to environment variables and defaults
- **Custom configuration**: Override any value via function parameters

**Example with multiple configuration sources:**

```bash
# Set in environment or .env file
export MOOSE_CLICKHOUSE_CONFIG__HOST=production-db.example.com
export MOOSE_CLICKHOUSE_CONFIG__HOST_PORT=8123
export MOOSE_CLICKHOUSE_CONFIG__DB_NAME=analytics
export MOOSE_CLICKHOUSE_CONFIG__USER=app_user
export MOOSE_CLICKHOUSE_CONFIG__PASSWORD=secure_password
export MOOSE_CLICKHOUSE_CONFIG__USE_SSL=true
```

```toml filename="moose.config.toml"
# If this file exists, these values are used as the third priority
[clickhouse_config]
host = "localhost"
host_port = 18123
db_name = "local"
user = "panda"
password = "pandapass"
use_ssl = false
```

```ts
// Scenario 1: Uses environment variables (overrides moose.config.toml)
const { client } = await getMooseClients();
// Result: production-db.example.com:8123

// Scenario 2: Override specific values (overrides everything else)
const { client } = await getMooseClients({
  database: "custom_db"  // Uses this for database
  // host, port, etc. come from env vars or moose.config.toml
});

// Scenario 3: Outside Moose project with no env vars (uses defaults)
const { client } = await getMooseClients();
// Result: localhost:18123 with default credentials
```

<Callout type="info">
The configuration gracefully handles missing `moose.config.toml` files, making `getMooseClients()` work seamlessly in standalone applications outside of Moose projects.
</Callout>

### Using the SQL Helper

The `sql` template tag provides safe query construction with automatic escaping:

```ts
import { sql } from "@514labs/moose-lib";

const userId = 123;
const status = "active";

// Safe interpolation
const query = sql`
  SELECT * FROM users
  WHERE id = ${userId}
  AND status = ${status}
`;

const result = await client.query.execute(query);
```

<Callout type="warning">
Always use the `sql` template tag for query construction. Never concatenate user input directly into query strings.
</Callout>

### Importing Table Types from Moose Projects

You can import table schemas from Moose projects to maintain type safety:

```ts filename="external-app/src/queries.ts" copy
// Import table definitions from your Moose project
import { UserTable } from "../../moose-project/app/tables/UserTable";
import { getMooseClients, sql } from "@514labs/moose-lib";

async function queryUsers() {
  const { client } = await getMooseClients();

  // Use imported table for type-safe queries
  const query = sql`
    SELECT
      ${UserTable.columns.id},
      ${UserTable.columns.name},
      ${UserTable.columns.email}
    FROM ${UserTable}
    WHERE ${UserTable.columns.isActive} = true
  `;

  const result = await client.query.execute(query);
  return result.json();
}
```

---

## Best Practices

### WebApp Best Practices

1. **Use expressMiddleware for Express**: Always add `expressMiddleware()` before accessing Moose utilities in Express apps

2. **Check for Moose utilities**: Always verify `getMooseUtils()` returns a value before using it
   ```ts
   const moose = getMooseUtils(req);
   if (!moose) {
     return res.status(500).json({ error: "Utilities not available" });
   }
   ```

3. **Choose unique mount paths**: Ensure mount paths don't conflict with other WebApps or Moose's reserved paths

4. **Handle errors gracefully**: Wrap database queries in try-catch blocks
   ```ts
   try {
     const result = await client.query.execute(query);
     res.json(await result.json());
   } catch (error) {
     res.status(500).json({ error: String(error) });
   }
   ```

5. **Combine with standard APIs**: Use WebApp for complex routing/middleware and standard `Api` for simple GET endpoints

### getMooseClients Best Practices

1. **Initialize once**: Create the client once at application startup rather than per-request
   ```ts
   // Good: Initialize once
   const { client } = await getMooseClients();

   // Bad: Initialize per request
   app.get("/data", async (req, res) => {
     const { client } = await getMooseClients(); // Wasteful
   });
   ```

2. **Use environment variables**: Store connection details in environment variables for different environments

3. **Always use sql helper**: Use the `sql` template tag for all queries to prevent SQL injection

4. **Type your results**: Specify result types for better type safety
   ```ts
   interface User {
     id: number;
     name: string;
   }

   const result = await client.query.execute<User>(query);
   ```

5. **Handle connection errors**: Wrap client initialization in try-catch blocks
   ```ts
   try {
     const { client } = await getMooseClients();
   } catch (error) {
     console.error("Failed to connect:", error);
     process.exit(1);
   }
   ```

---

## Comparison: WebApp vs getMooseClients

| Feature | WebApp | getMooseClients |
|---------|--------|-----------------|
| **Use Case** | Framework within Moose project | Moose clients in external app |
| **Infrastructure** | Managed by MooseStack | Self-managed |
| **Setup Complexity** | Simple (built-in) | Moderate (manual config) |
| **Database Access** | Automatic injection | Manual initialization |
| **Workflows** | Full access | Not available |
| **Framework Choice** | Express, Koa, Fastify, Raw | Any Node.js framework |
| **Authentication** | Built-in JWT support | Manual implementation |
| **Best For** | New Moose projects | Existing applications |

---

## Troubleshooting

### WebApp Issues

**Problem: "MooseStack utilities not available"**

Solution: Ensure you're using `expressMiddleware()` for Express apps:
```ts
app.use(expressMiddleware());
```

**Problem: "mountPath cannot begin with a reserved path"**

Solution: Choose a mount path that doesn't start with `/api`, `/admin`, `/consumption`, etc.

**Problem: "WebApp with mountPath already exists"**

Solution: Ensure each WebApp has a unique `mountPath` value.

### getMooseClients Issues

**Problem: "Configuration registry not initialized"**

Solution: Ensure you've imported `@514labs/moose-lib` correctly and that Moose configuration is accessible.

**Problem: Connection timeouts**

Solution: Verify ClickHouse is running and accessible:
```bash
curl http://localhost:18123/ping
```

Check your connection parameters match your ClickHouse configuration.

**Problem: Authentication failed**

Solution: Verify your username and password match your ClickHouse setup in `moose.config.toml`.

---

## Next Steps

- [Python BYOF Guide](/moose/apis/bring-your-own-framework/python) - FastAPI integration
- [Authentication](/moose/apis/auth) - JWT configuration for securing APIs
- [Analytics APIs](/moose/apis/analytics-api) - Simple GET endpoints for data queries
- [Configuration](/moose/configuration) - Infrastructure and service configuration
