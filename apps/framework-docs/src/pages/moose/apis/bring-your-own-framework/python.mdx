---
title: Bring Your Own Framework - Python
description: Use FastAPI with MooseStack
---

import { Callout } from "@/components";

# Bring Your Own Framework - Python

Python developers can integrate FastAPI with MooseStack using the `WebApp` class, which mounts your FastAPI application within a Moose project and provides automatic access to database clients and utilities.

---

## WebApp: Use FastAPI in Moose

The `WebApp` class lets you mount FastAPI applications within your Moose project at custom paths. MooseStack automatically injects database clients and utilities into your request handlers.

### Supported Framework

<Callout type="info">
WebApp currently supports FastAPI applications. Pass your FastAPI app instance to the WebApp constructor.
</Callout>

### Basic Setup

```python filename="app/apis/my_fastapi_app.py" copy
from fastapi import FastAPI, Request, HTTPException
from moose_lib.dmv2 import WebApp, WebAppConfig, WebAppMetadata
from moose_lib.dmv2.web_app_helpers import get_moose_utils
from app.tables.my_table import MyTable

# Create FastAPI app
app = FastAPI()

# Health check endpoint
@app.get("/health")
async def health():
    return {"status": "ok"}

# Data endpoint
@app.get("/data")
async def get_data(request: Request, limit: int = 10):
    moose = get_moose_utils(request)
    if not moose:
        raise HTTPException(
            status_code=500,
            detail="Moose utilities not available"
        )

    # Execute query using MooseClient
    query = """
        SELECT * FROM {table}
        LIMIT {limit}
    """

    result = moose.client.query.execute(query, {
        "table": MyTable,
        "limit": limit
    })

    return {
        "success": True,
        "count": len(result),
        "data": result
    }

# Register the FastAPI app as a WebApp
my_fastapi_app = WebApp(
    "myFastApi",
    app,
    WebAppConfig(
        mount_path="/myapi",
        metadata=WebAppMetadata(
            description="Custom FastAPI application"
        )
    )
)
```

**Access your API:**
- `GET http://localhost:4000/myapi/health`
- `GET http://localhost:4000/myapi/data?limit=10`

### Complete Example with Middleware

```python filename="app/apis/bar.py" copy
from fastapi import FastAPI, Request, HTTPException, Depends
from fastapi.responses import JSONResponse
from moose_lib.dmv2 import WebApp, WebAppConfig, WebAppMetadata
from moose_lib.dmv2.web_app_helpers import get_moose_utils
from app.tables.my_table import MyTable
from pydantic import BaseModel, Field
from typing import Literal
from datetime import datetime

app = FastAPI()

# Middleware to log requests
@app.middleware("http")
async def log_requests(request: Request, call_next):
    print(f"[bar.py] {request.method} {request.url.path}")
    response = await call_next(request)
    return response

# JWT authentication dependency
async def require_auth(request: Request):
    """Require JWT authentication for protected endpoints"""
    moose = get_moose_utils(request)
    if not moose or not moose.jwt:
        raise HTTPException(
            status_code=401,
            detail="Unauthorized - JWT token required"
        )
    return moose

# Health check endpoint
@app.get("/health")
async def health():
    return {
        "status": "ok",
        "timestamp": datetime.now().isoformat(),
        "service": "bar-fastapi-api",
    }

# Query endpoint with URL parameters
@app.get("/query")
async def query(request: Request, limit: int = 10):
    moose = get_moose_utils(request)
    if not moose:
        raise HTTPException(
            status_code=500,
            detail="MooseStack utilities not available"
        )

    try:
        query_str = """
            SELECT
                day_of_month,
                total_rows
            FROM BarAggregated
            ORDER BY total_rows DESC
            LIMIT {limit}
        """

        result = moose.client.query.execute(query_str, {
            "limit": limit
        })

        return {
            "success": True,
            "count": len(result),
            "data": result,
        }
    except Exception as error:
        print(f"Query error: {error}")
        raise HTTPException(
            status_code=500,
            detail=str(error)
        )

# POST endpoint with request body validation
class DataRequest(BaseModel):
    """Request body for /data endpoint"""
    order_by: Literal["total_rows", "rows_with_text", "max_text_length"] = Field(
        default="total_rows",
        description="Column to order by"
    )
    limit: int = Field(
        default=5,
        gt=0,
        le=100,
        description="Number of records to return"
    )
    start_day: int = Field(
        default=1,
        gt=0,
        le=31,
        description="Start day of month"
    )
    end_day: int = Field(
        default=31,
        gt=0,
        le=31,
        description="End day of month"
    )

@app.post("/data")
async def data(request: Request, body: DataRequest):
    moose = get_moose_utils(request)
    if not moose:
        raise HTTPException(
            status_code=500,
            detail="MooseStack utilities not available"
        )

    try:
        query_str = """
            SELECT
                day_of_month,
                {select_column}
            FROM BarAggregated
            WHERE
                day_of_month >= {start_day}
                AND day_of_month <= {end_day}
            ORDER BY {order_by} DESC
            LIMIT {limit}
        """

        result = moose.client.query.execute(query_str, {
            "select_column": body.order_by,
            "order_by": body.order_by,
            "start_day": body.start_day,
            "end_day": body.end_day,
            "limit": body.limit
        })

        return {
            "success": True,
            "params": {
                "order_by": body.order_by,
                "limit": body.limit,
                "start_day": body.start_day,
                "end_day": body.end_day,
            },
            "count": len(result),
            "data": result,
        }
    except Exception as error:
        print(f"Query error: {error}")
        raise HTTPException(
            status_code=500,
            detail=str(error)
        )

# Protected endpoint requiring JWT authentication
@app.get("/protected")
async def protected(moose=Depends(require_auth)):
    return {
        "message": "You are authenticated",
        "user": moose.jwt.get("sub") if moose.jwt else None,
        "claims": moose.jwt,
    }

# Global error handler
@app.exception_handler(Exception)
async def global_exception_handler(request: Request, exc: Exception):
    print(f"FastAPI error: {exc}")
    return JSONResponse(
        status_code=500,
        content={
            "error": "Internal Server Error",
            "message": str(exc),
        }
    )

# Register the FastAPI app as a WebApp
bar_fastapi_app = WebApp(
    "barFastApi",
    app,
    WebAppConfig(
        mount_path="/fastapi",
        metadata=WebAppMetadata(
            description="FastAPI WebApp with middleware"
        ),
    )
)
```

### WebApp Configuration

The `WebApp` constructor accepts three parameters:

```python
WebApp(name, app, config)
```

**Parameters:**
- `name` (str): Unique identifier for your WebApp
- `app` (FastAPI): Your FastAPI application instance
- `config` (WebAppConfig): Configuration object

**WebAppConfig:**
```python
@dataclass
class WebAppConfig:
    # Required: URL path where your app will be mounted
    mount_path: str

    # Optional: Metadata for documentation
    metadata: Optional[WebAppMetadata] = None

    # Optional: Whether to inject Moose utilities (default: True)
    inject_moose_utils: bool = True

@dataclass
class WebAppMetadata:
    description: Optional[str] = None
```

### Mount Path Rules

<Callout type="warning">
Mount paths must follow these rules:
- Cannot be `/` (root path)
- Cannot end with a trailing slash (e.g., `/api/` is invalid)
- Cannot start with reserved paths: `/admin`, `/api`, `/consumption`, `/health`, `/ingest`, `/moose`, `/ready`, `/workflows`
- Must be unique across all WebApps in your project
</Callout>

**Valid mount paths:**
- `/myapi`
- `/v1/analytics`
- `/custom/endpoint`

**Invalid mount paths:**
- `/` (root path)
- `/myapi/` (trailing slash)
- `/api/myendpoint` (starts with reserved path)

### Accessing Moose Utilities

Use `get_moose_utils()` to access MooseStack clients and helpers from your request handler:

```python
from moose_lib.dmv2.web_app_helpers import get_moose_utils

@app.get("/data")
async def get_data(request: Request):
    moose = get_moose_utils(request)
    if not moose:
        raise HTTPException(
            status_code=500,
            detail="Moose utilities not available"
        )

    # Access utilities
    client = moose.client
    jwt = moose.jwt
```

**Available utilities:**
- `client`: MooseClient for database queries
- `jwt`: Parsed JWT payload (when authentication is configured)

<Callout type="info" title="FastAPI Dependency Pattern">
You can also use FastAPI's dependency injection with `get_moose_dependency()`:

```python
from moose_lib.dmv2.web_app_helpers import get_moose_dependency, ApiUtil
from fastapi import Depends

@app.get("/data")
async def get_data(moose: ApiUtil = Depends(get_moose_dependency())):
    # moose is automatically injected
    result = moose.client.query.execute(...)
    return result
```
</Callout>

### Authentication with JWT

When JWT authentication is configured in `moose.config.toml`, WebApp automatically validates tokens and provides the decoded payload:

```python
from fastapi import HTTPException, Depends

# Option 1: Manual check
@app.get("/protected")
async def protected(request: Request):
    moose = get_moose_utils(request)

    if not moose or not moose.jwt:
        raise HTTPException(
            status_code=401,
            detail="Unauthorized - JWT token required"
        )

    # Access JWT claims
    user_id = moose.jwt.get("sub")
    custom_claim = moose.jwt.get("customField")

    return {
        "message": "Authenticated",
        "userId": user_id,
        "claims": moose.jwt
    }

# Option 2: Using a dependency function
async def require_auth(request: Request):
    moose = get_moose_utils(request)
    if not moose or not moose.jwt:
        raise HTTPException(
            status_code=401,
            detail="Unauthorized"
        )
    return moose

@app.get("/protected")
async def protected(moose=Depends(require_auth)):
    return {
        "message": "Authenticated",
        "user": moose.jwt.get("sub"),
        "claims": moose.jwt
    }
```

See the [Authentication documentation](/moose/apis/auth) for JWT configuration details.

### Combining WebApp with Standard APIs

You can use WebApp alongside standard Moose `Api` in the same file:

```python filename="app/apis/combined.py" copy
from fastapi import FastAPI, Request
from moose_lib.dmv2 import Api, WebApp, WebAppConfig
from moose_lib.dmv2.web_app_helpers import get_moose_utils
from pydantic import BaseModel

# Standard Moose API
class Params(BaseModel):
    limit: int

class Result(BaseModel):
    id: int
    name: str

def query_function(client, params: Params) -> list[Result]:
    query = "SELECT * FROM users LIMIT {limit}"
    return client.query.execute(query, {"limit": params.limit})

standard_api = Api[Params, Result]("standard", query_function)

# Custom FastAPI WebApp
app = FastAPI()

@app.get("/custom")
async def custom(request: Request):
    moose = get_moose_utils(request)
    # Custom FastAPI implementation
    return {"message": "Custom endpoint"}

custom_app = WebApp(
    "custom",
    app,
    WebAppConfig(mount_path="/custom")
)
```

**Access both APIs:**
- Standard: `GET http://localhost:4000/api/standard?limit=10`
- Custom: `GET http://localhost:4000/custom/custom`

---

## Best Practices

### WebApp Best Practices

1. **Check for Moose utilities**: Always verify `get_moose_utils()` returns a value before using it
   ```python
   moose = get_moose_utils(request)
   if not moose:
       raise HTTPException(
           status_code=500,
           detail="Moose utilities not available"
       )
   ```

2. **Use FastAPI dependencies**: Leverage FastAPI's `Depends()` for cleaner authentication
   ```python
   async def require_auth(request: Request):
       moose = get_moose_utils(request)
       if not moose or not moose.jwt:
           raise HTTPException(status_code=401)
       return moose

   @app.get("/protected")
   async def protected(moose=Depends(require_auth)):
       return {"user": moose.jwt.get("sub")}
   ```

3. **Choose unique mount paths**: Ensure mount paths don't conflict with other WebApps or Moose's reserved paths

4. **Handle errors gracefully**: Use FastAPI's exception handling
   ```python
   from fastapi.responses import JSONResponse

   @app.exception_handler(Exception)
   async def global_exception_handler(request: Request, exc: Exception):
       return JSONResponse(
           status_code=500,
           content={"error": str(exc)}
       )
   ```

5. **Validate request data**: Use Pydantic models for automatic validation
   ```python
   class DataRequest(BaseModel):
       limit: int = Field(gt=0, le=100)
       order_by: str = Field(pattern="^(id|name|created_at)$")
   ```

6. **Use async endpoints**: FastAPI supports async/await for better performance
   ```python
   @app.get("/data")
   async def get_data(request: Request):
       # Use async for I/O operations
       result = moose.client.query.execute(query, params)
       return result
   ```

7. **Add middleware for logging**: Use FastAPI middleware for request/response logging
   ```python
   @app.middleware("http")
   async def log_requests(request: Request, call_next):
       print(f"{request.method} {request.url.path}")
       response = await call_next(request)
       return response
   ```

8. **Document your endpoints**: Use FastAPI's built-in documentation features
   ```python
   @app.get("/data", summary="Get data", description="Retrieve data with pagination")
   async def get_data(
       request: Request,
       limit: int = Field(10, description="Number of records to return")
   ):
       ...
   ```

---

## Troubleshooting

### WebApp Issues

**Problem: "Moose utilities not available"**

Solution: Verify that `inject_moose_utils` is enabled (default) in your WebAppConfig:
```python
WebAppConfig(
    mount_path="/myapi",
    inject_moose_utils=True  # This is the default
)
```

**Problem: "mountPath cannot begin with a reserved path"**

Solution: Choose a mount path that doesn't start with `/api`, `/admin`, `/consumption`, etc.

**Problem: "WebApp with mountPath already exists"**

Solution: Ensure each WebApp has a unique `mount_path` value in your Python code.

**Problem: FastAPI routes not responding**

Solution: Ensure you're passing the FastAPI app instance, not a router:
```python
# Good
app = FastAPI()
webapp = WebApp("name", app, config)

# Bad - don't pass a router directly
router = APIRouter()
webapp = WebApp("name", router, config)  # Won't work
```

**Problem: JWT claims not accessible**

Solution: Ensure JWT is configured in `moose.config.toml` and check that the token is being passed correctly:
```python
moose = get_moose_utils(request)
if moose and moose.jwt:
    print(f"JWT claims: {moose.jwt}")
else:
    print("No JWT found in request")
```

**Problem: Database queries failing**

Solution: Check that your table references are correct and the table exists:
```python
# Make sure to import and reference tables correctly
from app.tables.my_table import MyTable

query = "SELECT * FROM {table}"
result = moose.client.query.execute(query, {"table": MyTable})
```

---

## Next Steps

- [TypeScript BYOF Guide](/moose/apis/bring-your-own-framework/typescript) - Express, Koa, and getMooseClients
- [Authentication](/moose/apis/auth) - JWT configuration for securing APIs
- [Analytics APIs](/moose/apis/analytics-api) - Simple GET endpoints for data queries
- [Configuration](/moose/configuration) - Infrastructure and service configuration
