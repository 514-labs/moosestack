---
title: Querying Data
description: Query OLAP tables using SQL with type safety
---

import { Callout, BulletPointsCard, CheckmarkBullets, LanguageSwitcher, TypeScript, Python, CTACard, CTACards } from "@/components";
import { Tabs } from "nextra/components";

# Querying Data

<LanguageSwitcher />

Moose provides type-safe SQL querying for your `OlapTable` and `MaterializedView` instances. Use cases include:

- Building APIs to expose your data to client/frontend applications
- Building transformation pipelines inside your database with materialized views

## Querying with MooseClient

Use `MooseClient` to query data from existing tables and materialized views.

### Basic Querying

<TypeScript>
```ts filename="BasicQuerying.ts"
import { MooseClient, sql } from "@514labs/moose-lib";
import { UserTable } from "./tables/UserTable";

const client = new MooseClient();

// Query existing table
const query = sql`
  SELECT id, name, email
  FROM ${UserTable}
  WHERE status = 'active'
  LIMIT 10
`;

const result = await client.query.execute(query);
const data = await result.json();
```
</TypeScript>

<Python>
<Tabs items={["execute_raw (Recommended)", "f-strings (Simple cases)"]}>
<Tabs.Tab>
Use `execute_raw` with parameter binding for safe, typed queries:

```py filename="BasicQuerying.py"
from moose_lib import MooseClient

client = MooseClient()

# Query existing table using execute_raw with explicit ClickHouse types
query = """
  SELECT id, name, email
  FROM users
  WHERE status = {status:String}
  LIMIT {limit:UInt32}
"""

rows = client.query.execute_raw(query, {
    "status": "active",
    "limit": 10
})
```
</Tabs.Tab>
<Tabs.Tab>
Use f-strings with `execute` for simple, static queries:

```py filename="BasicQueryingFString.py"
from moose_lib import MooseClient
from app.UserTable import UserTable
client = MooseClient()

# Simple f-string query (only for trusted, static data)
status = "active"
limit = 10
query = """
  SELECT id, name, email
  FROM {table: Identifier}
  WHERE status = {status:String}
  LIMIT {limit:UInt32}
"""
rows = client.query.execute(query, {"table": UserTable, "status": status, "limit": limit})

rows = client.query.execute(query)
```
</Tabs.Tab>
</Tabs>
</Python>

### Querying Materialized Views

<TypeScript>
```ts filename="QueryMaterializedView.ts"
import { MooseClient, sql } from "@514labs/moose-lib";

const client = new MooseClient();

// Query existing materialized view
const query = sql`
  SELECT user_id, total_orders, average_order_value
  FROM user_stats_view
  WHERE total_orders > 10
  ORDER BY average_order_value DESC
`;

const result = await client.query.execute(query);
```
</TypeScript>

<Python>
<Tabs items={["execute_raw (Recommended)", "f-strings (Simple cases)"]}>
<Tabs.Tab>
Use `execute_raw` with parameter binding:

```py filename="QueryMaterializedView.py"
from moose_lib import MooseClient

client = MooseClient()

# Query existing materialized view
query = """
  SELECT user_id, total_orders, average_order_value
  FROM user_stats_view
  WHERE total_orders > {minOrders:UInt32}
  ORDER BY average_order_value DESC
"""

rows = client.query.execute_raw(query, {"minOrders": 10})
```
</Tabs.Tab>
<Tabs.Tab>
Use f-strings with `execute`:

```py filename="QueryMaterializedViewFString.py"
from moose_lib import MooseClient

client = MooseClient()

# Simple f-string query
min_orders = 10
query = """
  SELECT user_id, total_orders, average_order_value
  FROM user_stats_view
  WHERE total_orders > {minOrders:UInt32}
  ORDER BY average_order_value DESC
"""
rows = client.query.execute_raw(query, {"minOrders": min_orders})

rows = client.query.execute(query)
```
</Tabs.Tab>
</Tabs>
</Python>

## Select With Column and Table References

<TypeScript>
```ts filename="TypedReferences.ts"
import { sql } from "@514labs/moose-lib";
import { UserTable, OrderTable } from "./tables";

// Reference table columns with type safety
const cols = UserTable.columns;
const query = sql`
  SELECT 
    ${cols.id},
    ${cols.name},
    ${cols.email}
  FROM ${UserTable}
  WHERE ${cols.status} = 'active'
`;

// Multiple table references
const joinQuery = sql`
  SELECT 
    ${UserTable.columns.id},
    ${UserTable.columns.name},
    ${OrderTable.columns.order_value}
  FROM ${UserTable}
  JOIN ${OrderTable} ON ${UserTable.columns.id} = ${OrderTable.columns.user_id}
`;
```

When you query a materialized view, you reference the `MaterializedView.targetTable` to get the columns of the target table.


```ts filename="TypedReferences.ts"
import { sql } from "@514labs/moose-lib";
import { ExampleMaterializedView } from "./materialized-views";


const query = sql`
  SELECT 
    ${ExampleMaterializedView.targetTable.columns.id},
    ${ExampleMaterializedView.targetTable.columns.name},
    ${ExampleMaterializedView.targetTable.columns.email}
  FROM ${ExampleMaterializedView.targetTable}
`;
```

In ClickHouse, when you query a Materialized View that has columns of type `AggregateFunction` in the result set, ordinarily you would need to run:

```sql
SELECT sumMerge(amount) FROM {ExampleMaterializedView}
```

When querying this with Moose, you can just reference the column name in the `sql` template literal. The interpolation will be replaced with the correct ClickHouse function:

```ts filename="TypedReferences.ts"
import { sql } from "@514labs/moose-lib";
import { ExampleMaterializedView } from "./materialized-views";

const query = sql`
  SELECT ${ExampleMaterializedView.targetTable.columns.amount}
  FROM ${ExampleMaterializedView.targetTable}
`;

// This will be replaced with:
// SELECT sumMerge(amount) FROM {ExampleMaterializedView}
```
</TypeScript>

<Python>
<Tabs items={["execute_raw (Recommended)", "f-strings (Simple cases)"]}>
<Tabs.Tab>
Use `execute_raw` with parameter binding:

```py filename="TypedReferences.py"
from moose_lib import MooseClient

client = MooseClient()

# Use parameter binding with explicit identifiers
query = """
  SELECT 
    id,
    name,
    email
  FROM {table: Identifier}
  WHERE status = {status:String}
"""

# Multiple table references (static names)
join_query = """
  SELECT 
    u.id,
    u.name,
    o.order_value
  FROM users u
  JOIN orders o ON u.id = o.user_id
"""

rows = client.query.execute_raw(query, {"status": "active"})
```
</Tabs.Tab>
<Tabs.Tab>
When using f-strings with `execute` you can reference the column names directly in your query:

```py filename="TypedReferencesFString.py"
from moose_lib import MooseClient
from app.UserTable import UserTable
client = MooseClient()

# Simple f-string queries
status = "active"
query = """
  SELECT 
    id,
    name,
    email
  FROM {table: Identifier}
  WHERE status = {status:String}
"""
rows = client.query.execute(query, {"table": UserTable, "status": status})

# Multiple table references (static example)
join_query = """
  SELECT 
    u.id,
    u.name,
    o.order_value
  FROM users u
  JOIN orders o ON u.id = o.user_id
"""

rows = client.query.execute(query)
```
</Tabs.Tab>
</Tabs>
</Python>

## Filtering with WHERE Clauses

<TypeScript>
```ts filename="WhereClauses.ts"
import { sql } from "@514labs/moose-lib";

// Multiple WHERE conditions
const filterQuery = sql`
  SELECT ${UserTable.columns.id}, ${UserTable.columns.name}
  FROM ${UserTable}
  WHERE ${UserTable.columns.status} = 'active'
    AND ${UserTable.columns.created_at} > '2024-01-01'
    AND ${UserTable.columns.email} ILIKE ${'%' + searchTerm + '%'}
`;

// Using IN clauses
const inQuery = sql`
  SELECT * FROM ${UserTable}
  WHERE ${UserTable.columns.id} IN (${userIds})
`;

// Using BETWEEN
const rangeQuery = sql`
  SELECT * FROM ${UserTable}
  WHERE ${UserTable.columns.age} BETWEEN ${minAge} AND ${maxAge}
`;
```
</TypeScript>

<Python>
<Tabs items={["execute_raw (Recommended)", "f-strings (Simple cases)"]}>
<Tabs.Tab>
Use `execute_raw` with parameter binding:

```py filename="WhereClauses.py"
from moose_lib import MooseClient

client = MooseClient()

# Multiple WHERE conditions
filter_query = """
  SELECT id, name
  FROM users
  WHERE status = {status:String}
    AND created_at > {startDate:DateTime}
    AND email ILIKE {searchPattern:String}
"""

# Using BETWEEN
range_query = """
  SELECT * FROM users
  WHERE age BETWEEN {minAge:UInt32} AND {maxAge:UInt32}
"""

# Using IN with typed arrays
in_query = """
  SELECT * FROM users
  WHERE id IN {userIds:Array(UInt32)}
"""

# Execute examples
filter_rows = client.query.execute_raw(filter_query, {
    "status": "active",
    "startDate": "2024-01-01",
    "searchPattern": "%example%"
})

range_rows = client.query.execute_raw(range_query, {
    "minAge": 18,
    "maxAge": 65
})

in_rows = client.query.execute_raw(in_query, {
    "userIds": [1, 2, 3, 4, 5]
})
```
</Tabs.Tab>
<Tabs.Tab>
Use f-strings with `execute`:

```py filename="WhereClausesFString.py"
from moose_lib import MooseClient

client = MooseClient()

# Simple f-string queries (only for trusted, static data)
status = "active"
start_date = "2024-01-01"
search_pattern = "%example%"
min_age = 18
max_age = 65
user_ids = [1, 2, 3, 4, 5]

# Multiple WHERE conditions
filter_query = """
  SELECT id, name
  FROM {table: Identifier}
  WHERE status = {status:String}
    AND created_at > {startDate:DateTime}
    AND email ILIKE {searchPattern:String}
"""

# Using BETWEEN
range_query = """
  SELECT * FROM {table: Identifier}
  WHERE age BETWEEN {minAge:UInt32} AND {maxAge:UInt32}
"""

# Using IN
in_query = """
  SELECT * FROM {table: Identifier}
  WHERE id IN {userIds:Array(UInt32)}
"""

# Execute examples
filter_rows = client.query.execute_raw(filter_query, {"table": UserTable, "status": status, "startDate": start_date, "searchPattern": search_pattern})
range_rows = client.query.execute_raw(range_query, {"table": UserTable, "minAge": min_age, "maxAge": max_age})
in_rows = client.query.execute_raw(in_query, {"table": UserTable, "userIds": user_ids})
```
</Tabs.Tab>
</Tabs>
</Python>

## Dynamic Query Building

<TypeScript>
```ts filename="DynamicQueries.ts"
import { sql, ApiHelpers as CH } from "@514labs/moose-lib";

interface QueryParams {
  sortBy: string;
  fields: string[];
  filters: Record<string, any>;
}

const buildDynamicQuery = ({ sortBy, fields, filters }: QueryParams) => {
  // Build field list
  const fieldList = fields.map(field => sql`${CH.column(field)}`);
  
  // Build WHERE conditions
  const conditions = Object.entries(filters)
    .filter(([_, value]) => value !== undefined)
    .map(([key, value]) => sql`${CH.column(key)} = ${value}`);
  
  let query = sql`
    SELECT ${fieldList.join(', ')}
    FROM ${UserTable}
  `;
  
  if (conditions.length > 0) {
    query = sql`${query} WHERE ${conditions.join(' AND ')}`;
  }
  
  query = sql`${query} ORDER BY ${CH.column(sortBy)}`;
  
  return query;
};
```
</TypeScript>

<Python>
<Tabs items={["execute_raw (Recommended)", "f-strings (Simple cases)"]}>
<Tabs.Tab>
Use `execute_raw` with parameter binding:

```py filename="DynamicQueries.py"
from moose_lib import MooseClient
from typing import Dict, Any

client = MooseClient()

def build_dynamic_query(filters: Dict[str, str], sort_by: str, limit: int):
    conditions: list[str] = []
    params: Dict[str, Any] = {}

    # Known valid columns - validate against this list
    valid_columns = {"status", "age", "city", "department"}
    
    for key, value in filters.items():
        if value is not None and key in valid_columns:
            conditions.append(f"{key} = {{{key}:String}}")
            params[key] = value

    query = "SELECT * FROM users"

    if conditions:
        query += " WHERE " + " AND ".join(conditions)

    # Use f-string for column name (validate first!)
    query += f" ORDER BY {sort_by} LIMIT {{limit:UInt32}}"
    params["limit"] = limit

    return client.query.execute_raw(query, params)

# Usage example
filters = {"status": "active", "city": "New York"}
result = build_dynamic_query(filters, "created_at", 10)
```
</Tabs.Tab>
<Tabs.Tab>
Use f-strings with `execute` (only for trusted, validated input):

```py filename="DynamicQueriesFString.py"
from moose_lib import MooseClient
from typing import Dict, Any

client = MooseClient()

def build_dynamic_query(filters: Dict[str, Any], sort_by: str, limit: int):
    conditions: list[str] = []

    # Known valid columns and values - validate against these
    valid_columns = {"status", "age", "city", "department"}
    valid_statuses = {"active", "inactive", "pending"}
    valid_sort_columns = {"id", "name", "created_at", "age"}

    # Validate sort_by column
    if sort_by not in valid_sort_columns:
        raise ValueError(f"Invalid sort column: {sort_by}")

    for key, value in filters.items():
        if value is not None and key in valid_columns:
            # Additional validation for specific columns
            if key == "status" and value not in valid_statuses:
                raise ValueError(f"Invalid status: {value}")
            
            # WARNING: Only use with validated input to prevent SQL injection
            conditions.append(f"{key} = '{value}'")

    query = "SELECT * FROM {table: Identifier}"

    if conditions:
        query += " WHERE " + " AND ".join(conditions)

    # Include column name directly (already validated!) and bind limit
    query += f" ORDER BY {sort_by} LIMIT {{limit:UInt32}}"

    return client.query.execute(query, {"table": UserTable, "limit": limit})

# Usage example
filters = {"status": "active", "city": "New York"}
result = build_dynamic_query(filters, "created_at", 10)
```
</Tabs.Tab>
</Tabs>
</Python>

### Interpolation and Security

<TypeScript>
Use the `sql` template literal to build safe queries:

```ts filename="SqlTemplateLiterals.ts"
import { sql } from "@514labs/moose-lib";

// Safe interpolation with sql template literal
const status = 'active';
const limit = 10;

const query = sql`
  SELECT id, name, email
  FROM ${UserTable}
  WHERE ${UserTable.columns.status} = ${status}
  LIMIT ${limit}
`;

// Conditional WHERE clauses
interface FilterParams {
  minAge?: number;
  status?: "active" | "inactive";
  searchText?: string;
}

const buildConditionalQuery = (filters: FilterParams) => {
  let conditions = [];
  
  if (filters.minAge !== undefined) {
    conditions.push(sql`age >= ${filters.minAge}`);
  }
  
  if (filters.status) {
    conditions.push(sql`status = ${filters.status}`);
  }
  
  if (filters.searchText) {
    conditions.push(sql`(name ILIKE ${'%' + filters.searchText + '%'} OR email ILIKE ${'%' + filters.searchText + '%'})`);
  }
  
  let query = sql`SELECT * FROM ${UserTable}`;
  
  if (conditions.length > 0) {
    query = sql`${query} WHERE ${conditions.join(' AND ')}`;
  }
  
  return sql`${query} ORDER BY created_at DESC`;
};
```
</TypeScript>

<Python>

Moose provides two distinct approaches for executing queries in Python. Choose the right one for your use case:

- Option 1: Use `execute_raw` with parameter binding
- Option 2: Use f-strings with `execute`

<Tabs items={["execute_raw", "execute"]}>
<Tabs.Tab>
**Use when:** You have dynamic identifiers (table names, column names) that aren't known until query time, or when you need server-side parameter binding.

**What it does:** Exposes the underlying ClickHouse driver with server-side parameter binding for values, while allowing dynamic identifiers in the query string.

**Benefits:** 
- Server-side parameter binding for values (prevents SQL injection)
- Dynamic table/column names in query structure
- Automatic type conversion for bound parameters

```py filename="ParameterBinding.py"
from moose_lib import MooseClient

client = MooseClient()

# Example: Dynamic table and column selection with server-side parameter binding
def query_user_data(table_name: str, status_filter: str, limit: int):
    # Dynamic identifiers in query structure, bound parameters for values
    query = """
      SELECT id, name, email
      FROM {table_name:Identifier}  # Dynamic table name
      WHERE status = {{status:String}}  # Server-side parameter binding
        AND created_at > {{startDate:DateTime}}
      LIMIT {{limit:UInt32}}
    """
    
    return client.query.execute_raw(query, {
        "table_name": table_name,  # Bound parameter
        "status": status_filter,  # Bound parameter
        "startDate": "2024-01-01T00:00:00",  # Bound parameter
        "limit": limit  # Bound parameter
    })

# Usage with different tables
users_data = query_user_data("users", "active", 10)
admins_data = query_user_data("admin_users", "pending", 5)

# Conditional WHERE clauses
def build_conditional_query(client: MooseClient, params: FilterParams):
    conditions: list[str] = []
    parameters: dict = {}

    if params.min_age is not None:
        conditions.append("age >= {minAge:UInt32}")
        parameters["minAge"] = params.min_age

    if params.status:
        conditions.append("status = {status:String}")
        parameters["status"] = params.status

    if params.search_text:
        conditions.append("(name ILIKE {searchPattern:String} OR email ILIKE {searchPattern:String})")
        parameters["searchPattern"] = f"%{params.search_text}%"

    query = "SELECT * FROM users"

    if conditions:
        query += " WHERE " + " AND ".join(conditions)

    query += " ORDER BY created_at DESC"

    return client.query.execute_raw(query, parameters)
```
</Tabs.Tab>
<Tabs.Tab>
**Use when:**
Have Moose to provide the types for the parameters in the generated SQL.
Use Moose objects for dynamic identifies.

```py filename="execute.py"
from moose_lib import MooseClient
from pydantic import BaseModel, Field, validator
from typing import Optional

client = MooseClient()

# Example: Static query with validated parameters
def get_active_users(status: str, limit: int):
    # Static table/column names, validated parameters
    query = """
        SELECT id, name, email
        FROM {table}
        WHERE status = {status}
        LIMIT {limit}
    """
    return client.query.execute(query, {"table": UserTable, "status": status, "limit": limit})

# Usage with validated input
active_users = get_active_users("active", 10)

class UserQueryParams(BaseModel):
    status: str = Field(..., pattern=r"^(active|inactive|pending)$")
    limit: int = Field(default=10, ge=1, le=1000)

def build_validated_query(params: UserQueryParams):
    # All parameters are validated by Pydantic
    query = """
        SELECT id, name, email
        FROM {table}
        WHERE status = {status}
        LIMIT {limit}
    """
    
    return client.query.execute(query, {"table": UserTable, "status": params.status, "limit": params.limit})
```
</Tabs.Tab>
</Tabs>

<Callout type="warning">
**Security Guidelines:**
- **execute_raw**: Use when you have dynamic identifiers (table/column names) or need server-side parameter binding
- **execute with f-strings**: Only for static queries with known table/column names and validated parameters
- Always validate input with Pydantic when using f-strings
- Never use f-strings with unvalidated user input or dynamic identifiers
- When in doubt, use execute_raw for maximum security
</Callout>

</Python>


## Building APIs

To build REST APIs that expose your data, see the [Analytics APIs documentation](/moose/apis/analytics-api) for comprehensive examples and patterns.


## Common Pitfalls

<TypeScript>
<Callout type="warning" title="Common TypeScript Issues">
- **Column name typos**: Use `UserTable.columns.columnName` for autocomplete
- **Type mismatches**: Ensure your schema types match ClickHouse types
- **Missing imports**: Import your table definitions before using them
- **Template literal syntax**: Use backticks `sql` not regular strings
- **Forgetting await**: Always await `client.query.execute()`
</Callout>
</TypeScript>


## Performance Optimization
If your query is slower than expected, there are a few things you can check:

- If using filters, try to filter on a column that is defined in the `orderByFields` of the table
- For common queries, consider [creating a materialized view](/stack/olap/create-materialized-view) to pre-compute the result set


## Further Reading

<CTACards columns={1}>
<CTACard
  title="Moose APIs"
  description="Build REST APIs for your data with built-in Moose API module"
  ctaLink="/stack/apis/egress"
  ctaLabel="Learn More →"
  orientation="horizontal"
/>
<CTACard
  title="Creating Materialized Views"
  description="Define data transformations"
  ctaLink="/stack/olap/create-materialized-view"
  ctaLabel="Learn More →"
  orientation="horizontal"
/>
</CTACards>

