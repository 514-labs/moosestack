---
title: Querying Data
description: Query OLAP tables using SQL with type safety
---

import { Callout, BulletPointsCard, CheckmarkBullets, LanguageSwitcher, TypeScript, Python, CTACard, CTACards } from "@/components";
import { Tabs } from "nextra/components";

# Querying Data

<LanguageSwitcher />

Moose provides type-safe SQL querying for your `OlapTable` and `MaterializedView` instances. Use cases include:

- Building APIs to expose your data to client/frontend applications
- Building transformation pipelines inside your database with materialized views

## Querying with MooseClient

Use `MooseClient` to query data from existing tables and materialized views.

### Basic Querying

<TypeScript>
```ts filename="BasicQuerying.ts"
import { MooseClient, sql } from "@514labs/moose-lib";
import { UserTable } from "./tables/UserTable";

const client = new MooseClient();

// Query existing table
const query = sql`
  SELECT id, name, email 
  FROM ${UserTable}
  WHERE status = 'active'
  LIMIT 10
`;

const result = await client.query.execute(query);
const data = await result.json();
```
</TypeScript>

<Python>
<Tabs items={["execute_raw (Recommended)", "f-strings (Simple cases)"]}>
<Tabs.Tab>
Use `execute_raw` with parameter binding for safe, typed queries:

```py filename="BasicQuerying.py"
from moose_lib import MooseClient

client = MooseClient()

# Query existing table using execute_raw with explicit ClickHouse types
query = """
  SELECT id, name, email 
  FROM users
  WHERE status = {status:String}
  LIMIT {limit:UInt32}
"""

rows = client.query.execute_raw(query, {
    "status": "active",
    "limit": 10
})
```
</Tabs.Tab>
<Tabs.Tab>
Use f-strings with `execute` for simple, static queries:

```py filename="BasicQueryingFString.py"
from moose_lib import MooseClient
from app.UserTable import UserTable
client = MooseClient()

# Simple f-string query (only for trusted, static data)
status = "active"
limit = 10
query = f"""
  SELECT {UserTable.columns.id}, {UserTable.columns.name}, {UserTable.columns.email} 
  FROM {UserTable.name}
  WHERE {UserTable.columns.status} = '{status}'
  LIMIT {limit}
"""

rows = client.query.execute(query)
```
</Tabs.Tab>
</Tabs>
</Python>

### Querying Materialized Views

<TypeScript>
```ts filename="QueryMaterializedView.ts"
import { MooseClient, sql } from "@514labs/moose-lib";

const client = new MooseClient();

// Query existing materialized view
const query = sql`
  SELECT user_id, total_orders, average_order_value
  FROM user_stats_view
  WHERE total_orders > 10
  ORDER BY average_order_value DESC
`;

const result = await client.query.execute(query);
```
</TypeScript>

<Python>
<Tabs items={["execute_raw (Recommended)", "f-strings (Simple cases)"]}>
<Tabs.Tab>
Use `execute_raw` with parameter binding:

```py filename="QueryMaterializedView.py"
from moose_lib import MooseClient

client = MooseClient()

# Query existing materialized view
query = """
  SELECT user_id, total_orders, average_order_value
  FROM user_stats_view
  WHERE total_orders > {minOrders:UInt32}
  ORDER BY average_order_value DESC
"""

rows = client.query.execute_raw(query, {"minOrders": 10})
```
</Tabs.Tab>
<Tabs.Tab>
Use f-strings with `execute`:

```py filename="QueryMaterializedViewFString.py"
from moose_lib import MooseClient

client = MooseClient()

# Simple f-string query
min_orders = 10
query = f"""
  SELECT user_id, total_orders, average_order_value
  FROM user_stats_view
  WHERE total_orders > {min_orders}
  ORDER BY average_order_value DESC
"""

rows = client.query.execute(query)
```
</Tabs.Tab>
</Tabs>
</Python>

## Select With Column and Table References

<TypeScript>
```ts filename="TypedReferences.ts"
import { sql } from "@514labs/moose-lib";
import { UserTable, OrderTable } from "./tables";

// Reference table columns with type safety
const cols = UserTable.columns;
const query = sql`
  SELECT 
    ${cols.id},
    ${cols.name},
    ${cols.email}
  FROM ${UserTable}
  WHERE ${cols.status} = 'active'
`;

// Multiple table references
const joinQuery = sql`
  SELECT 
    ${UserTable.columns.id},
    ${UserTable.columns.name},
    ${OrderTable.columns.order_value}
  FROM ${UserTable}
  JOIN ${OrderTable} ON ${UserTable.columns.id} = ${OrderTable.columns.user_id}
`;
```

When you query a materialized view, you reference the `MaterializedView.targetTable` to get the columns of the target table.


```ts filename="TypedReferences.ts"
import { sql } from "@514labs/moose-lib";
import { ExampleMaterializedView } from "./materialized-views";


const query = sql`
  SELECT 
    ${ExampleMaterializedView.targetTable.columns.id},
    ${ExampleMaterializedView.targetTable.columns.name},
    ${ExampleMaterializedView.targetTable.columns.email}
  FROM ${ExampleMaterializedView.targetTable}
`;
```

In ClickHouse, when you query a Materialized View that has columns of type `AggregateFunction` in the result set, ordinarily you would need to run:

```sql
SELECT sumMerge(amount) FROM {ExampleMaterializedView}
```

When querying this with Moose, you can just reference the column name in the `sql` template literal. The interpolation will be replaced with the correct ClickHouse function:

```ts filename="TypedReferences.ts"
import { sql } from "@514labs/moose-lib";
import { ExampleMaterializedView } from "./materialized-views";

const query = sql`
  SELECT ${ExampleMaterializedView.targetTable.columns.amount}
  FROM ${ExampleMaterializedView.targetTable}
`;

// This will be replaced with:
// SELECT sumMerge(amount) FROM {ExampleMaterializedView}
```
</TypeScript>

<Python>
<Tabs items={["execute_raw (Recommended)", "f-strings (Simple cases)"]}>
<Tabs.Tab>
Use `execute_raw` with parameter binding:

```py filename="TypedReferences.py"
from moose_lib import MooseClient

client = MooseClient()

# Python API does not expose typed column references; use explicit identifiers
query = """
  SELECT 
    id,
    name,
    email
  FROM users
  WHERE status = {status:String}
"""

# Multiple table references
join_query = """
  SELECT 
    u.id,
    u.name,
    o.order_value
  FROM users u
  JOIN orders o ON u.id = o.user_id
"""

rows = client.query.execute_raw(query, {"status": "active"})
```
</Tabs.Tab>
<Tabs.Tab>
When using f-strings with `execute` you can reference the column names directly in your query:

```py filename="TypedReferencesFString.py"
from moose_lib import MooseClient
from app.UserTable import UserTable
client = MooseClient()

# Simple f-string queries
status = "active"
query = f"""
  SELECT 
    {UserTable.columns.id},
    {UserTable.columns.name},
    {UserTable.columns.email}
  FROM {UserTable.name}
  WHERE {UserTable.columns.status} = '{status}'
"""

# Multiple table references
join_query = f"""
  SELECT 
    u.{UserTable.columns.id},
    u.{UserTable.columns.name},
    o.{OrderTable.columns.order_value}
  FROM {UserTable.name} u
  JOIN {OrderTable.name} o ON u.{UserTable.columns.id} = o.{OrderTable.columns.user_id}
"""

rows = client.query.execute(query)
```
</Tabs.Tab>
</Tabs>
</Python>

## Filtering with WHERE Clauses

<TypeScript>
```ts filename="WhereClauses.ts"
import { sql } from "@514labs/moose-lib";

// Multiple WHERE conditions
const filterQuery = sql`
  SELECT ${UserTable.columns.id}, ${UserTable.columns.name}
  FROM ${UserTable}
  WHERE ${UserTable.columns.status} = 'active'
    AND ${UserTable.columns.created_at} > '2024-01-01'
    AND ${UserTable.columns.email} ILIKE ${'%' + searchTerm + '%'}
`;

// Using IN clauses
const inQuery = sql`
  SELECT * FROM ${UserTable}
  WHERE ${UserTable.columns.id} IN (${userIds})
`;

// Using BETWEEN
const rangeQuery = sql`
  SELECT * FROM ${UserTable}
  WHERE ${UserTable.columns.age} BETWEEN ${minAge} AND ${maxAge}
`;
```
</TypeScript>

<Python>
<Tabs items={["execute_raw (Recommended)", "f-strings (Simple cases)"]}>
<Tabs.Tab>
Use `execute_raw` with parameter binding:

```py filename="WhereClauses.py"
from moose_lib import MooseClient

client = MooseClient()

# Multiple WHERE conditions
filter_query = """
  SELECT id, name
  FROM users
  WHERE status = {status:String}
    AND created_at > {startDate:DateTime}
    AND email ILIKE {searchPattern:String}
"""

# Using BETWEEN
range_query = """
  SELECT * FROM users
  WHERE age BETWEEN {minAge:UInt32} AND {maxAge:UInt32}
"""

# Using IN with typed arrays
in_query = """
  SELECT * FROM users
  WHERE id IN {userIds:Array(UInt32)}
"""

# Execute examples
filter_rows = client.query.execute_raw(filter_query, {
    "status": "active",
    "startDate": "2024-01-01",
    "searchPattern": "%example%"
})

range_rows = client.query.execute_raw(range_query, {
    "minAge": 18,
    "maxAge": 65
})

in_rows = client.query.execute_raw(in_query, {
    "userIds": [1, 2, 3, 4, 5]
})
```
</Tabs.Tab>
<Tabs.Tab>
Use f-strings with `execute`:

```py filename="WhereClausesFString.py"
from moose_lib import MooseClient

client = MooseClient()

# Simple f-string queries (only for trusted, static data)
status = "active"
start_date = "2024-01-01"
search_pattern = "%example%"
min_age = 18
max_age = 65
user_ids = [1, 2, 3, 4, 5]

# Multiple WHERE conditions
filter_query = f"""
  SELECT {UserTable.columns.id}, {UserTable.columns.name}
  FROM {UserTable.name}
  WHERE {UserTable.columns.status} = '{status}'
    AND {UserTable.columns.created_at} > '{start_date}'
    AND {UserTable.columns.email} ILIKE '{search_pattern}'
"""

# Using BETWEEN
range_query = f"""
  SELECT * FROM {UserTable.name}
  WHERE {UserTable.columns.age} BETWEEN {min_age} AND {max_age}
"""

# Using IN
in_query = f"""
  SELECT * FROM {UserTable.name}
  WHERE {UserTable.columns.id} IN ({','.join(map(str, user_ids))})
"""

# Execute examples
filter_rows = client.query.execute(filter_query)
range_rows = client.query.execute(range_query)
in_rows = client.query.execute(in_query)
```
</Tabs.Tab>
</Tabs>
</Python>

## Dynamic Query Building

<TypeScript>
```ts filename="DynamicQueries.ts"
import { sql, ApiHelpers as CH } from "@514labs/moose-lib";

interface QueryParams {
  sortBy: string;
  fields: string[];
  filters: Record<string, any>;
}

const buildDynamicQuery = ({ sortBy, fields, filters }: QueryParams) => {
  // Build field list
  const fieldList = fields.map(field => sql`${CH.column(field)}`);
  
  // Build WHERE conditions
  const conditions = Object.entries(filters)
    .filter(([_, value]) => value !== undefined)
    .map(([key, value]) => sql`${CH.column(key)} = ${value}`);
  
  let query = sql`
    SELECT ${fieldList.join(', ')}
    FROM ${UserTable}
  `;
  
  if (conditions.length > 0) {
    query = sql`${query} WHERE ${conditions.join(' AND ')}`;
  }
  
  query = sql`${query} ORDER BY ${CH.column(sortBy)}`;
  
  return query;
};
```
</TypeScript>

<Python>
<Tabs items={["execute_raw (Recommended)", "f-strings (Simple cases)"]}>
<Tabs.Tab>
Use `execute_raw` with parameter binding:

```py filename="DynamicQueries.py"
from moose_lib import MooseClient
from typing import Dict, Any

client = MooseClient()

def build_dynamic_query(filters: Dict[str, str], sort_by: str, limit: int):
    conditions: list[str] = []
    params: Dict[str, Any] = {}

    # Known valid columns - validate against this list
    valid_columns = {"status", "age", "city", "department"}
    
    for key, value in filters.items():
        if value is not None and key in valid_columns:
            conditions.append(f"{key} = {{{key}:String}}")
            params[key] = value

    query = "SELECT * FROM users"

    if conditions:
        query += " WHERE " + " AND ".join(conditions)

    # Use f-string for column name (validate first!)
    query += f" ORDER BY {sort_by} LIMIT {{limit:UInt32}}"
    params["limit"] = limit

    return client.query.execute_raw(query, params)

# Usage example
filters = {"status": "active", "city": "New York"}
result = build_dynamic_query(filters, "created_at", 10)
```
</Tabs.Tab>
<Tabs.Tab>
Use f-strings with `execute` (only for trusted, validated input):

```py filename="DynamicQueriesFString.py"
from moose_lib import MooseClient
from typing import Dict, Any

client = MooseClient()

def build_dynamic_query(filters: Dict[str, Any], sort_by: str, limit: int):
    conditions: list[str] = []

    # Known valid columns and values - validate against these
    valid_columns = {"status", "age", "city", "department"}
    valid_statuses = {"active", "inactive", "pending"}
    valid_sort_columns = {"id", "name", "created_at", "age"}

    # Validate sort_by column
    if sort_by not in valid_sort_columns:
        raise ValueError(f"Invalid sort column: {sort_by}")

    for key, value in filters.items():
        if value is not None and key in valid_columns:
            # Additional validation for specific columns
            if key == "status" and value not in valid_statuses:
                raise ValueError(f"Invalid status: {value}")
            
            # WARNING: Only use with validated input to prevent SQL injection
            conditions.append(f"{key} = '{value}'")

    query = f"SELECT * FROM {UserTable.name}"

    if conditions:
        query += " WHERE " + " AND ".join(conditions)

    # Include column name directly (already validated!)
    query += f" ORDER BY {sort_by} LIMIT {limit}"

    return client.query.execute(query)

# Usage example
filters = {"status": "active", "city": "New York"}
result = build_dynamic_query(filters, "created_at", 10)
```
</Tabs.Tab>
</Tabs>
</Python>

### Interpolation and Security

<TypeScript>
Use the `sql` template literal to build safe queries:

```ts filename="SqlTemplateLiterals.ts"
import { sql } from "@514labs/moose-lib";

// Safe interpolation with sql template literal
const status = 'active';
const limit = 10;

const query = sql`
  SELECT id, name, email
  FROM ${UserTable}
  WHERE ${UserTable.columns.status} = ${status}
  LIMIT ${limit}
`;

// Conditional WHERE clauses
interface FilterParams {
  minAge?: number;
  status?: "active" | "inactive";
  searchText?: string;
}

const buildConditionalQuery = (filters: FilterParams) => {
  let conditions = [];
  
  if (filters.minAge !== undefined) {
    conditions.push(sql`age >= ${filters.minAge}`);
  }
  
  if (filters.status) {
    conditions.push(sql`status = ${filters.status}`);
  }
  
  if (filters.searchText) {
    conditions.push(sql`(name ILIKE ${'%' + filters.searchText + '%'} OR email ILIKE ${'%' + filters.searchText + '%'})`);
  }
  
  let query = sql`SELECT * FROM ${UserTable}`;
  
  if (conditions.length > 0) {
    query = sql`${query} WHERE ${conditions.join(' AND ')}`;
  }
  
  return sql`${query} ORDER BY created_at DESC`;
};
```
</TypeScript>

<Python>

Moose provides two distinct approaches for executing queries in Python. Choose the right one for your use case:

- Option 1: Use `execute_raw` with parameter binding
- Option 2: Use f-strings with `execute`

<Tabs items={["execute_raw (Dynamic identifiers)", "f-strings (Simple cases)"]}>
<Tabs.Tab>
**Use when:** You have dynamic identifiers (table names, column names) that aren't known until query time, or when you need server-side parameter binding.

**What it does:** Exposes the underlying ClickHouse driver with server-side parameter binding for values, while allowing dynamic identifiers in the query string.

**Benefits:** 
- Server-side parameter binding for values (prevents SQL injection)
- Dynamic table/column names in query structure
- Automatic type conversion for bound parameters

```py filename="ParameterBinding.py"
from moose_lib import MooseClient

client = MooseClient()

# Example: Dynamic table and column selection with server-side parameter binding
def query_user_data(table_name: str, status_filter: str, limit: int):
    # Dynamic identifiers in query structure, bound parameters for values
    query = """
      SELECT id, name, email
      FROM {table_name:Identifier}  # Dynamic table name
      WHERE status = {{status:String}}  # Server-side parameter binding
        AND created_at > {{startDate:DateTime}}
      LIMIT {{limit:UInt32}}
    """
    
    return client.query.execute_raw(query, {
        "table_name": table_name,  # Bound parameter
        "status": status_filter,  # Bound parameter
        "startDate": "2024-01-01T00:00:00",  # Bound parameter
        "limit": limit  # Bound parameter
    })

# Usage with different tables
users_data = query_user_data("users", "active", 10)
admins_data = query_user_data("admin_users", "pending", 5)

# Conditional WHERE clauses
def build_conditional_query(client: MooseClient, params: FilterParams):
    conditions: list[str] = []
    parameters: dict = {}

    if params.min_age is not None:
        conditions.append("age >= {minAge:UInt32}")
        parameters["minAge"] = params.min_age

    if params.status:
        conditions.append("status = {status:String}")
        parameters["status"] = params.status

    if params.search_text:
        conditions.append("(name ILIKE {searchPattern:String} OR email ILIKE {searchPattern:String})")
        parameters["searchPattern"] = f"%{params.search_text}%"

    query = "SELECT * FROM users"

    if conditions:
        query += " WHERE " + " AND ".join(conditions)

    query += " ORDER BY created_at DESC"

    return client.query.execute_raw(query, parameters)
```
</Tabs.Tab>
<Tabs.Tab>
**Use when:** Simple, static queries where table/column names are known at code time and you have trusted, validated data.

**What it does:** Uses Python f-strings for query construction with client-side parameter interpolation.

**Benefits:**
- Simpler syntax for basic cases
- No parameter dictionary needed
- Direct string interpolation

**WARNING:** Only use with trusted, validated input to prevent SQL injection. Not suitable for dynamic identifiers.

```py filename="FStrings.py"
from moose_lib import MooseClient
from pydantic import BaseModel, Field, validator
from typing import Optional

client = MooseClient()

# Example: Static query with validated parameters
def get_active_users(status: str, limit: int):
    # Static table/column names, validated parameters
    query = f"""
        SELECT {UserTable.columns.id}, {UserTable.columns.name}, {UserTable.columns.email}
        FROM {UserTable.name}  # Static table name
        WHERE {UserTable.columns.status} = '{status}'  # Validated parameter
        LIMIT {limit}
    """
    
    return client.query.execute(query)

# Usage with validated input
active_users = get_active_users("active", 10)

# For more complex validation, use Pydantic
class UserQueryParams(BaseModel):
    status: str = Field(..., pattern=r"^(active|inactive|pending)$")
    limit: int = Field(default=10, ge=1, le=1000)

def build_validated_query(params: UserQueryParams):
    # All parameters are validated by Pydantic
    query = f"""
        SELECT {UserTable.columns.id}, {UserTable.columns.name}, {UserTable.columns.email}
        FROM {UserTable.name}
        WHERE {UserTable.columns.status} = '{params.status}'
        LIMIT {params.limit}
    """
    
    return client.query.execute(query)
```
</Tabs.Tab>
</Tabs>

<Callout type="warning">
**Security Guidelines:**
- **execute_raw**: Use when you have dynamic identifiers (table/column names) or need server-side parameter binding
- **execute with f-strings**: Only for static queries with known table/column names and validated parameters
- Always validate input with Pydantic when using f-strings
- Never use f-strings with unvalidated user input or dynamic identifiers
- When in doubt, use execute_raw for maximum security
</Callout>

</Python>


## Common Query Patterns

### Sorting and Pagination

<TypeScript>
```ts filename="SortingPagination.ts"
import { sql } from "@514labs/moose-lib";

// Multi-column sorting
const sortQuery = sql`
  SELECT ${UserTable.columns.id}, ${UserTable.columns.name}, ${UserTable.columns.created_at}
  FROM ${UserTable}
  ORDER BY ${UserTable.columns.status} ASC, ${UserTable.columns.created_at} DESC
  LIMIT ${limit} OFFSET ${offset}
`;

// Dynamic sorting
const dynamicSortQuery = sql`
  SELECT * FROM ${UserTable}
  ORDER BY ${CH.column(sortBy)} ${sortDirection}
  LIMIT ${limit}
`;
```
</TypeScript>

<Python>
```py filename="SortingPagination.py"
from moose_lib import MooseClient

# Multi-column sorting
sort_query = """
  SELECT id, name, created_at
  FROM {tableName:Identifier}
  ORDER BY status ASC, created_at DESC
  LIMIT {limit:UInt32} OFFSET {offset:UInt32}
"""

# Dynamic sorting
dynamic_sort_query = """
  SELECT * FROM {tableName:Identifier}
  ORDER BY {sortBy:Identifier} {sortDirection:String}
  LIMIT {limit:UInt32}
"""
```
</Python>

### Aggregations and Grouping

<TypeScript>
```ts filename="Aggregations.ts"
import { sql } from "@514labs/moose-lib";

// Basic aggregations
const aggQuery = sql`
  SELECT 
    ${UserTable.columns.status},
    COUNT(*) as user_count,
    AVG(${UserTable.columns.age}) as avg_age,
    SUM(${UserTable.columns.score}) as total_score
  FROM ${UserTable}
  GROUP BY ${UserTable.columns.status}
  HAVING COUNT(*) > 10
`;

// Complex aggregations with CASE statements
const complexAggQuery = sql`
  SELECT 
    ${UserTable.columns.status},
    COUNT(*) as total_users,
    COUNT(CASE WHEN ${UserTable.columns.age} > 25 THEN 1 END) as users_over_25,
    AVG(CASE WHEN ${UserTable.columns.status} = 'active' THEN ${UserTable.columns.score} END) as avg_active_score
  FROM ${UserTable}
  GROUP BY ${UserTable.columns.status}
`;
```
</TypeScript>

<Python>
```py filename="Aggregations.py"
from moose_lib import MooseClient

# Basic aggregations
agg_query = """
  SELECT 
    status,
    COUNT(*) as user_count,
    AVG(age) as avg_age,
    SUM(score) as total_score
  FROM {tableName:Identifier}
  GROUP BY status
  HAVING COUNT(*) > {minCount:UInt32}
"""

# Complex aggregations with CASE statements
complex_agg_query = """
  SELECT 
    status,
    COUNT(*) as total_users,
    COUNT(CASE WHEN age > 25 THEN 1 END) as users_over_25,
    AVG(CASE WHEN status = 'active' THEN score END) as avg_active_score
  FROM {tableName:Identifier}
  GROUP BY status
"""
```
</Python>

### Joins

<TypeScript>
```ts filename="Joins.ts"
import { sql } from "@514labs/moose-lib";
import { UserTable, OrderTable } from "./tables";

// INNER JOIN
const innerJoinQuery = sql`
  SELECT 
    ${UserTable.columns.id},
    ${UserTable.columns.name},
    ${OrderTable.columns.order_value}
  FROM ${UserTable}
  INNER JOIN ${OrderTable} ON ${UserTable.columns.id} = ${OrderTable.columns.user_id}
  WHERE ${OrderTable.columns.status} = 'completed'
`;

// LEFT JOIN
const leftJoinQuery = sql`
  SELECT 
    ${UserTable.columns.id},
    ${UserTable.columns.name},
    COUNT(${OrderTable.columns.id}) as order_count
  FROM ${UserTable}
  LEFT JOIN ${OrderTable} ON ${UserTable.columns.id} = ${OrderTable.columns.user_id}
  GROUP BY ${UserTable.columns.id}, ${UserTable.columns.name}
`;
```
</TypeScript>

<Python>
```py filename="Joins.py"
from moose_lib import MooseClient

# INNER JOIN
inner_join_query = """
  SELECT 
    u.id,
    u.name,
    o.order_value
  FROM {userTable:Identifier} u
  INNER JOIN {orderTable:Identifier} o ON u.id = o.user_id
  WHERE o.status = {orderStatus:String}
"""

# LEFT JOIN
left_join_query = """
  SELECT 
    u.id,
    u.name,
    COUNT(o.id) as order_count
  FROM {userTable:Identifier} u
  LEFT JOIN {orderTable:Identifier} o ON u.id = o.user_id
  GROUP BY u.id, u.name
"""
```
</Python>

## Building APIs

To build REST APIs that expose your data, see the [Analytics APIs documentation](/moose/apis/analytics-api) for comprehensive examples and patterns.


## Common Pitfalls

<TypeScript>
<Callout type="warning" title="Common TypeScript Issues">
- **Column name typos**: Use `UserTable.columns.columnName` for autocomplete
- **Type mismatches**: Ensure your schema types match ClickHouse types
- **Missing imports**: Import your table definitions before using them
- **Template literal syntax**: Use backticks `sql` not regular strings
- **Forgetting await**: Always await `client.query.execute()`
</Callout>
</TypeScript>

<Python>
<Callout type="warning" title="Common Python Issues">
- **SQL injection**: Always use parameter binding, never f-strings with user input
- **Type validation**: Use Pydantic models to validate query parameters
- **Memory issues**: Add LIMIT clauses for large queries
- **Connection handling**: Implement proper connection pooling and retry logic
- **Parameter types**: Use correct ClickHouse type annotations in parameter binding
</Callout>
</Python>

## Performance Optimization
If your query is slower than expected, there are a few things you can check:

- If using filters, try to filter on a column that is defined in the `orderByFields` of the table
- For common queries, consider [creating a materialized view](/stack/olap/create-materialized-view) to pre-compute the result set


## Further Reading

<CTACards columns={1}>
<CTACard
  title="Moose APIs"
  description="Build REST APIs for your data with built-in Moose API module"
  ctaLink="/stack/apis/egress"
  ctaLabel="Learn More →"
  orientation="horizontal"
/>
<CTACard
  title="Creating Materialized Views"
  description="Define data transformations"
  ctaLink="/stack/olap/create-materialized-view"
  ctaLabel="Learn More →"
  orientation="horizontal"
/>
</CTACards>

