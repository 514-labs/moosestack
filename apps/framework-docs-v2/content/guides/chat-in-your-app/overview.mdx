---
title: Overview
status: "draft"
description: When and why to build data-connected chat
languages: ["typescript"]
tags: ["MCP"]
---

import { BulletPointsCard } from "@/components/mdx";

# Overview

This guide is about building a conversational interface embedded directly into your product that can answer questions by querying your actual data. Users ask in natural language, and the system responds with results grounded in live queries and the context of your schema, metrics, and permissions.

This works because modern LLMs can call tools: they can inspect table metadata and run structured queries through a controlled interface (in this guide, an [MCP](https://modelcontextprotocol.io/) server over ClickHouse), then explain the output in plain language.

*What this guide is not about*: a generic chatbot that summarizes docs, a RAG-style assistant fed with your knowledge base, or a support bot optimized for ticket deflection. This means chat that can actually access and query your data: it can inspect schemas, run SQL, compute aggregates, and explain real results inside the workflows your app already supports, and that data access is the focus of this guide.

### Why chat is worth building, and why data is key

A data-connected chat interface makes analytics more available and more usable: users ask questions directly, and the system responds by querying your data rather than forcing dashboard navigation.

<BulletPointsCard
  title="Benefits"
  bulletStyle="check"
  bullets={[
    {
      title: "Democratize data access",
      description: "Non-technical users can query complex datasets without SQL or dashboard training."
    },
    {
      title: "Reduce friction",
      description: "Eliminate the five-click problem: users ask instead of navigating menus, filters, and dashboards."
    },
    {
      title: "Context-aware exploration",
      description: "Conversation history enables follow-ups and iterative refinement without starting over."
    },
    {
      title: "Faster decisions",
      description: "Answers arrive in seconds instead of waiting on analysts or learning a new interface."
    },
    {
      title: "Lower support load",
      description: "Self-serve reduces repeated questions and tickets to data and analytics teams."
    }
  ]}
/>

### Common use cases

Data-connected chat works best when users are trying to answer concrete questions from live, structured data, especially when the questions change from moment to moment and you cannot realistically pre-build every dashboard and drill-down.

<BulletPointsCard
  title="Use Cases"
  bulletStyle="number"
  bullets={[
    {
      title: "Internal analytics and business intelligence",
      description: "Chat is a fast layer over your existing metrics and dashboards. Executives can ask follow-ups without waiting on an analyst. Business users can generate ad-hoc cuts of the data without learning SQL. Analysts benefit too: chat is an efficient starting point for exploration when first familiarizing with a dataset."
    },
    {
      title: "Customer-facing analytics products",
      description: "If your product already has analytics value, chat can make that value feel immediate. SaaS customers can ask about usage, adoption, and trends without needing a bespoke dashboard for every role. E-commerce operators can explore sales patterns with natural follow-ups. Customers get a flexible interface that adapts to their questions."
    },
    {
      title: "Operational workflows",
      description: "Chat can serve as a query interface for support and ops workflows. DevOps teams can use chat for chatops-style exploration of metrics. Supply chain teams can query stock levels and fulfillment timelines. The goal is rapid, auditable data lookup: the system shows what it queried and why."
    }
  ]}
/>

Across all of these, the pattern is the same: chat is most valuable when it is grounded in the systems of record, fast enough to support iterative exploration, and integrated into the workflows where decisions actually get made.

### Implementation strategy: fast baseline, then iterate

Getting to "working" is relatively quick because the core plumbing is now mostly standardized: an LLM that can call tools, an MCP server that exposes your database safely, and an OLAP backend that can answer analytical questions fast. MooseStack packages those pieces so you can stand up a baseline end-to-end without spending weeks on glue code, and the Next.js UI in this guide is just a reference client (the backend works with any frontend).

The rest of the effort is still worth it because the quality of a data chat experience is determined by product-specific details: how your data is modeled, how business terms map to tables and metrics, what permissions and tenancy rules apply, and how results should be presented inside your existing workflows. Once the baseline is live, you can iterate efficiently on accuracy, latency, context, and UX to capture the remaining value without rebuilding the foundation.

### When this approach is worth building

Chat is worth investing in once your product has meaningful data gravity: users regularly ask questions that require slicing, aggregation, or comparison, and the existing UI forces them through dashboards, filters, or support channels to get answers. If you already maintain analytics views or a metrics layer, but users still need help finding or interpreting results, chat can reduce that friction immediately.

It is especially compelling when your team is fielding repeat questions, building one-off dashboards for narrow use cases, or struggling to productize a long tail of analytical queries. In those cases, chat becomes a flexible interface that scales with your schema, rather than another surface area you have to constantly redesign.
