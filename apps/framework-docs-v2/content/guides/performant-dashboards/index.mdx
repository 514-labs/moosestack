---
title: Improving the Performance of Your Dashboards
description: Migrate analytical workloads from your OLTP database to ClickHouse, incrementally, with AI assistance
previewVariant: "dashboards"
languages: ["typescript"]
---

import {
  CTACards,
  CTACard,
  Callout,
  CommunityCallout,
  ZoomImg,
} from "@/components/mdx";

# Improving the Performance of Your Dashboards

Slow dashboards are a database architecture problem. Running analytical queries (aggregations, wide scans, time-series breakdowns) on your transactional database degrades everything: dashboard latency, core app reliability, and your team's ability to ship new metrics without capacity planning.

This guide walks you through adding a dedicated analytical layer ([ClickHouse](https://clickhouse.com)) alongside your existing OLTP database using [MooseStack](/moosestack), [514 hosting](https://boreal.cloud), and a supporting toolchain ([dev MCP server](/moosestack/moosedev-mcp), [language server](/moosestack/language-server), CLIs, and [ClickHouse skills](https://github.com/514-labs/agent-skills/)) that form an agent harness for AI-assisted migration. You keep your source database as the system of record, replicate the data your dashboards need via CDC, and rewire analytical reads to ClickHouse. Writes stay unchanged.

<ZoomImg light="/guides/performant-dashboards/marchitecture-light.png" dark="/guides/performant-dashboards/marchitecture-dark.png" alt="Architecture: Your App writes to OLTP, CDC replicates to ClickHouse OLAP, analytical reads rewired to ClickHouse, managed by Fiveonefour Hosting" />

### What's supported today

| Source database | CDC method | App language |
|---|---|---|
| **[Postgres](https://clickhouse.com/cloud/postgresql)** | [ClickPipes](https://clickhouse.com/cloud/clickpipes) (managed by ClickHouse Cloud) | TypeScript |
| **SQL Server** | [Debezium](https://debezium.io/) (self-hosted) | TypeScript |

### Get Started

<CTACards columns={2}>
  <CTACard
    title="Overview"
    description="Business context, warning signs, when to pull the trigger, and what success looks like"
    ctaLink="/guides/performant-dashboards/overview"
    ctaLabel="Understand the problem"
    Icon="Eye"
  />
  <CTACard
    title="Tutorial"
    description="Step-by-step: set up CDC, model your analytics layer in code, and ship to production"
    ctaLink="/guides/performant-dashboards/tutorial"
    ctaLabel="Start building"
    Icon="Rocket"
  />
</CTACards>

<Callout
  type="info"
  title="Starting from scratch?"
  href="/guides/chat-in-your-app"
  ctaLabel="Get started"
>
  If you're building a new dashboard or data-connected chat (not migrating an
  existing one), start with [Chat in Your App](/guides/chat-in-your-app).
</Callout>

<CommunityCallout title="Need a different source or language?">
We're adding support for more source databases (MySQL, MongoDB), CDC methods, and Python examples. If your stack isn't listed, join the community and tell us what you need. It helps us prioritize.
</CommunityCallout>

## Accelerating migrations with MooseStack: the agent harness for your analytical stack

AI agents are good at writing code, but OLAP migrations fail when agents lack the right constraints: they don't know ClickHouse idioms, they can't validate their own output, and they have no way to catch mistakes before production. The harness solves this by keeping the agent inside the OLAP paradigm, letting it write in languages it already knows (TypeScript, not DDL scripts), and giving it tools to check its own work in fast, increasingly scoped feedback loops.

MooseStack gives you a development framework where your entire ClickHouse analytics layer (tables, materialized views, serving tables, and query handlers) lives in version-controlled TypeScript. You use an AI copilot (Claude Code, Cursor, Codex, or any MCP-capable editor) inside this structured harness:

<ZoomImg light="/guides/performant-dashboards/agent-harness-light.png" dark="/guides/performant-dashboards/agent-harness-dark.png" alt="Agent Harness Architecture: AI coding agent backed by Code, Cadence, and Context pillars via MooseStack, driving a unified data stack from Postgres to ClickHouse to Dashboards" />

**Code:** everything is typed objects with a dependency graph. The agent reads and writes TypeScript, not raw SQL or YAML. Type errors surface at write time, not after deployment.

**Cadence:** three nested feedback loops catch errors at increasing scope. The IDE catches type and SQL errors instantly, `moose dev` catches runtime and schema errors in seconds, and Boreal preview environments catch deployment and scale errors in minutes. The tightest loop that catches the error wins.

**Context:** the agent works with [ClickHouse-specific skills](https://github.com/514-labs/agent-skills/), [live query validation with LSP](/moosestack/language-server), [local dev environment validation with MooseDev MCP](/moosestack/moosedev-mcp), reference implementations, copilot prompts, test fixtures, and a structured context workspace. Not raw LLM training data: curated, task-specific context.

You work through [three phases](/guides/performant-dashboards/tutorial#migrate-a-dashboard-component-to-clickhouse) per dashboard component: parity translation (make the same query work on ClickHouse), optimization (materialized views and serving tables for production performance), and query layer (type-safe API handlers that replace your OLTP read path). Each phase is validated before you move on.
