---
title: Tutorial
description: Step-by-step guide to migrating your dashboard to ClickHouse
languages: ["typescript"]
---

import {
  Callout,
  CustomizePanel,
  CustomizeGrid,
  SelectField,
  ConditionalContent,
  CommunityCallout,
} from "@/components/mdx";

# Tutorial: Migrate Your Dashboard to ClickHouse

This tutorial assumes you already have a dashboard or report running in production, and you want to make it faster using OLAP best practices.

Your source database (Postgres or SQL Server) remains your transactional system of record, and your application continues writing to it as usual. CDC (ClickPipes or Debezium) streams changes into ClickHouse in real time so dashboards can read from ClickHouse instead of competing with OLTP workloads.

MooseStack is where you define your ClickHouse analytics layer **in code**. You’ll build views/materializations on top of the CDC-replicated raw tables and keep your existing dashboard APIs and request/response contracts the same—only the backing queries change.

By the end of this guide you’ll have:

1. A real-time replication pipeline feeding production ClickHouse from your source database.
2. A MooseStack project that defines ClickHouse resources (views, materialized views, serving tables) on top of the CDC-replicated raw tables, plus the query/API handlers your dashboard will call.
3. A local dev workflow for evolving those resources safely, and a Boreal-backed deploy workflow with preview environments + migration plans so you can validate changes before merging to `main`.


<Callout
  type="info"
  title="Starting from scratch?"
  href="/guides/chat-in-your-app"
  ctaLabel="Get started"
>
  If you’re building a new dashboard or data-connected chat (not migrating an
  existing dashboard), start with [Chat in Your App](/guides/chat-in-your-app).
</Callout>

## Customize this tutorial

<CustomizePanel
  title="Where does your current data live?"
  description="Select the database you use today so we can show the right way to replicate this data into ClickHouse"
>
  <CustomizeGrid columns={1}>
    <SelectField
      id="source-database"
      label="Source database"
      options={[
        { value: "sqlserver", label: "SQL Server" },
        { value: "postgres", label: "Postgres" },
      ]}
      defaultValue="postgres"
      persist
    />
    <SelectField
      id="os"
      label="Operating System"
      options={[
        { value: "macos", label: "macOS or Linux" },
        { value: "windows", label: "Windows (WSL 2)" },
      ]}
      defaultValue="macos"
      persist
    />
    <SelectField
      id="language"
      label="Language"
      options={[
        { value: "typescript", label: "TypeScript" },
      ]}
      defaultValue="typescript"
      persist
    />
  </CustomizeGrid>
</CustomizePanel>

<CommunityCallout title="Want Python Examples?">
This guide is written for TypeScript developers, but Python developers can follow along. The concepts translate directly, and MooseStack supports both languages. If you'd like Python-specific examples, let us know in our Slack community and we'll prioritize creating them.
</CommunityCallout>

You'll work through:

<ConditionalContent whenId="source-database" whenValue="postgres">

1. [Set up ClickHouse Cloud ClickPipes](#set-up-clickhouse-cloud-clickpipes-postgres-cdc) to replicate your Postgres tables into ClickHouse.
2. [Add MooseStack and set up Boreal](#add-moosestack-to-your-project-and-set-up-boreal) so your project is initialized and PRs get preview environments with migration plans.
3. [Migrate one dashboard component](#migrate-a-dashboard-component-to-clickhouse) using ClickHouse-native resources (views, materialized views, serving tables).
4. [Go to production](#going-to-production) using the preview environment and reviewed migrations.
</ConditionalContent>

<ConditionalContent whenId="source-database" whenValue="sqlserver">
1. [Add MooseStack and set up Boreal](#add-moosestack-to-your-project-and-set-up-boreal) (you’ll define the Debezium ingest pipeline in this project, then connect deployments).
2. [Prepare your local dev environment](#prepare-your-local-development-environment) to work with ClickHouse.
3. [Set up Debezium CDC](#set-up-change-data-capture-cdc) to stream SQL Server changes into ClickHouse via your MooseStack ingest API.
4. [Migrate one dashboard component](#migrate-a-dashboard-component-to-clickhouse) using ClickHouse-native resources (views, materialized views, serving tables).
5. [Go to production](#going-to-production) using the preview environment and reviewed migrations.
</ConditionalContent>

<Callout type="info" title="AI-assisted Development">
  We recommend using an AI copilot to accelerate the migration to handle complex
  query translations. However, you can complete every step manually if you
  prefer. Any AI-enabled editor (Claude Code, Cursor, Codex, Opencode, GitHub
  Copilot, Windsurf, etc.) will work. Editors that support MCPs can make this
  workflow even faster.
</Callout>

:::include /shared/guides/performant-dashboards/add-moosestack-and-set-up-boreal.mdx

## Develop with ClickHouse locally
:::include /shared/guides/performant-dashboards/prepare-your-local-development-environment.mdx

:::include /shared/guides/performant-dashboards/set-up-change-data-capture-cdc.mdx

### Migrate a dashboard component to ClickHouse

In this section, you'll take an existing dashboard component that's currently served by an OLTP-backed API endpoint and switch it to an OLAP-backed implementation (ClickHouse + MooseStack). Concretely, you'll update the existing backend handler so it reads from the ClickHouse tables you've just built, instead of querying your OLTP database.

The rest of your application stays the same: routing, auth, request/response contracts, and frontend behavior. For each component you migrate, you'll add a small function in your MooseStack project that builds and runs the ClickHouse query, importing your `OlapTable` objects so column access is type-safe. Then you'll repoint the existing API handler to call that new OLAP function in place of the original OLTP query logic.

This guide follows a three-phase migration pattern:

1. **Parity (raw translation)**: Do a direct, SQL-for-SQL translation of your OLTP logic into ClickHouse so the endpoint returns the same result as the original OLTP endpoint. The goal here is correctness, not perfect OLAP code.
2. **Precompute (make it OLAP-native)**: Refactor that raw query by shifting joins and upfront transformations to Materialized Views and prepared tables. This makes reads cheaper and the model easier to extend.
3. **Serve (semantic/query layer)**: Layer a query/semantic model over those prepared tables so defining dashboard metrics, group-bys, filters, and other controls becomes clean, reusable, and maintainable, so you don't have to rewrite raw dynamic SQL in every handler.

#### (Recommended) Build a copilot context pack

Copy the starter kit to create a dedicated workspace to compile all the context your copilot needs to migrate each component. It includes a template for a `context-map.md` file (a worksheet that tracks the location of relevant files in your codebase for each component) and a full example to help your copilot complete each phase of the migration.

```bash
pnpm dlx tiged 514-labs/moosestack/examples/dashboard-migration moosestack/context
```

As you complete each phase of this guide, you will attach the required input files in your initial prompt to your copilot. From there, the copilot will update the workspace files as it completes the steps in this guide. 

Pick a specific dashboard component or report to migrate. You'll work through one component at a time.

<GuideStepper id="performant-dashboards-migration" persist>

    :::include /shared/guides/performant-dashboards/phase-1-translation.mdx

    :::include /shared/guides/performant-dashboards/phase-2-optimization.mdx

    :::include /shared/guides/performant-dashboards/phase-3-query-layer.mdx

</GuideStepper>

:::include /shared/guides/performant-dashboards/going-to-production.mdx
