---
title: Tutorial
description: Step-by-step guide to migrating your dashboard to ClickHouse
languages: ["typescript"]
---

import {
  Callout,
  CustomizePanel,
  CustomizeGrid,
  SelectField,
  ConditionalContent,
  CommunityCallout,
  BulletPointsCard,
} from "@/components/mdx";

# Tutorial: Migrate Your Dashboard to ClickHouse

This tutorial is for teams with a production dashboard or report that needs to get faster as data volume grows.

<BulletPointsCard
  title="By the end of this guide you’ll have"
  bulletStyle="check"
  bullets={[
    {
      title: "Real-time replication (CDC) pipeline",
      description:
        "A production pipeline that continuously replicates data from your source database into ClickHouse.",
    },
    {
      title: "ClickHouse analytics layer in code",
      description:
        "A MooseStack project that defines views, materialized views, serving tables, and query/API handlers on top of CDC-replicated raw tables.",
    },
    {
      title: "Safe local-to-production workflow",
      description:
        "A local development workflow plus Boreal preview environments and migration plans so you can validate changes before merging to `main`."
    },
  ]}
/>

You do not need a full rewrite. Keep your source database (Postgres or SQL Server) as the transactional system of record, keep your existing app contracts, and offload analytical reads to ClickHouse via CDC (ClickPipes or Debezium).

This guide gives a path to ship this as normal code, as part of your existing development process. With MooseStack, you model your ClickHouse analytics layer in code, iterate locally, and roll out with preview migrations in Boreal so you can safely iterate on your analytics layer without risking your production ClickHouse data.

<Callout
  type="info"
  title="Starting from scratch?"
  href="/guides/chat-in-your-app"
  ctaLabel="Get started"
>
  If you’re building a new dashboard or data-connected chat (not migrating an
  existing dashboard), start with [Chat in Your App](/guides/chat-in-your-app).
</Callout>

## Customize this tutorial

<CustomizePanel
  title="Where does your current data live?"
  description="Select the database you use today so we can show the right way to replicate this data into ClickHouse"
>
  <CustomizeGrid columns={1}>
    <SelectField
      id="source-database"
      label="Source database"
      options={[
        { value: "sqlserver", label: "SQL Server" },
        { value: "postgres", label: "Postgres" },
      ]}
      defaultValue="postgres"
      persist
    />
    <SelectField
      id="os"
      label="Operating System"
      options={[
        { value: "macos", label: "macOS or Linux" },
        { value: "windows", label: "Windows (WSL 2)" },
      ]}
      defaultValue="macos"
      persist
    />
    <SelectField
      id="language"
      label="Language"
      options={[
        { value: "typescript", label: "TypeScript" },
      ]}
      defaultValue="typescript"
      persist
    />
  </CustomizeGrid>
</CustomizePanel>

<CommunityCallout title="Want Python Examples?">
This guide is written for TypeScript developers, but Python developers can follow along. The concepts translate directly, and MooseStack supports both languages. If you'd like Python-specific examples, let us know in our Slack community and we'll prioritize creating them.
</CommunityCallout>

You'll work through:

<ConditionalContent whenId="source-database" whenValue="postgres">
1. [Project Setup](#project-setup) to set up ClickHouse Cloud ClickPipes, initialize MooseStack, and configure Boreal preview environments.
2. [Develop with ClickHouse locally](#develop-with-clickhouse-locally) to prepare your local environment, validate data flow, and migrate a dashboard component to ClickHouse.
3. [Going to production](#going-to-production) using the preview environment and reviewed migrations.
</ConditionalContent>

<ConditionalContent whenId="source-database" whenValue="sqlserver">
1. [Project Setup](#project-setup) to initialize MooseStack and configure Boreal preview environments.
2. [Develop with ClickHouse locally](#develop-with-clickhouse-locally) to prepare your local environment, set up Debezium CDC, and migrate a dashboard component to ClickHouse.
3. [Going to production](#going-to-production) using the preview environment and reviewed migrations.
</ConditionalContent>

<Callout type="info" title="AI-assisted Development">
  We recommend using an AI copilot to accelerate the migration to handle complex
  query translations. However, you can complete every step manually if you
  prefer. Any AI-enabled editor (Claude Code, Cursor, Codex, Opencode, GitHub
  Copilot, Windsurf, etc.) will work. Editors that support MCPs can make this
  workflow even faster.
</Callout>

## Project Setup

<ConditionalContent whenId="source-database" whenValue="postgres">
:::include /shared/guides/performant-dashboards/clickpipes.mdx
</ConditionalContent>

:::include /shared/guides/performant-dashboards/add-moosestack-and-set-up-boreal.mdx

## Develop with ClickHouse locally
:::include /shared/guides/performant-dashboards/prepare-your-local-development-environment.mdx

<ConditionalContent whenId="source-database" whenValue="sqlserver">
:::include /shared/guides/performant-dashboards/set-up-change-data-capture-cdc.mdx
</ConditionalContent>

### Migrate a dashboard component to ClickHouse

In this section, you'll take an existing dashboard component that's currently served by an OLTP-backed API endpoint and switch it to an OLAP-backed implementation (ClickHouse + MooseStack). Concretely, you'll update the existing backend handler so it reads from the ClickHouse tables you've just built, instead of querying your OLTP database.

The rest of your application stays the same: routing, auth, request/response contracts, and frontend behavior. For each component you migrate, you'll add a small function in your MooseStack project that builds and runs the ClickHouse query, importing your `OlapTable` objects so column access is type-safe. Then you'll repoint the existing API handler to call that new OLAP function in place of the original OLTP query logic.

This guide follows a three-phase migration pattern:

1. **Parity (raw translation)**: Do a direct, SQL-for-SQL translation of your OLTP logic into ClickHouse so the endpoint returns the same result as the original OLTP endpoint. The goal here is correctness, not perfect OLAP code.
2. **Precompute (make it OLAP-native)**: Refactor that raw query by shifting joins and upfront transformations to Materialized Views and prepared tables. This makes reads cheaper and the model easier to extend.
3. **Serve (semantic/query layer)**: Layer a query/semantic model over those prepared tables so defining dashboard metrics, group-bys, filters, and other controls becomes clean, reusable, and maintainable, so you don't have to rewrite raw dynamic SQL in every handler.

#### (Recommended) Build a copilot context pack

Copy the starter kit to create a dedicated workspace to compile all the context your copilot needs to migrate each component. It includes a template for a `context-map.md` file (a worksheet that tracks the location of relevant files in your codebase for each component) and a full example to help your copilot complete each phase of the migration.

```bash
pnpm dlx tiged 514-labs/moosestack/examples/dashboard-migration moosestack/context
```

As you complete each phase of this guide, you will attach the required input files in your initial prompt to your copilot. From there, the copilot will update the workspace files as it completes the steps in this guide. 

Pick a specific dashboard component or report to migrate. You'll work through one component at a time.

<GuideStepper id="performant-dashboards-migration" persist>

    :::include /shared/guides/performant-dashboards/phase-1-translation.mdx

    :::include /shared/guides/performant-dashboards/phase-2-optimization.mdx

    :::include /shared/guides/performant-dashboards/phase-3-query-layer.mdx

</GuideStepper>

:::include /shared/guides/performant-dashboards/going-to-production.mdx
