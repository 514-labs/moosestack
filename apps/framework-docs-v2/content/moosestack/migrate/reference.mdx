title: Review & Edit Planned Migrations
description: Validate plan.yaml, tweak operations, and reference every supported migration action
order: 3
category: migrate
---

import { LanguageTabs, LanguageTabContent, Callout } from "@/components/mdx";

# Review & Edit Planned Migrations

When `moose generate migration` finishes, the hard work begins. This page shows how to read `plan.yaml`, decide whether the diff is acceptable, and edit operations safely. The second half of the document is a complete reference for every supported migration action.

<LanguageTabs>
  <LanguageTabContent value="typescript" />
  <LanguageTabContent value="python" />
</LanguageTabs>

This reference documents all migration operations, data types, and plan structures for Moose migrations. Use it while reviewing pull requests or editing `plan.yaml`.

<Callout type="info" title="Looking for how-to guides?">
This is a reference document. For step-by-step instructions, see:
- [Generate Planned Migration Plans](/moosestack/migrate/planned-migrations) - Create plan artifacts
- [Local Development](/moosestack/migrate/apply-migrations) - Develop with `moose dev`
- [Apply Plans with CLI](/moosestack/migrate/apply-planned-migrations-cli) - `moose migrate` workflow
- [Apply Plans with Moose Prod](/moosestack/migrate/apply-planned-migrations-service) - Automated runtime workflow
</Callout>

## How to Review `plan.yaml`

1. **Scan the operation list** – Confirm only the tables you touched appear. Unexpected `Drop*` operations almost always mean Moose inferred a rename or removal.
2. **Validate column definitions** – Ensure types, nullability, and defaults match your intent. Required columns added to existing tables usually need a default or backfill.
3. **Check ordering** – Moose sequences teardown actions before creates. If dependencies exist (e.g., materialized views), verify the order makes sense.
4. **Confirm snapshots** – `remote_state.json` should match production when you apply the plan. If someone else changed the database later, regenerate the plan before applying.

<Callout type="warning" title="Never edit drift snapshots manually">
`remote_state.json` and `local_infra_map.json` are used for drift detection. If their hashes don’t match when you run `moose migrate` or start `moose prod`, the deployment fails. Always regenerate instead of hand-editing these files.
</Callout>

## Editing the Plan

`plan.yaml` is just YAML—you can adjust operations before committing:

- Replace a `DropTableColumn` + `AddTableColumn` pair with `RenameTableColumn` to preserve data
- Add `RawSql` blocks for custom backfills
- Reorder operations when dependencies require a different sequence

The sections below document every supported action plus common edit patterns.

## Quick Reference

### Operations at a Glance

| Operation | What it does | Destructive |
|-----------|-------------|-------------|
| [CreateTable](#createtable) | Creates a new table | No |
| [DropTable](#droptable) | Removes a table | ⚠️ Yes |
| [AddTableColumn](#addtablecolumn) | Adds a column to existing table | No |
| [DropTableColumn](#droptablecolumn) | Removes a column | ⚠️ Yes |
| [RenameTableColumn](#renametablecolumn) | Renames a column (preserves data) | No |
| [ModifyTableColumn](#modifytablecolumn) | Changes column type/properties | ⚠️ Maybe |
| [RawSql](#rawsql) | Executes custom SQL | ⚠️ Varies |
| [CreateStream](#createstream) | Creates Kafka/Redpanda topic | No |
| [DropStream](#dropstream) | Removes topic | ⚠️ Yes |

### Key Terms

**Auto-Inferred Migrations**
Moose compares your code to the database and automatically generates operations without creating plan files. Used in `moose dev` for rapid iteration.

**Planned Migrations**
Generate `plan.yaml` file, review changes, commit to git, then execute. Provides drift detection and audit trails. Enable with `ddl_plan = true`.

**DDL (Data Definition Language)**
SQL statements that modify schema structure: `CREATE TABLE`, `ALTER TABLE`, `DROP TABLE`, etc. Moose generates these from your code or plan files.

**Drift**
When the actual database state doesn't match what Moose expects. Planned migrations detect drift before applying changes and abort if found.

**Lifecycle Modes**
Control what operations Moose can perform on specific tables:
- `FULLY_MANAGED` - All operations allowed (default)
- `DELETION_PROTECTED` - Blocks drops and destructive changes
- `EXTERNALLY_MANAGED` - Read-only, Moose doesn't modify

**Service Model**
Deploy with `moose prod` - migrations apply automatically on startup. Full MooseStack runtime.

**Library Model**
Integrate Moose into existing apps - migrations run with `moose migrate` CLI command when you choose.

---

## Scope

Migration operations apply to:
- **OLAP Tables** - ClickHouse tables and materialized views
- **Streams** - Kafka/Redpanda topics

Operations do **not** apply to:
- APIs (managed separately)
- Workflows (managed separately)

Operations only apply to enabled features in `moose.config.toml`:

```toml
[features]
olap = true              # Required for table operations
streaming_engine = true  # Required for stream operations
```

## Table Operations

### CreateTable

**What it does:** Creates a new ClickHouse table with specified schema, engine, and configuration.

**Code:**

<LanguageTabs>
  <LanguageTabContent value="typescript" label="TypeScript">

```typescript
import { Key, OlapTable, ClickHouseEngines } from "@514labs/moose-lib";

interface User {
  id: Key<string>;
  email: string;
  name: string;
  created_at: Date;
}

export const users = new OlapTable<User>("users", {
  engine: ClickHouseEngines.MergeTree,
  orderByFields: ["created_at"],
});
```

  </LanguageTabContent>
  <LanguageTabContent value="python" label="Python">

```python
from datetime import datetime
from pydantic import BaseModel
from moose_lib import Key, OlapTable, OlapConfig, ClickHouseEngines

class User(BaseModel):
    id: Key[str]
    email: str
    name: str
    created_at: datetime

users = OlapTable[User]("users", OlapConfig(
    engine=ClickHouseEngines.MergeTree,
    order_by_fields=["created_at"],
))
```

  </LanguageTabContent>
</LanguageTabs>

**Generated plan operation:**
```yaml
- CreateTable:
    table:
      name: users
      columns:
        - name: id
          data_type: String
          required: true
          primary_key: true
        - name: email
          data_type: String
          required: true
        - name: name
          data_type: String
          required: true
        - name: created_at
          data_type: DateTime
          required: true
      order_by: [created_at]
      engine: MergeTree
```

**Result:** New table `users` created in ClickHouse.

---

### DropTable

**What it does:** Removes an existing table and all its data.

**Code:** Remove the table export from your code.

<LanguageTabs>
  <LanguageTabContent value="typescript" label="TypeScript">

```typescript
// Remove or stop exporting:
// export const users = new OlapTable<User>("users");
```

  </LanguageTabContent>
  <LanguageTabContent value="python" label="Python">

```python
# Remove or stop importing:
# users = OlapTable[User]("users")
```

  </LanguageTabContent>
</LanguageTabs>

**Generated plan operation:**
```yaml
- DropTable:
    table: users
```

**Result:** Table `users` and all its data permanently deleted.

<Callout type="warning" title="Data loss">
This operation is destructive. All data in the table is permanently lost. Use `DELETION_PROTECTED` lifecycle mode to prevent accidental drops.
</Callout>

---

### AddTableColumn

**What it does:** Adds a new column to an existing table.

**Code:** Add a field to your interface/class.

<LanguageTabs>
  <LanguageTabContent value="typescript" label="TypeScript">

```typescript
interface User {
  id: Key<string>;
  email: string;
  name: string;
  phone_number: string; // New field
}
```

  </LanguageTabContent>
  <LanguageTabContent value="python" label="Python">

```python
class User(BaseModel):
    id: Key[str]
    email: str
    name: str
    phone_number: str  # New field
```

  </LanguageTabContent>
</LanguageTabs>

**Generated plan operation:**
```yaml
- AddTableColumn:
    table: users
    column:
      name: phone_number
      data_type: String
      required: true
      default: null
```

**Result:** New column `phone_number` added to table. Existing rows get `null` (or specified default value).

**Options:**
- Set `required: false` for nullable columns
- Specify `default` value for backfilling existing rows
- Use `after_column` to control column position

---

### DropTableColumn

**What it does:** Removes a column from an existing table.

**Code:** Remove the field from your interface/class.

<LanguageTabs>
  <LanguageTabContent value="typescript" label="TypeScript">

```typescript
interface User {
  id: Key<string>;
  email: string;
  // name field removed
}
```

  </LanguageTabContent>
  <LanguageTabContent value="python" label="Python">

```python
class User(BaseModel):
    id: Key[str]
    email: str
    # name field removed
```

  </LanguageTabContent>
</LanguageTabs>

**Generated plan operation:**
```yaml
- DropTableColumn:
    table: users
    column_name: name
```

**Result:** Column `name` and all its data permanently deleted.

<Callout type="warning" title="Data loss">
All data in the dropped column is permanently lost. If you're renaming a column, manually edit the plan to use `RenameTableColumn` instead.
</Callout>

---

### RenameTableColumn

**What it does:** Renames a column without losing data.

**Code:** Rename the field in your interface/class.

<LanguageTabs>
  <LanguageTabContent value="typescript" label="TypeScript">

```typescript
interface User {
  id: Key<string>;
  email: string;
  full_name: string; // Renamed from 'name'
}
```

  </LanguageTabContent>
  <LanguageTabContent value="python" label="Python">

```python
class User(BaseModel):
    id: Key[str]
    email: str
    full_name: str  # Renamed from 'name'
```

  </LanguageTabContent>
</LanguageTabs>

**Generated plan operation (auto-inferred):**
```yaml
# Moose will generate drop + add:
- DropTableColumn:
    table: users
    column_name: name
- AddTableColumn:
    table: users
    column:
      name: full_name
      data_type: String
```

**Manual edit to preserve data:**
```yaml
- RenameTableColumn:
    table: users
    before_column_name: name
    after_column_name: full_name
```

**Result:** Column renamed, data preserved.

<Callout type="info" title="Requires manual editing">
Moose cannot automatically detect renames—they look like drop + add. You must manually edit the migration plan to use `RenameTableColumn`.
</Callout>

---

### ModifyTableColumn

**What it does:** Changes the data type or attributes of an existing column.

**Code:** Change the field type or annotations.

<LanguageTabs>
  <LanguageTabContent value="typescript" label="TypeScript">

```typescript
interface User {
  id: Key<string>;
  email: string & LowCardinality; // Added optimization
  name: string;
}
```

  </LanguageTabContent>
  <LanguageTabContent value="python" label="Python">

```python
from typing import Annotated

class User(BaseModel):
    id: Key[str]
    email: Annotated[str, "LowCardinality"]  # Added optimization
    name: str
```

  </LanguageTabContent>
</LanguageTabs>

**Generated plan operation:**
```yaml
- ModifyTableColumn:
    table: users
    before_column:
      name: email
      data_type: String
      required: true
    after_column:
      name: email
      data_type:
        LowCardinality:
          nullable: String
      required: true
```

**Result:** Column type changed. Data converted if compatible.

**Compatibility notes:**
- Some type changes are incompatible (e.g., `String` → `Int64`)
- See [troubleshooting schema changes](/moosestack/migrate/schema-change) for details
- Test type changes in dev before applying to production

---

### RawSql

**What it does:** Executes custom SQL statements for operations not covered by other operations.

**Use cases:**
- Creating materialized views
- Custom backfill logic
- Complex schema transformations
- Adding ClickHouse-specific features (indexes, TTL, etc.)

**Manual plan entry:**
```yaml
- RawSql:
    sql:
      - "CREATE MATERIALIZED VIEW user_stats TO user_stats_table AS SELECT user_id, count() as event_count FROM events GROUP BY user_id"
    description: "Creating materialized view for user statistics"
```

**Result:** SQL executed as written.

<Callout type="warning" title="Use with caution">
`RawSql` bypasses Moose's safety checks. Ensure your SQL is correct and test in dev first. Syntax errors or destructive operations can cause migration failures.
</Callout>

---

## Stream Operations

### CreateStream

**What it does:** Creates a new Kafka/Redpanda topic for streaming data.

**Code:**

<LanguageTabs>
  <LanguageTabContent value="typescript" label="TypeScript">

```typescript
import { Stream } from "@514labs/moose-lib";

interface UserEvent {
  user_id: string;
  event_type: string;
  timestamp: Date;
}

export const userEvents = new Stream<UserEvent>("user_events");
```

  </LanguageTabContent>
  <LanguageTabContent value="python" label="Python">

```python
from datetime import datetime
from pydantic import BaseModel
from moose_lib import Stream

class UserEvent(BaseModel):
    user_id: str
    event_type: str
    timestamp: datetime

user_events = Stream[UserEvent]("user_events")
```

  </LanguageTabContent>
</LanguageTabs>

**Generated plan operation:**
```yaml
- CreateStream:
    stream:
      name: user_events
      schema: UserEvent
```

**Result:** New topic `user_events` created in Redpanda/Kafka.

**Requirements:**
```toml
[features]
streaming_engine = true  # Must be enabled
```

---

### DropStream

**What it does:** Removes an existing stream/topic.

**Code:** Remove the stream export from your code.

**Generated plan operation:**
```yaml
- DropStream:
    stream: user_events
```

**Result:** Topic deleted. Messages in topic are lost.

---

## Data Types Reference

Moose supports all ClickHouse data types. This section documents how to specify them in migration plans.

### Numeric Types

**Signed Integers:**
- `Int8`, `Int16`, `Int32`, `Int64`, `Int128`, `Int256`

**Unsigned Integers:**
- `UInt8`, `UInt16`, `UInt32`, `UInt64`, `UInt128`, `UInt256`

**Floating Point:**
- `Float32`, `Float64`

**Large Integers:**
- `BigInt`

**Decimal:**
```yaml
data_type: Decimal(10, 2)  # M = total digits, N = decimal places
```

### String Types

- `String` - Variable-length string
- `Bytes` - Binary data
- `UUID` - UUID identifier
- `IPv4`, `IPv6` - IP address types

### Date and Time Types

- `Date` - Date only (no time component)
- `Date16` - Date with 16-bit precision
- `DateTime` - Date and time
- `DateTime(N)` - Date and time with timezone precision (N = 1-3 digits)

**Example:**
```yaml
data_type: DateTime  # or DateTime(3) for millisecond precision
```

### Boolean Type

- `Boolean` - True/false value

### JSON Type

- `Json` - JSON data

### Complex Types

**Nullable Types:**
```yaml
data_type:
  nullable: String  # Makes any type nullable
```

**Arrays:**
```yaml
data_type:
  elementType: String
  elementNullable: false  # Whether array elements can be null
```

**Maps:**
```yaml
data_type:
  keyType: String
  valueType: Int64
```

**Structs/Tuples:**
```yaml
data_type:
  fields:
    - ["field_name", String]
    - ["field_count", Int64]
```

**Nested Types:**
```yaml
data_type:
  name: "Address"
  columns:
    - name: street
      data_type: String
      required: true
      unique: false
      primary_key: false
    - name: city
      data_type: String
      required: true
      unique: false
      primary_key: false
  jwt: false
```

**Enums:**

String enum:
```yaml
data_type:
  name: "Status"
  values:
    - name: "ACTIVE"
      value:
        String: "active"
    - name: "INACTIVE"
      value:
        String: "inactive"
```

Integer enum:
```yaml
data_type:
  name: "Priority"
  values:
    - name: "LOW"
      value:
        Int: 0
    - name: "HIGH"
      value:
        Int: 1
```

**LowCardinality Optimization:**
```yaml
data_type:
  LowCardinality:
    nullable: String  # Optimizes storage for low-cardinality columns
```

---

## Column Properties Reference

When defining columns in migration plans, you must specify these properties:

### Required Properties

**`name`** (string, required)
- Column identifier
- Must be unique within the table
- Example: `"user_id"`, `"created_at"`

**`data_type`** (type, required)
- One of the [supported data types](#data-types-reference)
- Can be simple (`String`) or complex (arrays, maps, etc.)

**`required`** (boolean, required)
- Whether the column must have a value
- `true` = NOT NULL
- `false` = NULL allowed

**`unique`** (boolean, required)
- Whether values must be unique across rows
- `true` = enforces uniqueness
- `false` = allows duplicates

**`primary_key`** (boolean, required)
- Whether this column is part of the primary key
- Used for row identification and deduplication
- `true` = part of primary key
- `false` = not part of primary key

### Optional Properties

**`default`** (string | null, optional)
- Default value for new rows
- Can be:
  - `null` - No default
  - `"value"` - Static value
  - `"now()"` - ClickHouse function
  - `"0"` - Numeric default

**`annotations`** (array, optional)
- Array of annotation tuples: `[string, boolean]`
- Used for metadata or special properties
- Example: `[["indexed", true]]`

**`comment`** (string | null, optional)
- Human-readable description of the column
- Stored in database metadata
- Example: `"User's primary email address"`

### Example Column Definition

```yaml
column:
  name: email
  data_type: String
  required: true
  unique: true
  primary_key: false
  default: null
  annotations: []
  comment: "User's primary email address"
```

---

## Migration Plan Structure

All migration plans follow this structure:

```yaml
created_at: 2025-01-14T10:30:00Z
operations:
  - <Operation1>
  - <Operation2>
  - <Operation3>
```

**Operation order:**
1. **Teardown operations first** - Drops, removals
2. **Setup operations second** - Creates, additions
3. **Modifications last** - Renames, type changes

This order avoids dependency conflicts (e.g., dropping a table that a view depends on).

---

## Common Operation Combinations

### Rename a Column (Preserving Data)

**Auto-generated plan:**
```yaml
- DropTableColumn:
    table: users
    column_name: createdAt
- AddTableColumn:
    table: users
    column:
      name: created_at
      data_type: DateTime
```

**Manually edit to:**
```yaml
- RenameTableColumn:
    table: users
    before_column_name: createdAt
    after_column_name: created_at
```

---

### Add Column with Backfill

**Auto-generated plan:**
```yaml
- AddTableColumn:
    table: users
    column:
      name: last_active
      data_type: DateTime
      default: null
```

**Manually edit to add backfill:**
```yaml
- AddTableColumn:
    table: users
    column:
      name: last_active
      data_type: DateTime
      default: null
- RawSql:
    sql:
      - "UPDATE users SET last_active = created_at WHERE last_active IS NULL"
    description: "Backfill last_active from created_at"
```

---

### Create Materialized View

**Plan entry (manual):**
```yaml
- CreateTable:
    table:
      name: user_stats
      columns:
        - name: user_id
          data_type: String
          primary_key: true
        - name: event_count
          data_type: UInt64
      order_by: [user_id]
      engine: MergeTree
- RawSql:
    sql:
      - "CREATE MATERIALIZED VIEW user_stats_mv TO user_stats AS SELECT user_id, count() as event_count FROM events GROUP BY user_id"
    description: "Creating materialized view for user statistics"
```

---

## Plan File Format

Migration plans are stored as `migrations/plan.yaml`:

```yaml
created_at: 2025-01-14T10:30:00.000Z
operations:
  - AddTableColumn:
      table: users
      column:
        name: status
        data_type: String
        required: false
        unique: false
        primary_key: false
        default: 'active'
        annotations: []
        comment: null
      after_column: email

  - RenameTableColumn:
      table: events
      before_column_name: createdAt
      after_column_name: created_at

  - DropTableColumn:
      table: legacy_data
      column_name: deprecated_field
```

---

## Best Practices

**Review generated plans:**
- Always review `plan.yaml` before applying
- Check for unexpected `DropTableColumn` or `DropTable` operations
- Verify renames are detected correctly (edit if needed)

**Edit plans when needed:**
- Use `RenameTableColumn` instead of drop+add for renames
- Add `RawSql` for custom backfills
- Adjust operation order if dependencies exist

**Test in development:**
- Use `moose dev` to test migrations locally
- Verify data compatibility for type changes
- Check materialized views recalculate correctly

**Use lifecycle modes:**
- `DELETION_PROTECTED` - Blocks drops (production default)
- `FULLY_MANAGED` - Allows all operations (development)
- `EXTERNALLY_MANAGED` - Read-only (shared tables)

See [lifecycle management](/moosestack/migrate/lifecycle) for details.

---

## See Also

- [Migration concept guide](/moosestack/migrate) - Understanding migration modes and models
- [Local development](/moosestack/migrate/apply-migrations) - Develop with auto-inferred migrations
- [Planned migrations](/moosestack/migrate/planned-migrations) - Production workflow guide
- [Lifecycle management](/moosestack/migrate/lifecycle) - Control allowed operations
- [CLI commands](/moosestack/moose-cli#generate-migration-plan-olap) - moose migrate and related commands

