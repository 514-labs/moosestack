---
title: How to Use Planned Migrations with Library Model
description: Generate, review, and manually apply database schema changes when integrating Moose into existing applications
order: 13
category: olap
---

import { Callout, LanguageTabs, LanguageTabContent } from "@/components/mdx";

# How to Use Planned Migrations with Library Model

<LanguageTabs>
  <LanguageTabContent value="typescript" />
  <LanguageTabContent value="python" />
</LanguageTabs>

This guide walks you through using planned migrations with the library deployment model (`moose migrate`). You'll learn how to safely apply database schema changes to production when Moose is integrated into your existing Next.js, Express, FastAPI, or other application.

<Callout type="info" title="New to migrations?" href="/moosestack/migrate" ctaLabel="Read the concept guide" compact>
If you're unfamiliar with migration modes or deployment models, start with the migrations concept guide.
</Callout>

## When to Use This Guide

Use this guide if:
- You're integrating Moose into an existing application (Next.js, Express, FastAPI, etc.)
- You want explicit control over when migrations execute
- You want to review exact schema changes before they apply
- You need to coordinate migrations with your deployment pipeline

If you're using the full MooseStack runtime with `moose prod`, see [How to Use Planned Migrations with Service Model](/moosestack/migrate/planned-migrations) instead.

## Before You Begin

**Required configuration:**
```toml file="moose.config.toml"
language = "typescript"  # or "python"
source_dir = "moose"     # Where your schema files live

[state_config]
storage = "clickhouse"

[features]
olap = true
ddl_plan = true          # Enables planned migrations
streaming_engine = false # Unless you need Kafka/Redpanda
workflows = false
apis = false
```

**Required access:**
- ClickHouse connection string with DDL permissions (`CREATE`, `ALTER`, `DROP`)
- Git repository with pull request workflow
- CI/CD pipeline access (recommended for automation)

**Prerequisites:**
- Moose CLI installed (`npm i -g @514labs/moose-cli` or `pip install moose-cli`)
- Existing application with Moose library installed
- Basic understanding of your table schemas
- Familiarity with your deployment process

**Connection string format:**
```bash
clickhouse://username:password@hostname:port/database
```

## Steps

### 1. Make schema changes in your code

Edit your table definitions on a feature branch. The changes must be in the source directory specified in your config (e.g., `moose/`).

<LanguageTabs>
  <LanguageTabContent value="typescript" label="TypeScript">

```typescript filename="moose/index.ts" copy
import { Key, OlapTable } from "@514labs/moose-lib";

interface PageView {
  id: Key<string>;
  path: string;
  referrer?: string;
  timestamp: Date;
  user_agent: string; // New field added
}

export const pageViews = new OlapTable<PageView>("page_views");
```

  </LanguageTabContent>
  <LanguageTabContent value="python" label="Python">

```python filename="moose/main.py" copy
from datetime import datetime
from typing import Optional
from pydantic import BaseModel
from moose_lib import Key, OlapTable

class PageView(BaseModel):
    id: Key[str]
    path: str
    referrer: Optional[str] = None
    timestamp: datetime
    user_agent: str  # New field added

page_views = OlapTable[PageView]("page_views")
```

  </LanguageTabContent>
</LanguageTabs>

Commit these changes to your branch but don't merge yet.

### 2. Generate the migration plan from production

Run this command from your project root, pointing to your production ClickHouse database:

```bash filename="Terminal" copy
export PROD_CLICKHOUSE_URL="clickhouse://user:password@prod-host:9440/analytics"
moose generate migration --clickhouse-url "$PROD_CLICKHOUSE_URL" --save
```

<Callout type="warning" title="Keep credentials secure" compact>
Store connection strings in environment variables or your secrets manager, never in shell history or committed code. Use `$PROD_CLICKHOUSE_URL` in commands rather than typing credentials directly.
</Callout>

**What happens:** Moose CLI connects to production ClickHouse, compares the live database state with your local code changes, and generates three files:

```text
./migrations/plan.yaml               # Operations to execute
./migrations/remote_state.json       # Production state snapshot
./migrations/local_infra_map.json    # Your code's desired state
```

**Expected output:**
```text
$ moose generate migration --clickhouse-url "$PROD_CLICKHOUSE_URL" --save
    Remote Plan Comparing local project code with deployed infrastructure
    Remote Plan Calculated plan differences locally
      Migration generated
```

### 3. Review the generated plan

Open `./migrations/plan.yaml` to see the exact operations Moose will perform:

```yaml filename="migrations/plan.yaml" copy
- AddTableColumn:
    table: page_views
    column:
      name: user_agent
      data_type: String
      required: true
      unique: false
      primary_key: false
      default: null
```

**What to check:**
- Verify the operations match your intent
- Ensure no unexpected drops or destructive changes
- Check the order of operations (teardowns happen first, then setups)

<Callout type="warning" title="Data loss risk">
If you see `DropTableColumn` operations, verify they're intentional. Moose Migrate doesn't distinguish column renames from drop-and-recreate, so a rename will appear as a drop followed by an add.
</Callout>

### 4. Edit the plan if needed (optional)

You can modify `plan.yaml` to override Moose's assumptions. Common edits:

**Rename a column instead of drop/add:**
```yaml filename="migrations/plan.yaml" copy
# Moose generated:
- DropTableColumn:
    table: page_views
    column_name: occurredAt
- AddTableColumn:
    table: page_views
    column:
      name: occurred_at
      data_type: DateTime

# Edit to preserve data:
- RenameTableColumn:
    table: page_views
    before_column_name: occurredAt
    after_column_name: occurred_at
```

**Add custom backfill logic:**
```yaml filename="migrations/plan.yaml" copy
- AddTableColumn:
    table: page_views
    column:
      name: session_id
      data_type: String
      required: false
      default: null
- RawSql:
    sql:
      - "UPDATE page_views SET session_id = generateUUIDv4() WHERE session_id IS NULL"
    description: "Generate session IDs for existing rows"
```

See the [migration reference](/moosestack/migrate/reference) for all available operations.

### 5. Commit the migration files

Add all three migration files to your branch:

```bash filename="Terminal" copy
git add migrations/
git commit -m "Add migration plan for user_agent column"
```

**Important:** Commit all three files together:
- `plan.yaml` - The operations to execute
- `remote_state.json` - Production snapshot for drift detection
- `local_infra_map.json` - Your code's desired state

### 6. Create a pull request

Push your branch and create a PR as usual:

```bash filename="Terminal" copy
git push origin your-feature-branch
```

**In the PR description, explain:**
- What schema changes you're making and why
- Any manual edits you made to the plan
- Expected impact on the database
- When you plan to run the migration

Your team can now review both the code changes and the exact migration operations.

### 7. Apply the migration to production

Once your PR is approved and merged, manually run the migration against production:

```bash filename="Terminal" copy
# Pull latest code including the migration files
git pull origin main

# Apply the migration
export PROD_CLICKHOUSE_URL="clickhouse://user:password@prod-host:9440/analytics"
moose migrate --clickhouse-url "$PROD_CLICKHOUSE_URL"
```

**What happens:**
1. Moose loads `migrations/plan.yaml`
2. Validates current production state matches `remote_state.json` (drift check)
3. Validates local code matches `local_infra_map.json`
4. Executes plan operations in order against ClickHouse
5. Completes and reports success

**Expected output:**
```text
$ moose migrate --clickhouse-url "$PROD_CLICKHOUSE_URL"
✓ Loading migration plan
✓ Validating production state (no drift detected)
✓ Validating code state (matches plan)
✓ Executing migration operations
  → AddTableColumn: page_views.user_agent
✓ Migration completed successfully
```

<Callout type="warning" title="Migration will abort if drift detected">
If someone else modified the production database since you generated the plan, the migration will fail. Regenerate the plan against current production and retry.
</Callout>

## Automating in CI/CD

Integrate migrations into your deployment pipeline to ensure they run before deploying application code.

### GitHub Actions Example

```yaml filename=".github/workflows/deploy.yml" copy
name: Deploy

on:
  push:
    branches: [main]

jobs:
  migrate:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install Moose CLI
        run: npm install -g @514labs/moose-cli

      - name: Apply migrations
        run: moose migrate --clickhouse-url "$PROD_CLICKHOUSE_URL"
        env:
          PROD_CLICKHOUSE_URL: ${{ secrets.CLICKHOUSE_URL }}

  deploy:
    needs: migrate
    runs-on: ubuntu-latest
    steps:
      - name: Deploy application
        run: # your deployment commands
```

### GitLab CI Example

```yaml filename=".gitlab-ci.yml" copy
migrate:
  stage: deploy
  script:
    - npm install -g @514labs/moose-cli
    - moose migrate --clickhouse-url "$PROD_CLICKHOUSE_URL"
  environment:
    name: production
  only:
    - main

deploy:
  stage: deploy
  needs: [migrate]
  script:
    - # your deployment commands
  only:
    - main
```

**Best practices for CI/CD:**
- Store connection strings as secrets, never in code
- Run migrations before deploying application changes
- Add a manual approval step for production migrations
- Set up notifications for migration failures
- Test migrations in staging environment first

## Development Workflow

For local development, you can use `moose dev` to spin up a local ClickHouse instance:

```bash filename="Terminal" copy
moose dev  # Starts local ClickHouse, applies migrations automatically
```

The local instance uses hot-reload, so schema changes apply immediately without manual migration commands.

**Local connection string (from default config):**
```bash
clickhouse://panda:pandapass@localhost:18123/local
```

## Troubleshooting

**Can't connect to ClickHouse:**
- Verify connection string format: `clickhouse://user:pass@host:port/database`
- Check that hostname and port are accessible from your location
- Ensure user has DDL permissions (`CREATE`, `ALTER`, `DROP`)
- Try connecting with `clickhouse-client` to test credentials

**Migration aborted due to drift:**
1. Someone modified production since you generated the plan
2. Regenerate the plan: `moose generate migration --clickhouse-url "$PROD_CLICKHOUSE_URL" --save`
3. Review the new plan for conflicts
4. Commit and apply the updated plan

**Plan not found:**
- Verify `migrations/plan.yaml` exists and is committed
- Check that you've pulled latest changes: `git pull origin main`
- Ensure you're running from the project root directory

**Type mismatch errors:**
- See [troubleshooting schema changes](/moosestack/migrate/schema-change) for data type compatibility issues
- Some type changes (e.g., `String` to `Int64`) require custom SQL migration

**Permissions errors:**
- Ensure ClickHouse user has `CREATE`, `ALTER`, and `DROP` permissions
- Check database-level permissions, not just server-level
- Verify user can access the specific database in the connection string

## Next Steps

- [How to use planned migrations with service model](/moosestack/migrate/planned-migrations) - For full MooseStack runtime
- [Migration reference](/moosestack/migrate/reference) - Operations, data types, and YAML reference
- [Lifecycle modes](/moosestack/migrate/lifecycle) - Control what operations are allowed per table
- [Add to existing app guide](/moosestack/getting-started/from-clickhouse) - Complete integration guide

