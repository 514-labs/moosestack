---
title: Migrations
description: Understanding how Moose manages database schema changes through code
order: 0
category: migrate
---

import { Callout } from "@/components/mdx";

# Migrations

If you've ever had your application code break because it didn't match your database schema, you know the pain of managing state in two places. Moose solves this by acting as a **synchronization engine** that keeps your code and infrastructure in alignment.

## Code-First vs Database-First

There are two common ways to manage schemas: "Code-First" (defining tables in your application) and "Database-First" (managing SQL directly).

Moose Migrate supports both approaches through a hybrid **synchronization** layer that can be configured on a per-table (or per-stream) basis:
1.  **Code-First**: Define models in code, and Moose Migrate pushes changes to the database.
2.  **Database-First**: Modify the database, and Moose Migrate detects drift and pulls the latest schema definitions into code.

This ensures that whether a table is fully managed by MooseStack or an external system, your application logic and your infrastructure remain consistent.

## How It Works

The migration engine compares two things:
1.  **The Desired State**: The schema of tables and streams defined in your code.
2.  **The Actual State**: The schemas currently running in your database (ClickHouse) or streaming platform (Redpanda).

For the **Code-First** workflow, you might define a `User` model in your application:

```typescript
// You write this in your code:
export interface User {
    id: string;
    name: string;
    email: string;
}

export const usersTable = new OlapTable<User>("Users");
```

Moose Migrate detects this definition and automatically ensures the corresponding table exists in your database:

```sql
-- Moose ensures this exists in your database:
CREATE TABLE User (
    id String,
    name String,
    email String
) ENGINE = MergeTree() ORDER BY id;
```

When it detects a difference—like a new column or a new table entirely—it generates a migration plan to bridge the gap.

## Development vs. Production

While the core concept is the same, the workflow changes depending on where you are in your development cycle.

### 1. Rapid Prototyping (Dev Mode)
When you're building a new feature locally, you want speed. You don't want to stop and approve a migration file every time you add a field to a struct.

In **Auto-Inferred** mode (the default for `moose dev`), Moose watches your files. The moment you save a change to a data model, Moose applies the schema update to your local Docker containers immediately. It feels like magic—you just code, and the database keeps up.

[Learn more about Auto-Inferred Migrations →](/moosestack/migrate/auto-inferred)

### 2. Safety & Control (Production)
When you're deploying to production, you want safety. You need to know exactly what's going to happen before it happens. You definitely don't want a rename operation to be misinterpreted as a "drop and create" that wipes out your user data.

For this, Moose Migrate uses **Planned Migrations**. You run a command to generate a migration plan (a strictly formatted file describing the changes). You review this plan, commit it to version control, and then apply it to your production environment. This gives you a predictable, auditable history of every change made to your database.

[Learn more about Planned Migrations →](/moosestack/migrate/planned-migrations)

## Protecting Your Data

Not all environments are equal. You might want to be able to delete tables freely in development but prevent accidental data loss in production. Or you might have legacy tables that Moose Migrate shouldn't touch at all.

Moose Migrate handles this via **Lifecycle Management**. You can tag specific tables or streams with policies like `DELETION_PROTECTED` (for safety) or `EXTERNALLY_MANAGED` (for database-first workflows). This tells the migration engine which operations are allowed—or ignored entirely for external tables.

[Learn more about Lifecycle Management →](/moosestack/migrate/lifecycle)

## Where to Go Next

*   **Just starting out?** Fire up `moose dev` and experience [Auto-Inferred Migrations](/moosestack/migrate/auto-inferred).
*   **Ready to deploy?** Learn how to generate and apply [Planned Migrations](/moosestack/migrate/planned-migrations).
*   **Need to script it?** Check out the [CLI Reference](/moosestack/migrate/apply-planned-migrations-cli) for CI/CD integration.
*   **Something went wrong?** See how to recover from [Failed Migrations](/moosestack/migrate/failed-migrations).
