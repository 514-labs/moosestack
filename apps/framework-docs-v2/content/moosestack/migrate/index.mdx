---
title: Migrations
description: Understanding how Moose manages database schema changes through code
order: 0
category: migrate
---

import { Callout } from "@/components/mdx";

# Migrations

Migrations synchronize your code-defined database schema with your production infrastructure. As your application evolves, you'll add/remove fields, change data types, and restructure tables. Moose Migrate handles these schema changes safely and reliably.

## How Migrations Work

Moose Migrate operates by comparing two states:

1. **Your code** - Tables and streams defined in your application
2. **Your database** - The actual schema in ClickHouse, Kafka, or Redpanda

When these states differ, Moose Migrate generates operations to bring them into alignment. These operations might include:

- Adding or dropping tables
- Adding, removing, or renaming columns
- Changing data types
- Creating or modifying streaming topics

The full list of operations is available in the [Migration Plan Format](/moosestack/migrate/plan-format) documentation.

## Core Concepts

Migrations in Moose revolve around three key decisions:

| Concept | What it is | Where to go |
| :--- | :--- | :--- |
| [Lifecycle Management](#lifecycle-management) | Controlling *what* changes are allowed (e.g., preventing data deletion). | [Overview](/moosestack/migrate/lifecycle) • [Fully Managed](/moosestack/migrate/lifecycle-fully-managed) • [Deletion Protected](/moosestack/migrate/lifecycle-deletion-protected) • [Externally Managed](/moosestack/migrate/lifecycle-externally-managed) |
| [Generating Migrations](#generating-migrations) | Deciding *how* changes are generated. | [Overview](/moosestack/migrate/modes) • [Auto-Inferred](/moosestack/migrate/auto-inferred) • [Planned](/moosestack/migrate/planned-migrations) |
| [Applying Changes](#applying-changes-to-production) | The workflow for executing migrations: serverless (`moose migrate`) vs server runtime (`moose prod`). | [Serverless](/moosestack/migrate/apply-planned-migrations-cli) • [Server Runtime](/moosestack/migrate/apply-planned-migrations-service) |


### Lifecycle Management

For each table and stream resource defined in your code, you can control *what* changes are allowed (e.g., preventing data deletion, ignoring schema changes, etc.) with the `LifeCycle` configuration property:

<LanguageTabs>
  <LanguageTabContent value="typescript" label="TypeScript">
```ts
import { OlapTable, LifeCycle } from "@514labs/moose-lib";

interface Schema {
  id: string;
  name: string;
  age: number;
}

const table = new OlapTable<Schema>("table_name", {
  lifeCycle: LifeCycle.FULLY_MANAGED
  orderByFields: ["id"]
});
```

  </LanguageTabContent>
  <LanguageTabContent value="python" label="Python">
```py
from moose_lib import OlapTable, LifeCycle, OlapConfig
from pydantic import BaseModel

class Schema(BaseModel):
  id: str
  name: str
  age: int

table = OlapTable[Schema]("table_name", OlapConfig(
  life_cycle=LifeCycle.FULLY_MANAGED
  order_by_fields=["id"]
))
```
  </LanguageTabContent>
</LanguageTabs>

| Option | Behavior | Use When |
| :--- | :--- | :--- |
| [`FULLY_MANAGED`](/moosestack/migrate/lifecycle-fully-managed) (default) | Automatically modifies resources to match your code, including destructive operations. | When you're developing new tables that you want your application to manage and evolve over time. |
| [`DELETION_PROTECTED`](/moosestack/migrate/lifecycle-deletion-protected) | Automatically modifies resources to match your code, but blocks destructive operations (drops, deletions). | When you want to protect critical production tables from accidental data loss. |
| [`EXTERNALLY_MANAGED`](/moosestack/migrate/lifecycle-externally-managed) | Does not modify resources. You manage the schema manually directly in your database. | When you have existing tables that you want to manage outside of your application, or if you're using a Managed CDC service like [ClickPipes](https://clickhouse.com/cloud/clickpipes) or [PeerDB](https://peerdb.io) to manage your schema. |

<Callout type="info" title="Per-resource configuration">
You configure lifecycle modes individually on each `OlapTable` and `Stream` object. This allows you to mix fully managed development tables with deletion-protected production tables and externally managed legacy resources in the same application.
</Callout>

[Compare Lifecycle Management Modes →](/moosestack/migrate/lifecycle)

### Generating Migrations

Moose Migrate provides two complementary ways to generate migrations. Each is designed for use in different stages of the application lifecycle, and it's best practice to use both in your workflow:

| Option | Behavior | Use Case |
| :--- | :--- | :--- |
| [Auto-Inferred](/moosestack/migrate/auto-inferred) | Updates database instantly on file save. Fast iteration, but can be destructive. | Local development, fast prototyping |
| [Planned](/moosestack/migrate/planned-migrations) | Generates reviewable plan files. Safe, deterministic, with drift detection. | Production deployment, CI/CD |


[Compare Migration Modes →](/moosestack/migrate/modes)

### Applying Changes

You have two options for executing planned migrations against your production database:

| Mode | Behavior | Use Case |
| :--- | :--- | :--- |
| [Serverless (`moose migrate`)](/moosestack/migrate/apply-planned-migrations-cli) | You run migrations manually or via CI/CD. | Integrating Moose OLAP into an existing application as a library. |
| [Server Runtime (`moose prod`)](/moosestack/migrate/apply-planned-migrations-service) | Migrations are automatically run within the Moose Runtime on server startup. | Building a dedicated analytics service with the full Moose Runtime. |


## Advanced Topics

- [Failed Migrations](/moosestack/migrate/failed-migrations) - Recover from migration errors
