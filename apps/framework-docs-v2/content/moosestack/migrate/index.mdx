---
title: Migrations
description: Understanding how Moose manages database schema changes through code
order: 0
category: migrate
---

import { LanguageTabs, LanguageTabContent, Callout } from "@/components/mdx";

# Migrations

<LanguageTabs>
  <LanguageTabContent value="typescript" />
  <LanguageTabContent value="python" />
</LanguageTabs>

When you define database tables and streaming topics in your code, you need a way to synchronize those definitions with your actual infrastructure. As your application evolves, you'll add fields, change data types, and restructure tables. Migrations are the mechanism that makes these schema changes safely and reliably.

## What Are Migrations?

Migrations are operations that update your database schema to match your code definitions. Instead of manually writing SQL commands or managing schema changes through a database interface, you declare your desired schema in code, and Moose Migrate calculates what needs to change and applies those changes for you.

Think of migrations like version control for your database structure. Just as Git tracks changes to your code, migrations track changes to your schema, creating an audit trail and enabling safe, repeatable deployments.

### Why Migrations Matter

Database schema changes are risky. A mistaken column drop can lose customer data. An incorrectly applied change during high traffic can cause downtime. Manual SQL scripts are error-prone and hard to track across environments.

Moose Migrate solves these problems by:

- **Generating changes automatically** - You focus on your schema definition, not SQL syntax
- **Providing review workflows** - See exactly what will change before it happens
- **Detecting conflicts** - Know when someone else has modified the database
- **Preserving data** - Use rename operations instead of destructive drop-and-recreate
- **Creating audit trails** - Track every schema change through version control

## How Migrations Work

Moose Migrate operates through a comparison model. The system compares two states:

1. **Your code** - Tables and streams defined in your application
2. **Your database** - The actual schema in ClickHouse, Kafka, or Redpanda

When these states differ, Moose generates a set of operations to bring them into alignment. These operations might include:

- Adding or dropping tables
- Adding, removing, or renaming columns
- Changing data types
- Creating or modifying streaming topics

The key insight is that Moose handles the complexity of schema evolution so you can focus on your application logic.

## Core Concepts

Understanding migrations requires familiarity with three key decisions:

### Migration Modes: Planned vs Auto-Inferred

This determines **how** migration operations are generated and when you review them.

**Planned migrations** generate a migration plan file that you review and commit before execution. This is like a pull request for your database—you see the exact changes, can edit them if needed, and approve them explicitly.

**Auto-inferred migrations** diff your code against the database on-the-fly and apply changes immediately. This is faster for development but riskier for production, since there's no review step.

### Deployment Models: Service vs Library

This determines **when** migrations execute.

**Service model** (`moose prod`) runs migrations automatically when your application starts. MooseStack manages the entire runtime, including the database and migration lifecycle.

**Library model** (`moose migrate`) lets you control migration timing through CLI commands. This is useful when integrating Moose into an existing application where you manage deployment workflows yourself.

### Lifecycle Modes: What Changes Are Allowed

This determines **which** operations Moose can perform on specific tables or streams.

- **`FULLY_MANAGED`** allows all operations including drops (data loss possible)
- **`DELETION_PROTECTED`** allows additions and modifications but blocks destructive operations
- **`EXTERNALLY_MANAGED`** makes resources read-only (Moose will not modify them)

These three concepts combine to give you precise control over schema evolution.

## When to Use Each Migration Mode

Choosing the right migration mode depends on your environment and risk tolerance.

### Use Planned Migrations When:

**You're deploying to production** - Reviewing exact changes before execution prevents costly mistakes. If you're running a production system with real data, planned migrations are essential.

**Multiple systems touch your database** - If you use ClickPipes, PeerDB, Airbyte, or other data integration tools, you need drift detection. Planned migrations will abort if the database state doesn't match expectations.

**Your team requires approval workflows** - Many organizations require pull request reviews for infrastructure changes. Planned migrations create reviewable artifacts that fit naturally into this workflow.

**You need compliance audit trails** - SOC2, HIPAA, and similar frameworks often require documented approval for database changes. Committing migration plans to Git creates this trail automatically.

### Use Auto-Inferred Migrations When:

**You're in early development** - Rapid iteration matters more than safety when you're building a prototype or exploring design options. Auto-inferred migrations let you change your schema and see results immediately.

**You're comfortable with potential data loss** - Auto-inferred migrations can't distinguish renames from drop-and-recreate. If you remove a field, it will drop the column and lose data.

<Callout type="warning">
Auto-inferred migrations are primarily meant for development environments. For production, planned migrations provide review, drift detection, and audit trails that are difficult to replicate with auto-inference.
</Callout>

<Callout type="warning" title="ClickHouse Requirements for Serverless">
Your ClickHouse instance needs the KeeperMap engine for state storage and migration locking.

✅ **ClickHouse Cloud**: Works out of the box
✅ **`moose dev` or `moose prod`**: Already configured
⚠️ **Self-hosted ClickHouse**: See [ClickHouse KeeperMap documentation](https://clickhouse.com/docs/en/engines/table-engines/special/keeper-map) for setup requirements
</Callout>

### State Storage Options

Moose migrations require storing infrastructure state and coordinating locks. You can choose between two backends:

**ClickHouse State Storage (Default)**
Uses the `_MOOSE_STATE` KeeperMap table. Best for:
- ClickHouse Cloud (works out of the box)
- Self-hosted with ClickHouse Keeper already configured

**Redis State Storage**
Uses Redis for state and locking. Best for:
- Existing Redis infrastructure
- Multi-tenant deployments (isolated by `key_prefix`)
- When ClickHouse Keeper isn't available

**Configuration:**
```toml filename="moose.config.toml" copy
[state_config]
storage = "redis"  # or "clickhouse" (default)
```

**Usage with Redis:**
```bash filename="Terminal" copy
# With environment variable (recommended)
export MOOSE_REDIS_CONFIG__URL="redis://host:port"
moose migrate --clickhouse-url clickhouse://...

# Or with CLI flag
moose migrate \
  --clickhouse-url clickhouse://... \
  --redis-url redis://host:port
```

<Callout type="info">
The ClickHouse URL is always required, even when using Redis for state storage.
</Callout>

### Understanding Plan Output

Moose shows exactly what will change:

```bash
  +  Table: Analytics Version None - id: String, number: Int64, status: String -  - deduplicate: false
  +  Table: Users Version None - id: String, name: String, email: String -  - deduplicate: false
```

## Migration Types

| Change Type | Infrastructure Impact | Data Impact |
|-------------|----------------------|-------------|
| **Add new object** | New table/stream/API created | No impact |
| **Remove object** | Table/stream/API dropped | All data lost |
| **Add field** | New column created | Existing rows get NULL/default |
| **Remove field** | Column dropped | Data permanently lost |
| **Change type** | Column altered | Data converted if compatible |

For detailed examples of each migration type, see [Migration Types](/moosestack/migrate/migration-types).

## Viewing Infrastructure State

### Via CLI
```bash
# Check current infrastructure objects
moose ls

# View migration logs
moose logs
```

### Via Direct Connection

Connect to your local infrastructure using details from `moose.config.toml`:

```toml file="moose.config.toml"
[features]
olap = true              # ClickHouse for analytics
streaming_engine = true  # Redpanda for streaming
workflows = false        # Temporal for workflows

[clickhouse_config]
host = "localhost"
host_port = 18123
native_port = 9000
db_name = "local"
user = "panda"
password = "pandapass"

[redpanda_config]
broker = "localhost:19092"
message_timeout_ms = 1000
retention_ms = 30000
replication_factor = 1
```

## Best Practices

### Development
- Use `moose dev` for all local development
- Monitor plan outputs for warnings
- Test schema changes with sample data

### Production
- Always use remote planning before deployments
- Review changes carefully in production plans
- Maintain proper authentication
- Test migrations in staging first

### Managing TTL Outside Moose

If you're managing ClickHouse TTL settings through other tools or want to avoid migration failures from TTL drift, you can configure Moose to ignore TTL changes:

```toml filename="moose.config.toml" copy
[migration_config]
ignore_operations = ["ModifyTableTtl", "ModifyColumnTtl"]
```

This tells Moose to:
- Skip generating TTL change operations in migration plans
- Ignore TTL differences during drift detection

You'll still get migrations for all other schema changes (adding tables, modifying columns, etc.), but TTL changes won't block your deployments.

## Troubleshooting

### Authentication Errors
- Verify your authentication token
- Generate a new token: `moose generate hash-token`
- Check server configuration in `moose.config.toml`

### Migration Issues
- Check `moose logs` for detailed error messages
- Verify object definitions in your main file
- Ensure all required fields are properly typed
- **Stuck migration lock**: If you see "Migration already in progress" but no migration is running, wait 5 minutes for automatic expiry or manually clear it:
  ```sql copy=false
  DELETE FROM _MOOSE_STATE WHERE key = 'migration_lock';
  ```
