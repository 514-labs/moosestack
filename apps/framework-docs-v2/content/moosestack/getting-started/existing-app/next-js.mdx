---
title: Embed ClickHouse analytics in Next.js
description: Add MooseStack to an existing Next.js app to model, migrate, and query ClickHouse from Server Components (no separate backend service).
---

import { Callout, FileTree, BulletPointsCard } from "@/components/mdx";

# Embed ClickHouse analytics in your Next.js app

## Overview

This guide shows how to add MooseStack to an existing Next.js (App Router) app as a library. You keep Next.js as your app runtime, but you get ClickHouse schema management as TypeScript code, type-safe query helpers you can import into server-side handlers, and a production migration workflow—without deploying a separate backend service.

#### Intended audience
Developers with an existing Next.js app who want to **embed schema management + type-safe ClickHouse queries** without deploying a separate backend service.

#### What you’ll accomplish

By the end of this guide, you’ll be able to:

- Model ClickHouse schema in TypeScript in a `moose/` directory (tables, views/materialized views)
- Query ClickHouse from your Next.js server-side code using type-safe query helpers
- Run migrations against production ClickHouse with the Moose CLI as part of your existing deployment workflow

### Guide outline

- **[Get started](#get-started):** install and configure MooseStack in your Next.js repo, then set up your project so you can import the compiled output from `@/moose`.
- **[Model table](#model-table):** define your ClickHouse table schema in TypeScript in `moose/index.ts`.
- **[Start local ClickHouse](#start-local-clickhouse):** run `moose dev` to spin up a local ClickHouse instance and automatically instantiate (and hot-reload) your TypeScript models against it.
- **[Write queries](#write-queries):** create type-safe query helpers that use your models, and set up the Moose ClickHouse client to connect to your local ClickHouse instance.
- **[Use in Next.js](#use-in-nextjs):** import the compiled query helpers from `@/moose` into Server Components / Route Handlers, run your app, and see the query results render in your pages.
- **[Deploy to production](#deploy-to-production):** use the Moose CLI to run migrations against production ClickHouse, then update your production environment variables to point at it.

{/* ### What you’ll change in your repo

You’ll touch a few things: dependencies + scripts, `moose.config.toml`, `tsconfig.moose.json`, some `tsconfig.json` / `next.config.*` configuration, `.env.local`, and the `moose/` directory itself. */}

---

## Project structure

<FileTree>
  <FileTree.Folder name="your-nextjs-app" defaultOpen>
    <FileTree.Folder name="app" defaultOpen>
        <FileTree.File name="page.tsx" />
    </FileTree.Folder>
    <FileTree.Folder name="moose" defaultOpen>
      <FileTree.File name="index.ts" />
      <FileTree.File name="client.ts" />
      <FileTree.Folder name="queries" defaultOpen>
        <FileTree.File name="overview-metrics.ts" />
      </FileTree.Folder>
    </FileTree.Folder>
    <FileTree.Folder name="dist">
      <FileTree.File name="(auto-generated by build:moose)" />
    </FileTree.Folder>
    <FileTree.File name="moose.config.toml" />
    <FileTree.File name="tsconfig.moose.json" />
    <FileTree.File name=".env.local" />
    <FileTree.File name=".gitignore" />
    <FileTree.File name="package.json" />
    <FileTree.File name="tsconfig.json" />
    <FileTree.File name="next.config.ts" />
  </FileTree.Folder>
</FileTree>

---

## Prerequisites

<BulletPointsCard
  title="Before you start"
  bulletStyle="check"
  compact={true}
  divider={false}
  bullets={[
    {
      title: "Node.js 20+",
      description: "Required for native module compatibility",
      link: { text: "Download →", href: "https://nodejs.org/en/download", external: true },
    },
    {
      title: "Docker Desktop",
      description: "MooseStack uses Docker to run ClickHouse locally",
      link: {
        text: "Download →",
        href: "https://docs.docker.com/get-started/get-docker/",
        external: true,
      },
    },
    {
      title: "Existing Next.js 13+ app",
      description: "Using the App Router",
    },
    {
      title: "pnpm (or npm/yarn)",
      description: "Package manager",
    },
  ]}
/>

---

## Get Started

This section gets MooseStack running inside your existing Next.js project. You’ll install dependencies, configure TypeScript + Next.js, and create the Moose config needed to run `moose dev` locally.

### Install dependencies + add scripts

Add MooseStack and its build tools:

```bash title="Terminal" copy
pnpm add @514labs/moose-lib ts-patch tsconfig-paths typia
pnpm add -D @514labs/moose-cli@latest @types/node
```

Add these scripts to your `package.json`:

```json title="package.json"
{
  "scripts": {
    "build:moose:types": "tspc -p tsconfig.moose.json --declaration --emitDeclarationOnly",
    "build:moose": "pnpm build:moose:types && tspc -p tsconfig.moose.json",

    "dev:next": "next dev",
    "dev:moose": "moose-cli dev",

    "moose": "moose-cli",

    "build": "pnpm build:moose && next build"
  },

  "pnpm": {
    "onlyBuiltDependencies": [
      "@confluentinc/kafka-javascript",
      "@514labs/kafka-javascript"
    ]
  }
}
```

<Callout type="warning" title="Why tspc instead of tsc?">
MooseStack uses compiler plugins to inject schemas into your models at build time. The `ts-patch` package provides `tspc`, which supports these plugins.
</Callout>

### Configure TypeScript (import compiled Moose output)

Moose code must be imported from the compiled `dist/` output.

#### Update `tsconfig.json`

Add a `ts-node` block at the top level (if not already present):

```json title="tsconfig.json"
{
  "ts-node": {
    "compilerOptions": {
      "module": "commonjs",
      "moduleResolution": "node"
    }
  }
}
```

Add these path mappings (both are required):

```json title="tsconfig.json"
{
  "compilerOptions": {
    "paths": {
      "@/*": ["./*"],
      "@/moose": ["./dist/index"],
      "@/moose/*": ["./dist/*"]
    }
  }
}
```

Exclude `moose` and `dist` directories from Next’s TypeScript compilation (Next will import the pre-compiled output from `dist/`):

```json title="tsconfig.json"
{
  "exclude": ["node_modules", "dist", "moose"]
}
```

<Callout type="info" title="Why the @/moose alias matters">
Always import from `@/moose` (or `@/moose/*`) so Next.js uses the compiled output in `dist/` with injected schemas.
</Callout>


Create `tsconfig.moose.json` in your project root:

```json title="tsconfig.moose.json"
{
  "compilerOptions": {
    "outDir": "dist",
    "noEmit": false,
    "declaration": true,
    "declarationMap": true,
    "module": "commonjs",
    "moduleResolution": "node",
    "isolatedModules": false,
    "strictNullChecks": true,
    "esModuleInterop": true,
    "plugins": [
      { "transform": "typia/lib/transform" },
      {
        "transform": "./node_modules/@514labs/moose-lib/dist/compilerPlugin.js",
        "transformProgram": true
      }
    ]
  },
  "include": ["moose/**/*"],
  "exclude": ["node_modules", "dist"]
}
```

#### Configure Next.js (server bundling)

Update `next.config.ts` to avoid bundling server-only dependencies:

```typescript title="next.config.ts"
const nextConfig = {
  serverExternalPackages: [
    "@confluentinc/kafka-javascript",
    "@514labs/moose-lib"
  ]
};

export default nextConfig;
```

#### Create Moose config + environment variables

Create `moose.config.toml` in your project root:

```toml title="moose.config.toml"
language = "Typescript"
source_dir = "moose"

[clickhouse_config]
db_name = "local"
user = "panda"
password = "pandapass"
use_ssl = false
host = "localhost"
host_port = 18123
native_port = 9000

[http_server_config]
host = "localhost"
port = 4000
management_port = 5001

# Key dev workflow: rebuild dist/ after moose reloads
on_reload_complete_script = "pnpm build:moose"

[features]
streaming_engine = false
data_model_v2 = true
```
Create or update ` .env.local` with your ClickHouse connection details:

```bash title=".env.local"
# Required: Run Moose in client-only mode
MOOSE_CLIENT_ONLY=true

# ClickHouse connection (matches moose.config.toml)
MOOSE_CLICKHOUSE_CONFIG__DB_NAME=local
MOOSE_CLICKHOUSE_CONFIG__HOST=localhost
MOOSE_CLICKHOUSE_CONFIG__PORT=18123
MOOSE_CLICKHOUSE_CONFIG__USER=panda
MOOSE_CLICKHOUSE_CONFIG__PASSWORD=pandapass
MOOSE_CLICKHOUSE_CONFIG__USE_SSL=false
```

Update `.gitignore` to exclude MooseStack generated files:

```text title=".gitignore"
# MooseStack generated files
/dist
.moose/
.ts-node/
```

---

## Model table

In this step you’ll define your first ClickHouse model as an `OlapTable` object. MooseStack uses these models as the source of truth for schema management. Create `moose/models/events.ts` with the following content:

```ts title="moose/models/events.ts"
import { OlapTable } from "@514labs/moose-lib";

export interface EventModel {
  transaction_id: string;
  event_type: string;
  product_id: number;
  customer_id: string;
  amount: number;
  quantity: number;
  event_time: Date;
  customer_email: string;
  customer_name: string;
  product_name: string;
  status: string; // e.g. 'completed', 'active', 'inactive'
}

export const Events = new OlapTable<EventModel>("events", {
  orderByFields: ["event_time"]
});
```

---

## Start local ClickHouse

Now start the Moose Runtime in `dev` mode. This instantly brings up a local ClickHouse instance (via Docker) and automatically instantiates your models against it, giving you a fast feedback loop for iterating on your schema.

Leave this running in its own terminal for the rest of the guide:

```bash title="Terminal" copy
pnpm dev:moose
```

As you update models and query helpers in `moose/`, Moose will apply schema changes to this instance and (based on your `moose.config.toml`) rebuild `dist/` after reload so Next.js can import the compiled output via `@/moose`.

---

<span id="write-queries" />

## Write queries

This step is crucial to facilitate the interaction between your Next.js app and Clickhouse.

With the local ClickHouse instance running, you’ll instantiate the Moose ClickHouse client to connect to it. This is a singleton that will be used to connect to the ClickHouse instance for the duration of the application's lifecycle. You'll then leverage this client to write type-safe query helpers that use your `OlapTable` objects. 

#### Create a ClickHouse client helper

Create `moose/client.ts`:

```ts title="moose/client.ts"
import { getMooseClients, Sql } from "@514labs/moose-lib";

let clientsPromise:
  | Promise<Awaited<ReturnType<typeof getMooseClients>>>
  | undefined;

async function getMoose() {
  clientsPromise ??= getMooseClients({
    host: process.env.MOOSE_CLICKHOUSE_CONFIG__HOST ?? "localhost",
    port: process.env.MOOSE_CLICKHOUSE_CONFIG__PORT ?? "18123",
    username: process.env.MOOSE_CLICKHOUSE_CONFIG__USER ?? "panda",
    password: process.env.MOOSE_CLICKHOUSE_CONFIG__PASSWORD ?? "pandapass",
    database: process.env.MOOSE_CLICKHOUSE_CONFIG__DB_NAME ?? "local",
    useSSL:
      (process.env.MOOSE_CLICKHOUSE_CONFIG__USE_SSL ?? "false") === "true",
  });

  return await clientsPromise;
}

export async function executeQuery<T>(query: Sql): Promise<T[]> {
  const { client } = await getMoose();
  const result = await client.query.execute(query);
  return result.json();
}
```

#### Create a query helper

Create a file called `moose/queries/overview-metrics.ts` with the following content:

```ts title="moose/queries/overview-metrics.ts"
import { sql } from "@514labs/moose-lib";
import { Events } from "../models/events";
import { executeQuery } from "../client";

export interface DateRange {
  start: Date;
  end: Date;
}

export const getOverviewMetrics = async (dateRange?: DateRange) => {
  const startDate = dateRange?.start.toISOString().split("T")[0];
  const endDate = dateRange?.end.toISOString().split("T")[0];

  interface SalesRow {
    total_revenue: number;
    total_sales: number;
  }

  const dateFilter =
    dateRange ?
      sql`AND event_time >= toDate(${startDate!}) AND event_time <= toDate(${endDate!})`
    : sql``;

  const sales = await executeQuery<SalesRow>(
    sql`
      SELECT
        sum(amount) as total_revenue,
        count(*) as total_sales
      FROM ${Events}
      WHERE event_type = 'purchase' ${dateFilter}
    `,
  );

  const activeUsers = await executeQuery<{
    active_users: number;
  }>(sql`
    SELECT uniq(customer_id) as active_users
    FROM ${Events}
    WHERE event_time > now() - interval 1 hour
  `);

  return {
    totalRevenue: sales?.[0]?.total_revenue ?? 0,
    totalSales: sales?.[0]?.total_sales ?? 0,
    activeNow: activeUsers?.[0]?.active_users ?? 0,
  };
};
```

#### Export from `moose/index.ts`

Create `moose/index.ts` to re-export your models and queries:

```ts title="moose/index.ts"
export * from "./models/events";
export * from "./queries/overview-metrics";
```

---

## Use in Next Page

Keep `pnpm dev:moose` running. In a second terminal, start your Next.js app:

```bash title="Terminal" copy
pnpm dev:next
```

Now import and call your Moose query helper from a **Server Component** in your Next.js app:

```typescript title="app/analytics/page.tsx"
import { getOverviewMetrics } from "@/moose";

export default async function AnalyticsPage() {
  const { totalRevenue, totalSales, activeNow } = await getOverviewMetrics();

  return (
    <div>
      <h1>Analytics</h1>
      <div>
        <p>Total Revenue: {totalRevenue}</p>
        <p>Total Sales: {totalSales}</p>
        <p>Active Users (last hour): {activeNow}</p>
      </div>
    </div>
  );
}
```

<Callout type="warning" title="Server-only: keep ClickHouse access on the server">
Do not call ClickHouse from the browser. Use Server Components, Route Handlers, or Server Actions so credentials remain server-side.
</Callout>

**Success checklist:**

- `pnpm build:moose` creates `dist/index.js` (and types)
- Next can resolve `@/moose`
- Your `/analytics` page renders without runtime errors

---

## Deploy to Production

In this setup, your Next.js app connects directly to ClickHouse—there’s no separate production Moose Runtime to deploy. You just need to:

1. Apply your schema to production ClickHouse
2. Configure your Next.js production environment with production credentials

#### Enable planned migrations

Add `ddl_plan = true` to `[features]` in `moose.config.toml`:

```toml title="moose.config.toml"
[features]
streaming_engine = false
data_model_v2 = true
ddl_plan = true
```

#### Generate a migration plan

```bash title="Terminal" copy
pnpm moose generate migration \
  --clickhouse-url "clickhouse://user:password@your-prod-host:8443/db?secure=true" \
  --save
```

This creates files in `migrations/` including `plan.yaml`.

#### Apply the migration

```bash title="Terminal" copy
pnpm moose migrate \
  --clickhouse-url "clickhouse://user:password@your-prod-host:8443/db?secure=true"
```

#### Configure production environment

Set these in your deployment platform (Vercel, Railway, etc.):

```bash title="Production Environment Variables"
MOOSE_CLIENT_ONLY=true
MOOSE_CLICKHOUSE_CONFIG__DB_NAME=production_db
MOOSE_CLICKHOUSE_CONFIG__HOST=your-clickhouse-host.example.com
MOOSE_CLICKHOUSE_CONFIG__PORT=8443
MOOSE_CLICKHOUSE_CONFIG__USER=prod_user
MOOSE_CLICKHOUSE_CONFIG__PASSWORD=prod_password
MOOSE_CLICKHOUSE_CONFIG__USE_SSL=true
```

---

## Troubleshooting

**"Module not found: Can't resolve '@/moose/..."**
- Run `pnpm build:moose` to generate `dist/`
- Verify `tsconfig.json` has both `"@/moose": ["./dist/index"]` and `"@/moose/*": ["./dist/*"]`

**"Supply the type param T so that the schema is inserted..."**
- Check imports use `@/moose/*`, not `moose/*`
- Ensure `ts-patch` is installed and `tspc` is used in build scripts

**"ERR_UNSUPPORTED_DIR_IMPORT"**
- Add the `ts-node` block to `tsconfig.json` (see Configure TypeScript above)

**Native module errors (NODE_MODULE_VERSION)**
- Ensure Node.js v20, delete `node_modules`, run `pnpm install`

---

## Next steps

- [OlapTable Reference](/moosestack/olap/model-table) — Primary keys, engines, and configuration
- [Read Data](/moosestack/olap/read-data) — Query patterns and the Moose client
- [Migrations](/moosestack/migrate) — Schema versioning and migration strategies
- [Schema Optimization](/moosestack/olap/schema-optimization) — Ordering keys and partitioning
