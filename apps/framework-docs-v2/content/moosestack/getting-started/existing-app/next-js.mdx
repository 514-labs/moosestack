---
title: Embed ClickHouse analytics in Next.js
description: Add MooseStack to an existing Next.js app with a sibling `moose/` workspace package for ClickHouse schema + queries (no separate Moose production service).
---

import { Callout, FileTree, BulletPointsCard } from "@/components/mdx";

# Embed ClickHouse analytics in your Next.js app

## Overview

This quickstart shows how to embed MooseStack into an existing Next.js (App Router) app so you can define ClickHouse schema in TypeScript and serve type-safe analytics from Server Components and Server Actions—while keeping Next.js as your only deployed backend.

From this you will be able to:
- Model ClickHouse schema in TypeScript, alongside your Next.js code
- Integrate type-safe ClickHouse queries into your Server Components and Server Actions
- Generate/apply migrations against production ClickHouse when you're ready to deploy

<Callout type="info" title="What runs in production?">
Only your Next.js app runs in production. MooseStack is used as a library + CLI to manage schema/migrations and to generate an importable package (`moose/dist`) that your Next.js runtime uses to query ClickHouse.
</Callout>

### Guide outline

- **[Get started](#get-started):** add `moose/` as a sibling workspace and configure dependencies + env vars.
- **[Model table](#model-table):** define a table model (for example, `Events`) in `moose/src/index.ts`.
- **[Start local ClickHouse](#start-local-clickhouse):** run `pnpm dev:moose`.
- **[Use in Next.js](#use-in-nextjs):** define a client + query helper in `moose/`, then call it from a Server Component or Server Action.
- **[Deploy to production](#deploy-to-production):** generate/apply migrations and set production env vars.

---

## Project structure

This guide's examples mirror our reference project at `examples/nextjs-moose`:

- The Next.js app is at the repo root (`./`)
- A sibling `moose/` workspace package that contains your ClickHouse models and query helpers

If you're applying this to an existing repo with a different layout, keep the **package name** `moose` the same and adjust only the paths/commands.

<FileTree>
  <FileTree.Folder name="nextjs-moose" defaultOpen>
    <FileTree.File name="pnpm-workspace.yaml" />
    <FileTree.File name="package.json" />
    <FileTree.File name="tsconfig.json" />
    <FileTree.File name="next.config.ts" />
    <FileTree.File name=".env.local (optional)" />
    <FileTree.Folder name="app" defaultOpen>
      <FileTree.File name="page.tsx" />
      <FileTree.Folder name="actions" defaultOpen>
        <FileTree.File name="metrics.ts" />
      </FileTree.Folder>
    </FileTree.Folder>
    <FileTree.Folder name="moose" defaultOpen>
      <FileTree.File name="moose.config.toml" />
      <FileTree.File name="package.json" />
      <FileTree.File name="tsconfig.json" />
      <FileTree.Folder name="src" defaultOpen>
        <FileTree.File name="client.ts" />
        <FileTree.File name="index.ts" />
        <FileTree.File name="models.ts" />
        <FileTree.File name="queries.ts" />
      </FileTree.Folder>
      <FileTree.Folder name="dist">
        <FileTree.File name="(auto-generated by build)" />
      </FileTree.Folder>
    </FileTree.Folder>
    <FileTree.File name=".gitignore" />
  </FileTree.Folder>
</FileTree>

---

## Prerequisites

<BulletPointsCard
  title="Before you start"
  bulletStyle="check"
  compact={true}
  divider={false}
  bullets={[
    {
      title: "Node.js 20+",
      description: "Required for native module compatibility",
      link: { text: "Download →", href: "https://nodejs.org/en/download", external: true },
    },
    {
      title: "Docker Desktop",
      description: "MooseStack uses Docker to run ClickHouse locally",
      link: {
        text: "Download →",
        href: "https://docs.docker.com/get-started/get-docker/",
        external: true,
      },
    },
    {
      title: "Existing Next.js 13+ app",
      description: "Using the App Router",
    },
    {
      title: "pnpm",
      description: "Package manager (workspaces)",
    },
  ]}
/>

---

## Get started

This section adds a **`moose/` workspace package** next to your Next.js app and configures it for local development.

### Confirm your workspace setup (pnpm)

This guide assumes you're using **pnpm workspaces**. Your Next.js app package will depend on your local `moose` workspace package.

In the Next.js example, `pnpm-workspace.yaml` lives at the repo root and includes **two packages**: the Next.js app (`.`) and the Moose package (`moose`).

```yaml title="pnpm-workspace.yaml (nextjs-moose)"
packages:
  - "."
  - "moose"
```

<Callout type="info" title="Fast path: copy the `moose/` package from our example">
If you want the quickest setup, you can pull the `moose/` workspace package from our Next.js example and drop it next to your Next.js app (as `./moose`):

```bash title="Terminal" copy
pnpm dlx tiged 514-labs/moosestack/examples/nextjs-moose/moose moose
```

Then install dependencies and build the `moose` package:

```bash title="Terminal" copy
pnpm install
pnpm -C moose run build
```

</Callout>

#### Add your moose workspace as a dependency

Add `moose` as a workspace dependency in your **Next.js app workspace** `package.json`:

```json title="(your Next.js app workspace)/package.json"
{
  "dependencies": {
    "moose": "workspace:*"
  }
}
```

#### Configure repo root package.json

<Callout type="warning" title="Ensure workspace root">
If your Next.js app is not at the repo root, add these configurations to your **repo root** `package.json` (not your Next.js app's `package.json`).
</Callout>

Add the required `pnpm.onlyBuiltDependencies` configuration to your **repo root** `package.json`. Optionally, you can also add convenience scripts to run Moose commands from the repo root:

```json title="package.json (repo root)"
{
  "pnpm": {
    "onlyBuiltDependencies": [
      "@confluentinc/kafka-javascript",
      "@514labs/kafka-javascript"
    ]
  },
  "scripts": {
    "dev:moose": "pnpm -C moose run dev",
    "build:moose": "pnpm -C moose run build",
    "moose": "pnpm -C moose run moose"
  }
}
```

### Configure Next.js (server bundling)

Update `next.config.ts` to avoid bundling server-only dependencies:

```typescript title="next.config.ts"
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  serverExternalPackages: [
    "@514labs/moose-lib",
    "@confluentinc/kafka-javascript",
    "@514labs/kafka-javascript",
  ],
};

export default nextConfig;
```

### Configure environment variables (Next.js runtime)

This step is **required**: the `moose` package initializes its ClickHouse client from environment variables, so these values must be present when your Next.js server starts.

Create or update your Next.js app's `.env.local` file with the following ClickHouse connection details for your local development environment:

```bash title=".env.local" copy
MOOSE_CLIENT_ONLY=true

MOOSE_CLICKHOUSE_CONFIG__DB_NAME=local
MOOSE_CLICKHOUSE_CONFIG__HOST=localhost
MOOSE_CLICKHOUSE_CONFIG__PORT=18123
MOOSE_CLICKHOUSE_CONFIG__USER=panda
MOOSE_CLICKHOUSE_CONFIG__PASSWORD=pandapass
MOOSE_CLICKHOUSE_CONFIG__USE_SSL=false
```

<Callout type="info" title="Configuring environment variables in Next.js">
Next.js automatically loads environment variables from `.env.local` (and other `.env*` files) at runtime. These variables are available in `process.env` when your Server Components and Server Actions execute.
</Callout>

Update your `.gitignore` to exclude MooseStack generated files:

```text title=".gitignore"
# MooseStack generated files
# ignore your moose workspace build output
/moose/dist
.moose/
.ts-node/
```

---

## Model table

In this step you'll define your first ClickHouse model as an `OlapTable` object.

The starter `moose` package you copied into your repo already includes an example model at `moose/src/models.ts`:

```ts title="moose/src/models.ts"
import { OlapTable } from "@514labs/moose-lib";

export interface EventModel {
  id: string;
  amount: number;
  event_time: Date;
  status: 'completed' | 'active' | 'inactive';
}

export const Events = new OlapTable<EventModel>("events", {
  orderByFields: ["event_time"],
});
```

<Callout type="info" title="Adding more tables">
Add more tables by exporting additional `OlapTable` objects from `moose/src/models.ts` (or create separate model files and re-export them). See [OlapTable Reference](/moosestack/olap/model-table).
</Callout>

---

## Start local ClickHouse

Start the Moose Runtime in `dev` mode. This brings up a local ClickHouse instance (via Docker) and hot-reloads schema changes to it whenever you edit your models.

Leave this running in its own terminal for the rest of the guide:

```bash title="Terminal" copy
# run this from your repo root
pnpm dev:moose
```

The provided `moose` workspace is configured to automatically rebuild the package for use inside your Next.js app whenever you make changes to your models.

```toml title="moose/moose.config.toml"
[http_server_config]
on_reload_complete_script = "pnpm build"
```

See [Dev Environment Configuration](/moosestack/configuration/dev-environment) for more details.

---

## Use in Next.js

#### 1) Set up a shared ClickHouse client in `moose/`

First, create a shared ClickHouse client initializer inside your `moose` package. This keeps connection logic in one place and lets Next.js Server Components/Actions call simple query helpers.

```ts title="moose/src/client.ts"
import { getMooseClients, Sql, QueryClient } from "@514labs/moose-lib";

async function getClickhouseClient(): Promise<QueryClient> {
  const { client } = await getMooseClients({
    host: process.env.MOOSE_CLICKHOUSE_CONFIG__HOST ?? "localhost",
    port: process.env.MOOSE_CLICKHOUSE_CONFIG__PORT ?? "18123",
    username: process.env.MOOSE_CLICKHOUSE_CONFIG__USER ?? "panda",
    password: process.env.MOOSE_CLICKHOUSE_CONFIG__PASSWORD ?? "pandapass",
    database: process.env.MOOSE_CLICKHOUSE_CONFIG__DB_NAME ?? "local",
    useSSL: (process.env.MOOSE_CLICKHOUSE_CONFIG__USE_SSL ?? "false") === "true",
  });

  return client.query;
}

export async function executeQuery<T>(query: Sql): Promise<T[]> {
  const queryClient = await getClickhouseClient();
  const result = await queryClient.execute(query);
  return result.json();
}
```

#### 2) Define a query helper in `moose/src/queries.ts`

Next, define a query helper that uses the shared client and export it from `"moose"`. The example defines a very basic query for you to use as a starting point:

```ts title="moose/src/queries.ts"
import { sql } from "@514labs/moose-lib";
import { Events, EventModel } from "./models";
import { executeQuery } from "./client";

export async function getEvents(limit: number = 10): Promise<EventModel[]> {
  return await executeQuery<EventModel>(
    sql`SELECT * FROM ${Events} ORDER BY ${Events.columns.event_time} DESC LIMIT ${limit}`,
  );
}
```

#### 3) Export from `moose/src/index.ts`

Make sure your `moose` package exports the models and queries:

```ts title="moose/src/index.ts"
export * from "./models";
export * from "./queries";
```

#### 4) Import and use the helper in Next.js

Now your Next.js app can import and use the helper from `"moose"` in any Server Component or Server Action, like this:

**Server Component example:**

```ts title="app/analytics/page.tsx"
import { getEvents } from "moose";

export default async function AnalyticsPage() {
  const events = await getEvents(10);

  return (
    <div>
      <h1>Recent Events</h1>
      <ul>
        {events.map((event) => (
          <li key={event.id}>
            {event.id}: {event.amount} ({event.status})
          </li>
        ))}
      </ul>
    </div>
  );
}
```

**Server Action example:**

```ts title="app/actions/metrics.ts"
"use server";

import { getEvents } from "moose";

export async function getRecentEvents(limit: number = 10) {
  return await getEvents(limit);
}
```

<Callout type="warning" title="Server-only: keep ClickHouse access on the server">
Do not call ClickHouse from the browser. Use Server Components, Route Handlers, or Server Actions so credentials remain server-side.
</Callout>

---

## Deploy to production

There's no separate production Moose Runtime to deploy. You just need to:

1. Apply your schema to production ClickHouse
2. Configure your production environment with production credentials

#### Enable planned migrations

Make sure `ddl_plan = true` is set in `[features]` in `moose/moose.config.toml`:

```toml title="moose/moose.config.toml"
[features]
streaming_engine = false
data_model_v2 = true
ddl_plan = true
```

#### Generate a migration plan

<Callout type="warning" title="Important: Use production credentials">
This command connects to the ClickHouse instance you specify in `--clickhouse-url` and generates a migration plan *for that database*. Use your **production** ClickHouse URL + credentials if you intend to deploy these schema changes to production.
</Callout>

```bash title="Terminal" copy
pnpm moose generate migration \
  --clickhouse-url "clickhouse://user:password@your-prod-host:8443/db?secure=true" \
  --save
```

This creates files in `migrations/` including `plan.yaml`.

#### Apply the migration

```bash title="Terminal" copy
pnpm moose migrate \
  --clickhouse-url "clickhouse://user:password@your-prod-host:8443/db?secure=true"
```

#### Configure production environment

In production, set these environment variables in your deployment platform (Vercel, Railway, etc.). Make sure to use your **production** ClickHouse URL + credentials.

```bash title="Production Environment Variables"
MOOSE_CLIENT_ONLY=true
MOOSE_CLICKHOUSE_CONFIG__DB_NAME=production_db
MOOSE_CLICKHOUSE_CONFIG__HOST=your-clickhouse-host.example.com
MOOSE_CLICKHOUSE_CONFIG__PORT=8443
MOOSE_CLICKHOUSE_CONFIG__USER=prod_user
MOOSE_CLICKHOUSE_CONFIG__PASSWORD=prod_password
MOOSE_CLICKHOUSE_CONFIG__USE_SSL=true
```

---

## Troubleshooting

If you see import errors for `import ... from "moose"`, confirm:

- Your root `pnpm-workspace.yaml` includes both your Next.js app and the `moose` workspace
- You ran `pnpm install` so `workspace:*` links are created
- You ran `pnpm -C moose run build` (or your equivalent script) to generate `moose/dist/`

**Native module errors (NODE_MODULE_VERSION)**
- Ensure Node.js v20+, delete `node_modules`, run `pnpm install`

---

## Next steps

- [OlapTable Reference](/moosestack/olap/model-table) — Primary keys, engines, and configuration
- [Read Data](/moosestack/olap/read-data) — Query patterns and the Moose client
- [Migrations](/moosestack/migrate) — Schema versioning and migration strategies
- [Schema Optimization](/moosestack/olap/schema-optimization) — Ordering keys and partitioning
