---
title: Embed ClickHouse analytics in Next.js
description: Add MooseStack to an existing Next.js app to model, migrate, and query ClickHouse from Server Components (no separate backend service).
---

import { Callout, FileTree, BulletPointsCard } from "@/components/mdx";

# Embed ClickHouse analytics in your Next.js app

This guide shows how to **embed ClickHouse-powered analytics** inside an existing Next.js (App Router) app using MooseStack.

You’ll run **`moose dev` alongside `next dev`**, define ClickHouse tables and query helpers in a `moose/` workspace, and import them into your **Server Components / Route Handlers**.

<Callout type="info" title="The core pattern">
- Write models + queries in `moose/**`
- Compile them to `dist/**` (Moose uses a TypeScript compiler plugin to inject schemas)
- Import from `@/moose` (which points at `dist/`), not from `moose/`
</Callout>

**By the end you will have:**

- **Local dev working**: `moose dev` (local ClickHouse + schema apply + rebuild `dist/`) running alongside `next dev`
- **A `moose/` workspace**: tables + query helpers you can import from `@/moose`
- **A working analytics page**: a Server Component that queries ClickHouse safely and type-sensibly

**Best for:** developers with an existing Next.js app who want to **embed schema management + type-safe ClickHouse queries** without deploying a separate backend service.

---

## Project structure

<FileTree>
  <FileTree.Folder name="your-nextjs-app" defaultOpen>
    <FileTree.Folder name="moose" defaultOpen>
      <FileTree.File name="index.ts" />
      <FileTree.File name="client.ts" />
      <FileTree.Folder name="models" defaultOpen>
        <FileTree.File name="events.ts" />
      </FileTree.Folder>
      <FileTree.Folder name="queries" defaultOpen>
        <FileTree.File name="overview-metrics.ts" />
      </FileTree.Folder>
    </FileTree.Folder>
    <FileTree.Folder name="dist">
      <FileTree.File name="(auto-generated by build:moose)" />
    </FileTree.Folder>
    <FileTree.File name="moose.config.toml" />
    <FileTree.File name="tsconfig.moose.json" />
    <FileTree.File name=".env.local" />
  </FileTree.Folder>
</FileTree>

---

## Prerequisites

<BulletPointsCard
  title="Before you start"
  bulletStyle="check"
  compact={true}
  divider={false}
  bullets={[
    {
      title: "Node.js 20+",
      description: "Required for native module compatibility",
      link: { text: "Download →", href: "https://nodejs.org/en/download", external: true },
    },
    {
      title: "Docker Desktop",
      description: "MooseStack uses Docker to run ClickHouse locally",
      link: {
        text: "Download →",
        href: "https://docs.docker.com/get-started/get-docker/",
        external: true,
      },
    },
    {
      title: "Existing Next.js 13+ app",
      description: "Using the App Router",
    },
    {
      title: "pnpm (or npm/yarn)",
      description: "Package manager",
    },
  ]}
/>

---

## 1) Installation & setup

This section gets MooseStack running inside your existing Next.js project. You’ll install dependencies, configure TypeScript + Next.js, and create the Moose config needed to run `moose dev` locally.

### 1.1 Install dependencies + add scripts

Add MooseStack and its build tools:

```bash title="Terminal" copy
pnpm add @514labs/moose-lib ts-patch tsconfig-paths typia
pnpm add -D @514labs/moose-cli @types/node
```

Add these scripts to your `package.json`:

```json title="package.json"
{
  "scripts": {
    "build:moose:types": "tspc -p tsconfig.moose.json --declaration --emitDeclarationOnly",
    "build:moose": "pnpm build:moose:types && tspc -p tsconfig.moose.json",

    "dev:next": "next dev",
    "dev:moose": "moose-cli dev",

    "moose": "moose-cli",

    "build": "pnpm build:moose && next build"
  },

  "pnpm": {
    "onlyBuiltDependencies": [
      "@confluentinc/kafka-javascript",
      "@514labs/kafka-javascript"
    ]
  }
}
```

<Callout type="warning" title="Why tspc instead of tsc?">
MooseStack uses compiler plugins to inject schemas into your models at build time. The `ts-patch` package provides `tspc`, which supports these plugins.
</Callout>

### 1.2 Configure TypeScript (import compiled Moose output)

Moose code must be imported from the compiled `dist/` output.

#### Update `tsconfig.json`

Add a `ts-node` block at the top level (if not already present):

```json title="tsconfig.json"
{
  "ts-node": {
    "compilerOptions": {
      "module": "commonjs",
      "moduleResolution": "node"
    }
  }
}
```

Add these path mappings (both are required):

```json title="tsconfig.json"
{
  "compilerOptions": {
    "paths": {
      "@/*": ["./*"],
      "@/moose": ["./dist/index"],
      "@/moose/*": ["./dist/*"]
    }
  }
}
```

Exclude `moose` and `dist` directories from Next’s TypeScript compilation (Next will import the pre-compiled output from `dist/`):

```json title="tsconfig.json"
{
  "exclude": ["node_modules", "dist", "moose"]
}
```

<Callout type="info" title="Why the @/moose alias matters">
Always import from `@/moose` (or `@/moose/*`) so Next.js uses the compiled output in `dist/` with injected schemas.
</Callout>


Create `tsconfig.moose.json` in your project root:

```json title="tsconfig.moose.json"
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "outDir": "dist",
    "noEmit": false,
    "declaration": true,
    "declarationMap": true,
    "module": "commonjs",
    "moduleResolution": "node",
    "isolatedModules": false,
    "strictNullChecks": true,
    "plugins": [
      { "transform": "typia/lib/transform" },
      {
        "transform": "./node_modules/@514labs/moose-lib/dist/compilerPlugin.js",
        "transformProgram": true
      }
    ]
  },
  "include": ["moose/**/*"],
  "exclude": ["node_modules", "dist"]
}
```

### 1.3 Configure Next.js (server bundling)

Update `next.config.ts` to avoid bundling server-only dependencies:

```typescript title="next.config.ts"
const nextConfig = {
  serverExternalPackages: [
    "@confluentinc/kafka-javascript",
    "@514labs/moose-lib"
  ]
};

export default nextConfig;
```

### 1.4 Create Moose config + environment variables

Create `moose.config.toml` in your project root:

```toml title="moose.config.toml"
language = "Typescript"
source_dir = "moose"

[clickhouse_config]
db_name = "local"
user = "panda"
password = "pandapass"
use_ssl = false
host = "localhost"
host_port = 18123
native_port = 9000

[http_server_config]
host = "localhost"
port = 4000
management_port = 5001

# Key dev workflow: rebuild dist/ after moose reloads
on_reload_complete_script = "pnpm build:moose"

[features]
streaming_engine = false
data_model_v2 = true
```
Create or update ` .env.local` with your ClickHouse connection details:

```bash title=".env.local"
# Required: Run Moose in client-only mode
MOOSE_CLIENT_ONLY=true

# ClickHouse connection (matches moose.config.toml)
MOOSE_CLICKHOUSE_CONFIG__DB_NAME=local
MOOSE_CLICKHOUSE_CONFIG__HOST=localhost
MOOSE_CLICKHOUSE_CONFIG__PORT=18123
MOOSE_CLICKHOUSE_CONFIG__USER=panda
MOOSE_CLICKHOUSE_CONFIG__PASSWORD=pandapass
MOOSE_CLICKHOUSE_CONFIG__USE_SSL=false
```

Update `.gitignore` to exclude MooseStack generated files:

```text title=".gitignore"
# MooseStack generated files
/dist
.moose/
.ts-node/
```

---

## 2) Create your `moose/` workspace (models + queries)

In this step you’ll add:
- an OLAP table model
- a ClickHouse client helper
- a reusable query function

### Define a model

```typescript title="moose/models/events.ts"
import { OlapTable } from "@514labs/moose-lib";

export interface EventModel {
  transaction_id: string;
  event_type: string;
  product_id: number;
  customer_id: string;
  amount: number;
  quantity: number;
  event_time: Date;
  customer_email: string;
  customer_name: string;
  product_name: string;
  status: string; // e.g. 'completed', 'active', 'inactive'
}

export const Events = new OlapTable<EventModel>("events", {
  orderByFields: ["event_time"]
});
```

### Create a ClickHouse client helper

Create `moose/client.ts`:

```ts title="moose/client.ts"
import { getMooseClients } from "@514labs/moose-lib";

const globalForMoose = globalThis as unknown as {
  mooseClient: Awaited<ReturnType<typeof getMooseClients>> | undefined;
};

export async function getMoose() {
  if (globalForMoose.mooseClient) {
    return globalForMoose.mooseClient;
  }

  const client = await getMooseClients({
    database: process.env.MOOSE_CLICKHOUSE_CONFIG__DB_NAME!,
    host: process.env.MOOSE_CLICKHOUSE_CONFIG__HOST!,
    port: process.env.MOOSE_CLICKHOUSE_CONFIG__PORT!,
    username: process.env.MOOSE_CLICKHOUSE_CONFIG__USER!,
    password: process.env.MOOSE_CLICKHOUSE_CONFIG__PASSWORD!,
    useSSL: process.env.MOOSE_CLICKHOUSE_CONFIG__USE_SSL === "true"
  });

  if (process.env.NODE_ENV !== "production") {
    globalForMoose.mooseClient = client;
  }

  return client;
}
```

### Create a query helper

```typescript title="moose/queries/overview-metrics.ts"
import { sql } from "@514labs/moose-lib";
import { Events } from "../models/events";
import { getMoose } from "../client";

export interface DateRange {
  start: Date;
  end: Date;
}

export const getOverviewMetrics = async (dateRange?: DateRange) => {
  const moose = await getMoose();

  const startDate = dateRange?.start.toISOString().split("T")[0];
  const endDate = dateRange?.end.toISOString().split("T")[0];

  const dateFilter = dateRange
    ? sql`AND event_time >= toDate(${startDate!}) AND event_time <= toDate(${endDate!})`
    : sql``;

  const salesData = await moose.client.query.execute(
    sql`
      SELECT
        sum(amount) as total_revenue,
        count(*) as total_sales
      FROM ${Events}
      WHERE event_type = 'purchase' ${dateFilter}
    `
  );

  const [salesRow] = await salesData.json<{
    total_revenue?: number;
    total_sales?: number;
  }>();

  const activeUsersData = await moose.client.query.execute(
    sql`
      SELECT uniq(customer_id) as active_users
      FROM ${Events}
      WHERE event_time > now() - interval 1 hour
    `
  );

  const [activeUsersRow] = await activeUsersData.json<{
    active_users?: number;
  }>();

  return {
    totalRevenue: salesRow?.total_revenue ?? 0,
    totalSales: salesRow?.total_sales ?? 0,
    activeNow: activeUsersRow?.active_users ?? 0
  };
};
```

### Export from `moose/index.ts`

```ts title="moose/index.ts"
export * from "./models/events";
export * from "./queries/overview-metrics";
```

---

## 3) Query ClickHouse from Next.js

Import and call your Moose query helper from a **Server Component**:

```typescript title="app/analytics/page.tsx"
import { getOverviewMetrics } from "@/moose";

export default async function AnalyticsPage() {
  const { totalRevenue, totalSales, activeNow } = await getOverviewMetrics();

  return (
    <div>
      <h1>Analytics</h1>
      <div>
        <p>Total Revenue: {totalRevenue}</p>
        <p>Total Sales: {totalSales}</p>
        <p>Active Users (last hour): {activeNow}</p>
      </div>
    </div>
  );
}
```

<Callout type="warning" title="Server-only: keep ClickHouse access on the server">
Do not call ClickHouse from the browser. Use Server Components, Route Handlers, or Server Actions so credentials remain server-side.
</Callout>

---

## 4) Run `moose dev` + `next dev` (recommended)

Run both in two terminals:

```bash title="Terminal 1" copy
pnpm dev:moose
```

```bash title="Terminal 2" copy
pnpm dev:next
```

**What’s happening:**
- `moose dev` manages local ClickHouse (Docker) and applies schema changes from `moose/`
- On every reload, Moose runs `on_reload_complete_script = "pnpm build:moose"` to rebuild `dist/`
- Next imports compiled output from `dist/` via `@/moose`

**Success checklist:**
- `pnpm build:moose` creates `dist/index.js` (and types)
- Next can resolve `@/moose`
- Your `/analytics` page renders without runtime errors

---

## 5) Production rollout (optional)

In this setup, your Next.js app connects directly to ClickHouse—there’s no separate Moose Runtime service to deploy. You just need to:

1. Apply your schema to production ClickHouse
2. Configure your Next.js production environment with production credentials

### Enable planned migrations

Add `ddl_plan = true` to `[features]` in `moose.config.toml`:

```toml title="moose.config.toml"
[features]
streaming_engine = false
data_model_v2 = true
ddl_plan = true
```

### Generate a migration plan

```bash title="Terminal" copy
pnpm moose generate migration \
  --clickhouse-url "clickhouse://user:password@your-prod-host:8443/db?secure=true" \
  --save
```

This creates files in `migrations/` including `plan.yaml`.

### Apply the migration

```bash title="Terminal" copy
pnpm moose migrate \
  --clickhouse-url "clickhouse://user:password@your-prod-host:8443/db?secure=true"
```

### Configure production environment

Set these in your deployment platform (Vercel, Railway, etc.):

```bash title="Production Environment Variables"
MOOSE_CLIENT_ONLY=true
MOOSE_CLICKHOUSE_CONFIG__DB_NAME=production_db
MOOSE_CLICKHOUSE_CONFIG__HOST=your-clickhouse-host.example.com
MOOSE_CLICKHOUSE_CONFIG__PORT=8443
MOOSE_CLICKHOUSE_CONFIG__USER=prod_user
MOOSE_CLICKHOUSE_CONFIG__PASSWORD=prod_password
MOOSE_CLICKHOUSE_CONFIG__USE_SSL=true
```

---

## Troubleshooting

**"Module not found: Can't resolve '@/moose/..."**
- Run `pnpm build:moose` to generate `dist/`
- Verify `tsconfig.json` has both `"@/moose": ["./dist/index"]` and `"@/moose/*": ["./dist/*"]`

**"Supply the type param T so that the schema is inserted..."**
- Check imports use `@/moose/*`, not `moose/*`
- Ensure `ts-patch` is installed and `tspc` is used in build scripts

**"ERR_UNSUPPORTED_DIR_IMPORT"**
- Add the `ts-node` block to `tsconfig.json` (see Configure TypeScript above)

**Native module errors (NODE_MODULE_VERSION)**
- Ensure Node.js v20, delete `node_modules`, run `pnpm install`

---

## Next steps

- [OlapTable Reference](/moosestack/olap/model-table) — Primary keys, engines, and configuration
- [Read Data](/moosestack/olap/read-data) — Query patterns and the Moose client
- [Migrations](/moosestack/migrate) — Schema versioning and migration strategies
- [Schema Optimization](/moosestack/olap/schema-optimization) — Ordering keys and partitioning
