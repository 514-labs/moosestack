---
title: Embed ClickHouse analytics in Fastify
description: Add MooseStack to an existing Fastify app to model, migrate, and query ClickHouse from your Fastify handlers (no separate Moose backend service).
---

import { Callout, FileTree, BulletPointsCard } from "@/components/mdx";

# Embed ClickHouse analytics in your Fastify backend

## Overview

This guide shows how to add MooseStack to an existing Fastify app as a library. You keep Fastify as your backend runtime, but you get ClickHouse schema management as TypeScript code, type-safe query helpers you can import into Fastify handlers, and a production migration workflow—without deploying a separate Moose backend service.

#### Intended audience

Developers with an existing Fastify app who want to **embed schema management + type-safe ClickHouse queries** without deploying a separate Moose backend service.

#### What you’ll accomplish

By the end of this guide, you’ll be able to:

- Model ClickHouse schema in TypeScript in a `moose/` directory (tables, views/materialized views)
- Query ClickHouse from your Fastify handlers using type-safe query helpers
- Run migrations against production ClickHouse with the Moose CLI as part of your existing deployment workflow

### Guide outline

- **[Get started](#get-started):** install and configure MooseStack in your Fastify repo, then set up your project so you can import the compiled output from `@/moose`.
- **[Model table](#model-table):** define your ClickHouse table schema in TypeScript in `moose/index.ts`.
- **[Start local ClickHouse](#start-local-clickhouse):** run `moose dev` to spin up a local ClickHouse instance and automatically instantiate (and hot-reload) your TypeScript models against it.
- **[Write queries](#write-queries):** create type-safe query helpers that use your models, and set up the Moose ClickHouse client to connect to your local ClickHouse instance.
- **[Use in Fastify](#use-in-fastify):** import the compiled query helpers from `@/moose` into your Fastify route handlers and return the results.
- **[Deploy to production](#deploy-to-production):** use the Moose CLI to run migrations against production ClickHouse, then update your production environment variables to point at it.

---

## Project structure

<FileTree>
  <FileTree.Folder name="your-fastify-app" defaultOpen>
    <FileTree.Folder name="src" defaultOpen>
      <FileTree.File name="index.ts" />
    </FileTree.Folder>
    <FileTree.Folder name="moose" defaultOpen>
      <FileTree.File name="index.ts" />
      <FileTree.File name="client.ts" />
      <FileTree.Folder name="queries" defaultOpen>
        <FileTree.File name="overview-metrics.ts" />
      </FileTree.Folder>
    </FileTree.Folder>
    <FileTree.Folder name="dist">
      <FileTree.File name="(auto-generated by build:moose)" />
    </FileTree.Folder>
    <FileTree.File name="moose.config.toml" />
    <FileTree.File name="tsconfig.moose.json" />
    <FileTree.File name=".env" />
    <FileTree.File name=".gitignore" />
    <FileTree.File name="package.json" />
    <FileTree.File name="tsconfig.json" />
  </FileTree.Folder>
</FileTree>

---

## Prerequisites

<BulletPointsCard
  title="Before you start"
  bulletStyle="check"
  compact={true}
  divider={false}
  bullets={[
    {
      title: "Node.js 20+",
      description: "Required for native module compatibility",
      link: { text: "Download →", href: "https://nodejs.org/en/download", external: true },
    },
    {
      title: "Docker Desktop",
      description: "MooseStack uses Docker to run ClickHouse locally",
      link: {
        text: "Download →",
        href: "https://docs.docker.com/get-started/get-docker/",
        external: true,
      },
    },
    {
      title: "Existing Fastify app",
      description: "TypeScript recommended",
    },
    {
      title: "pnpm (or npm/yarn)",
      description: "Package manager",
    },
  ]}
/>

---

<span id="get-started" />

## Get started

This section gets MooseStack running inside your existing Fastify project. You’ll install dependencies, configure TypeScript to import compiled Moose output, and create the Moose config needed to run `moose dev` locally.

### Install dependencies + add scripts

Add MooseStack and its build tools:

```bash title="Terminal" copy
pnpm add @514labs/moose-lib ts-patch tsconfig-paths typia
pnpm add -D @514labs/moose-cli@latest @types/node
```

Add these scripts to your `package.json` (replace `dev:fastify` with your existing dev command if you already have one):

```json title="package.json"
{
  "scripts": {
    "build:moose:types": "tspc -p tsconfig.moose.json --declaration --emitDeclarationOnly",
    "build:moose": "pnpm build:moose:types && tspc -p tsconfig.moose.json",

    "dev:fastify": "node ./dist-server.js",
    "dev:moose": "moose-cli dev",

    "moose": "moose-cli"
  },

  "pnpm": {
    "onlyBuiltDependencies": [
      "@confluentinc/kafka-javascript",
      "@514labs/kafka-javascript"
    ]
  }
}
```

<Callout type="warning" title="Why tspc instead of tsc?">
MooseStack uses compiler plugins to inject schemas into your models at build time. The `ts-patch` package provides `tspc`, which supports these plugins.
</Callout>

### Configure TypeScript (import compiled Moose output)

Moose code must be imported from the compiled `dist/` output.

#### Update `tsconfig.json`

Add these path mappings (adjust `@/*` if you don’t use it):

```json title="tsconfig.json"
{
  "ts-node": {
    "compilerOptions": {
      "allowImportingTsExtensions": false,
      "verbatimModuleSyntax": false,
      "erasableSyntaxOnly": false,
      "module": "commonjs",
      "moduleResolution": "node"
    }
  },
  "compilerOptions": {
    "paths": {
      "@/*": ["./src/*"],
      "@/moose": ["./dist/index"],
      "@/moose/*": ["./dist/*"]
    }
  }
}
```

<Callout type="warning" title="Incompatible TypeScript options">
If your `tsconfig.json` extends a base config (like `fastify-tsconfig`) that sets `allowImportingTsExtensions: true`, `verbatimModuleSyntax: true`, or `erasableSyntaxOnly: true`, you must add the `ts-node` block above with these overrides. These options are incompatible with ts-node when it compiles to CommonJS (`module: "commonjs"`), which `moose-cli dev` requires. The `ts-node` block overrides these for ts-node only, allowing your regular TypeScript compilation to keep these options if needed.
</Callout>

Create `tsconfig.moose.json` in your project root:

```json title="tsconfig.moose.json"
{
  "compilerOptions": {
    "outDir": "dist",
    "noEmit": false,
    "declaration": true,
    "declarationMap": true,
    "module": "commonjs",
    "moduleResolution": "node",
    "isolatedModules": false,
    "strictNullChecks": true,
    "esModuleInterop": true,
    "plugins": [
      { "transform": "typia/lib/transform" },
      {
        "transform": "./node_modules/@514labs/moose-lib/dist/compilerPlugin.js",
        "transformProgram": true
      }
    ]
  },
  "include": ["moose/**/*"],
  "exclude": ["node_modules", "dist"]
}
```

#### Create Moose config + environment variables

Create `moose.config.toml` in your project root:

```toml title="moose.config.toml"
language = "Typescript"
source_dir = "moose"

[clickhouse_config]
db_name = "local"
user = "panda"
password = "pandapass"
use_ssl = false
host = "localhost"
host_port = 18123
native_port = 9000

[http_server_config]
host = "localhost"
port = 4000
management_port = 5001

# Key dev workflow: rebuild dist/ after moose reloads
on_reload_complete_script = "pnpm build:moose"

[features]
streaming_engine = false
data_model_v2 = true
```

Create or update `.env` (or your existing env file) with your ClickHouse connection details:

```bash title=".env" copy
MOOSE_CLIENT_ONLY=true

MOOSE_CLICKHOUSE_CONFIG__DB_NAME=local
MOOSE_CLICKHOUSE_CONFIG__HOST=localhost
MOOSE_CLICKHOUSE_CONFIG__PORT=18123
MOOSE_CLICKHOUSE_CONFIG__USER=panda
MOOSE_CLICKHOUSE_CONFIG__PASSWORD=pandapass
MOOSE_CLICKHOUSE_CONFIG__USE_SSL=false
```

Update `.gitignore` to exclude MooseStack generated files:

```text title=".gitignore"
# MooseStack generated files
/dist
.moose/
.ts-node/
```

---

<span id="model-table" />

## Model table

In this step you’ll define your first ClickHouse model as an `OlapTable` object. MooseStack uses these models as the source of truth for schema management.

Create `moose/index.ts` with the following content:

```ts title="moose/index.ts"
import { OlapTable } from "@514labs/moose-lib";

export interface EventModel {
  transaction_id: string;
  event_type: string;
  product_id: number;
  customer_id: string;
  amount: number;
  quantity: number;
  event_time: Date;
  customer_email: string;
  customer_name: string;
  product_name: string;
  status: string; // e.g. 'completed', 'active', 'inactive'
}

export const Events = new OlapTable<EventModel>("events", {
  orderByFields: ["event_time"],
});
```

---

<span id="start-local-clickhouse" />

## Start local ClickHouse

Now start the Moose Runtime in `dev` mode. This instantly brings up a local ClickHouse instance (via Docker) and automatically instantiates your models against it, giving you a fast feedback loop for iterating on your schema.

Leave this running in its own terminal for the rest of the guide:

```bash title="Terminal" copy
pnpm dev:moose
```

As you update models and query helpers in `moose/`, Moose will apply schema changes to this instance and (based on your `moose.config.toml`) rebuild `dist/` after reload so your app can import the compiled output via `@/moose`.

---

<span id="write-queries" />

## Write queries

This step is crucial to facilitate the interaction between your Fastify app and ClickHouse.

With the local ClickHouse instance running, you’ll instantiate the Moose ClickHouse client to connect to it. This is a singleton that will be used to connect to the ClickHouse instance for the duration of the application's lifecycle. You'll then leverage this client to write type-safe query helpers that use your `OlapTable` objects.

#### Create a ClickHouse client helper

Create `moose/client.ts`:

```ts title="moose/client.ts"
import { getMooseClients } from "@514labs/moose-lib";

const globalForMoose = globalThis as unknown as {
  mooseClient: Awaited<ReturnType<typeof getMooseClients>> | undefined;
};

export async function getMoose() {
  if (globalForMoose.mooseClient) {
    return globalForMoose.mooseClient;
  }

  const client = await getMooseClients({
    database: process.env.MOOSE_CLICKHOUSE_CONFIG__DB_NAME!,
    host: process.env.MOOSE_CLICKHOUSE_CONFIG__HOST!,
    port: process.env.MOOSE_CLICKHOUSE_CONFIG__PORT!,
    username: process.env.MOOSE_CLICKHOUSE_CONFIG__USER!,
    password: process.env.MOOSE_CLICKHOUSE_CONFIG__PASSWORD!,
    useSSL: process.env.MOOSE_CLICKHOUSE_CONFIG__USE_SSL === "true",
  });

  if (process.env.NODE_ENV !== "production") {
    globalForMoose.mooseClient = client;
  }

  return client;
}
```

#### Create a query helper

Create a file called `moose/queries/overview-metrics.ts` with the following content:

```ts title="moose/queries/overview-metrics.ts"
import { sql } from "@514labs/moose-lib";
import { Events } from "../index";
import { getMoose } from "../client";

export interface DateRange {
  start: Date;
  end: Date;
}

export const getOverviewMetrics = async (dateRange?: DateRange) => {
  const moose = await getMoose();

  const startDate = dateRange?.start.toISOString().split("T")[0];
  const endDate = dateRange?.end.toISOString().split("T")[0];

  const dateFilter =
    dateRange ?
      sql`AND ${Events.columns.event_time} >= toDate(${startDate!}) AND ${Events.columns.event_time} <= toDate(${endDate!})`
    : sql``;

  const salesData = await moose.client.query.execute(
    sql`
      SELECT
        sum(${Events.columns.amount}) as total_revenue,
        count(*) as total_sales
      FROM ${Events}
      WHERE ${Events.columns.event_type} = 'purchase' ${dateFilter}
    `,
  );

  const [salesRow] = await salesData.json<{
    total_revenue?: number;
    total_sales?: number;
  }>();

  const activeUsersData = await moose.client.query.execute(
    sql`
      SELECT uniq(${Events.columns.customer_id}) as active_users
      FROM ${Events}
      WHERE ${Events.columns.event_time} > now() - interval 1 hour
    `,
  );

  const [activeUsersRow] = await activeUsersData.json<{
    active_users?: number;
  }>();

  return {
    totalRevenue: salesRow?.total_revenue ?? 0,
    totalSales: salesRow?.total_sales ?? 0,
    activeNow: activeUsersRow?.active_users ?? 0,
  };
};
```

#### Export from `moose/index.ts`

```ts title="moose/index.ts"
export * from "./queries/overview-metrics";
```

---

<span id="use-in-fastify" />

## Use in Fastify

Keep `pnpm dev:moose` running.

Now import and call your Moose query helper from a Fastify route handler:

```ts title="src/index.ts"
import Fastify from "fastify";
import { getOverviewMetrics } from "@/moose";

const app = Fastify();

app.get("/analytics", async () => {
  return await getOverviewMetrics();
});

app.listen({ port: 3000 });
```

<Callout type="warning" title="Server-only: keep ClickHouse access on the server">
Do not call ClickHouse from the browser. Keep ClickHouse credentials and queries in your Fastify handlers.
</Callout>

---

<span id="deploy-to-production" />

## Deploy to production (optional)

In this setup, your Fastify app connects directly to ClickHouse—there’s no separate production Moose Runtime to deploy. You just need to:

1. Apply your schema to production ClickHouse
2. Configure your production environment with production credentials

#### Enable planned migrations

Add `ddl_plan = true` to `[features]` in `moose.config.toml`:

```toml title="moose.config.toml"
[features]
streaming_engine = false
data_model_v2 = true
ddl_plan = true
```

#### Generate a migration plan

```bash title="Terminal" copy
pnpm moose generate migration \
  --clickhouse-url "clickhouse://user:password@your-prod-host:8443/db?secure=true" \
  --save
```

This creates files in `migrations/` including `plan.yaml`.

#### Apply the migration

```bash title="Terminal" copy
pnpm moose migrate \
  --clickhouse-url "clickhouse://user:password@your-prod-host:8443/db?secure=true"
```

#### Configure production environment

Set these in your deployment platform:

```bash title="Production Environment Variables"
MOOSE_CLIENT_ONLY=true
MOOSE_CLICKHOUSE_CONFIG__DB_NAME=production_db
MOOSE_CLICKHOUSE_CONFIG__HOST=your-clickhouse-host.example.com
MOOSE_CLICKHOUSE_CONFIG__PORT=8443
MOOSE_CLICKHOUSE_CONFIG__USER=prod_user
MOOSE_CLICKHOUSE_CONFIG__PASSWORD=prod_password
MOOSE_CLICKHOUSE_CONFIG__USE_SSL=true
```

---

## Troubleshooting

If you see import errors for `@/moose`, confirm:

- You ran `pnpm build:moose` to generate `dist/`
- Your `tsconfig.json` path mappings include both `"@/moose"` and `"@/moose/*"`

---

## Next steps

- [OlapTable Reference](/moosestack/olap/model-table) — Primary keys, engines, and configuration
- [Read Data](/moosestack/olap/read-data) — Query patterns and the Moose client
- [Migrations](/moosestack/migrate) — Schema versioning and migration strategies
- [Schema Optimization](/moosestack/olap/schema-optimization) — Ordering keys and partitioning
