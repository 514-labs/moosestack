  <GuideStepper.Step
    id="phase-3"
    number={3}
    title="Serve the materialized view to your frontend"
    summary="Expose the serving table via Query Layer and preserve the existing API contract."
  >
    <GuideStepper.WhatYouNeed>
      - `moosestack/context/dashboard-migration/<COMPONENT_NAME>/` — the context directory (test cases, context map)
      - `moosestack/app/models/<SERVING_TABLE_NAME>-mv.ts` — the serving table and MV file from Phase 2
      - Your existing backend endpoint handler that currently calls the OLTP or parity query (e.g. Express route, Fastify handler)
      - `moosestack/query-layer/` — the Query Layer source copied in the step above
    </GuideStepper.WhatYouNeed>
    <GuideStepper.WhatYouGet>
      - A QueryModel that maps serving-table data to your existing API contract
      - Handler integration that switches reads from OLTP/parity logic to Query Layer
      - Fixture-based verification that response behavior remains intact
    </GuideStepper.WhatYouGet>

<GuideStepper.Prompt>
Role:
You are a MooseStack integration engineer. Your goal is to expose optimized ClickHouse serving data through Query Layer and handler rewiring while preserving existing API contract behavior.

Rules:

1. Validate required inputs once at start and list any missing input.
2. Preserve request shape, response shape, ordering, and types.
3. Do not introduce breaking API changes during handler rewiring.
4. Record ambiguity as assumptions in `context-map.md`.
5. Do not fabricate fixture results or verification evidence.
6. If any fixture comparison fails, mark FAIL, report root cause, fix, and re-run.
7. Do not mark PASS until all recorded fixtures pass.

Required inputs:

- Serving table and MV file path
- Existing handler path
- Request/response contract path

Required outputs:

- `moosestack/app/query-models/<name>.model.ts`
- Updated handler integration file(s)
- Verification evidence for fixture comparisons
- Phase 3 Status (PASS/FAIL)

</GuideStepper.Prompt>

<GuideStepper.Checkpoint
  id="phase-3-install-query-layer"
  title="Install Query Layer source"
>
If you haven't already, run the following command to copy the Query Layer source code into your project:

```bash
pnpm dlx tiged 514-labs/query-layer/src ./query-layer
```

</GuideStepper.Checkpoint>

<GuideStepper.Checkpoint
  id="phase-3-define-implement-query-model"
  title="Define and implement the QueryModel"
>
Goal: map the existing endpoint contract to a QueryModel and implement it.

Steps:

1. Identify the QueryModel requirements from the existing contract:
   - **Dimensions:** fields the UI groups by (e.g. `merchantName`, `day`)
   - **Metrics:** aggregates the UI needs (e.g. `totalOrders`, `fulfillmentRate`)
   - **Filters:** request params + allowed operators (e.g. `merchantId in`, `day gte/lte`)
   - **Sortable:** sortable fields + any tie-breakers
2. Create `moosestack/app/query-models/<name>.ts` with `defineQueryModel(...)` over the serving table.
3. Map the serving table columns to those requirements, keeping field names aligned with the existing API contract.

```ts
// File: moosestack/app/query-models/orderFulfillment.model.ts

import { sql } from "@514labs/moose-lib";
import { defineQueryModel } from "../query-layer";
import { OrderFulfillmentServing } from "../models/OrderFulfillmentServing.model";

export const orderFulfillmentModel = defineQueryModel({
  table: OrderFulfillmentServing,

  // Dimensions: fields users can group by
  dimensions: {
    merchantName: { column: "merchant_name" },
    day: { column: "day" },
  },

  // Metrics: aggregations users can request
  metrics: {
    totalOrders: { agg: sql`sum(total_orders)` },
    fulfilledOrders: { agg: sql`sum(fulfilled_orders)` },
    fulfillmentRate: {
      agg: sql`round(100 * sum(fulfilled_orders) / nullIf(sum(total_orders), 0), 2)`,
    },
  },

  // Filters: fields users can filter on
  filters: {
    merchantId: { column: "merchant_id", operators: ["eq", "in"] as const },
    day: { column: "day", operators: ["gte", "lte"] as const },
  },

  // Sortable: fields users can sort by
  sortable: ["merchantName", "day", "totalOrders", "fulfillmentRate"] as const,
});
```

</GuideStepper.Checkpoint>

<GuideStepper.Checkpoint
  id="phase-3-wire-handler"
  title="Wire the handler"
>
Goal: rewire your existing query handler function to call the QueryModel and map results back to the exact response shape.

Steps:

1. Build a QueryModel request from your endpoint inputs (filters, sort, pagination).
2. Execute the QueryModel against ClickHouse using the `query` method.
3. Map the QueryModel results back to the exact response shape the endpoint already produces.

```ts
// File: moosestack/app/apis/orderFulfillment.api.ts

import { getMooseUtils } from "@514labs/moose-lib";
import { orderFulfillmentModel } from "../query-models/orderFulfillment.model";

interface OrderFulfillmentRequest {
  merchantId?: string;
  startDate?: string;
  endDate?: string;
  limit?: number;
  offset?: number;
  orderBy?: "merchantName" | "day" | "totalOrders" | "fulfillmentRate";
}

export async function getOrderFulfillment(request: OrderFulfillmentRequest) {
  const { client } = await getMooseUtils();

  return await orderFulfillmentModel.query(
    {
      dimensions: ["merchantName", "day"],
      metrics: ["totalOrders", "fulfilledOrders", "fulfillmentRate"],
      filters: {
        ...(request.merchantId && { merchantId: { eq: request.merchantId } }),
        ...(request.startDate && { day: { gte: request.startDate } }),
        ...(request.endDate && { day: { lte: request.endDate } }),
      },
      sortBy: request.orderBy ?? "merchantName",
      sortDir: "ASC",
      limit: request.limit ?? 100,
      offset: request.offset ?? 0,
    },
    client.query,
  );
}
```

**Integration point:** In your existing backend handler (Express, Fastify, Next.js, etc.), replace the OLTP query call with a call to this new function and return the result:

```ts
// In your existing backend handler (e.g. Express route)
import { getOrderFulfillment } from "moosestack/app/apis/orderFulfillment.api";

app.post("/api/order-fulfillment", async (req, res) => {
  const result = await getOrderFulfillment(req.body);
  res.json(result); // Same response shape as before
});
```

</GuideStepper.Checkpoint>

<GuideStepper.Checkpoint
  id="phase-3-verification"
  title="Verification"
>
Goal: verify the endpoint response matches the saved Phase 1 fixtures.

Steps:

1. Restart your backend with the updated handler so the endpoint now reads from ClickHouse via the QueryModel.
2. Run a saved Phase 1 test case by copying the `curl` request from:
   - `moosestack/context/dashboard-migration/<COMPONENT_NAME>/test-cases/01-<short-name>.md`
3. Save the live endpoint response:

```bash
# Paste the curl from the test case file and redirect the JSON response:
<PASTE_CURL_HERE> | jq -S '.' > localhost-result.json
```

4. Extract the expected response JSON from the same test case file:

````bash
awk 'f{print} /^```json/{f=1; next} /^```$/{if(f){exit}}' \
  moosestack/context/dashboard-migration/<COMPONENT_NAME>/test-cases/01-<short-name>.md \
  | jq -S '.' > expected.json
````

5. Compare:

```bash
diff expected.json localhost-result.json
```

Repeat for every recorded test case. If differences remain, fix the smallest possible issue (sorting, rounding/casting, date bucketing) and re-run.

**Optional: Verify performance improvement**

Measure response time for your heaviest test case (replace `test-case-heaviest.json` with the file you want to benchmark):

```bash
time curl -s -X POST http://localhost:4000/api/order-fulfillment \
  -H "Content-Type: application/json" \
  -d @test-case-heaviest.request.json
```

Verify the response time is significantly improved compared to the original OLTP query.

</GuideStepper.Checkpoint>
</GuideStepper.Step>
