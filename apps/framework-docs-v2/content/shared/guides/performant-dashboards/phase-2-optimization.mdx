<GuideStepper.Step
  id="phase-2"
  number={2}
  title="Performance optimization (Materialized Views)"
  summary="Move expensive read-time logic into serving tables and materialized views."
>
    <GuideStepper.WhatYouNeed>
      - `moosestack/context/dashboard-migration/<COMPONENT_NAME>/` — the context directory (context map, test cases from Phase 1)
      - The unoptimized parity query from Phase 1 (e.g. `moosestack/app/queries/<COMPONENT_NAME>-olap-translation.ts`)
      - The MooseStack source table model files referenced in the parity query (e.g. `moosestack/app/models/*.ts`)
    </GuideStepper.WhatYouNeed>
    <GuideStepper.WhatYouGet>
      - A serving-table schema aligned to request-time access patterns
      - A production-ready Materialized View implementation tied to that serving table
      - Verification that serving tables are populated from your MV pipeline
    </GuideStepper.WhatYouGet>

<GuideStepper.Prompt>
Convert the provided ClickHouse query function into OLAP-native serving tables and materialized views while preserving query semantics.

Rules:

1. Validate required inputs once at start and list any missing input.
2. Preserve query semantics while moving expensive read-time work to write-time structures.
3. If MV strategy is ambiguous, decide with tradeoffs and record the decision in `context-map.md`.
4. Define the Materialized View using the `MaterializedView` object from `@514labs/moose-lib`.
5. Ensure `MaterializedView.selectStatement` output aligns exactly with the `MaterializedView.targetTable` schema names and types.
6. Do not fabricate verification evidence.
7. If optimization validation fails, mark FAIL, report root cause, fix, and re-run.
8. Do not mark PASS until serving tables are populated and query QA passes.

Required inputs:

- ClickHouse query function path
- MooseStack source table model path(s)
- Access patterns (filters, group-bys, sorts) from the API specification

Required outputs:

- `moosestack/app/models/<SERVING_TABLE_NAME>-mv.ts` with the serving table and Materialized View definitions.
- Updated `context-map.md` with the file path to the file that defines the serving table and Materialized View.
- Validation that the serving table and Materialized View are populated in the moose project infra map.
- A ClickHouse SQL query that can be used to verify the serving table has been populated via the Materialized View.

</GuideStepper.Prompt>

<GuideStepper.Checkpoint
  id="phase-2-serving-table-design"
  title="Create + verify serving table"
>
Goal: define the MooseStack serving table (`OlapTable`) in `moosestack/app/models/<SERVING_TABLE_NAME>-mv.ts`, register it, and verify the table is created before you wire the MV.

Steps:

1. Only define an `OlapTable` object in this step. **Do not** define a `MaterializedView` object.
2. **Serving-table schema (output of this checkpoint)**: define the `OlapTable` columns from the final `SELECT` output of the Phase 1 parity query. This schema is the canonical shape your downstream dashboard API will consume.
3. **Grain (row identity)**: decide which fields define one row in this serving table (for example, `merchant_id + day`). This is the core modeling decision for correctness and aggregation behavior.
4. **`orderByFields` (storage/sort key)**: choose the primary sort key by starting with grain fields, then adding the most common filter/group-by fields from your access patterns.
5. **Table engine (write/read semantics)**: select the engine from `ClickHouseEngines` (imported from `@514labs/moose-lib`) and set it explicitly on `OlapTable`. Use `ClickHouseEngines.MergeTree` by default for immutable aggregates; choose another `ClickHouseEngines.*` value only when your workload needs different semantics (for example, dedup/update behavior).
6. Implement and save the serving table `OlapTable` definition in `moosestack/app/models/<SERVING_TABLE_NAME>-mv.ts`.
7. `export` the `ServingTable` object from `moosestack/app/models/<SERVING_TABLE_NAME>-mv.ts`.
8. From your root `index.ts` file, import `ServingTable` from `moosestack/app/models/<SERVING_TABLE_NAME>-mv.ts`.
9. Save your files and monitor `moose dev` logs for table creation:

```
[INFO] Created table: <SERVING_TABLE_NAME>
```

10. If table creation fails, check:

- **Engine/order key config**: if you use `ClickHouseEngines.ReplacingMergeTree` (or `ReplicatedReplacingMergeTree`), ensure an `ORDER BY` is defined via `orderByFields`/`orderByExpression`. Look for errors like `ReplacingMergeTree requires an order by clause`.
- **Mutually exclusive table config**: define only one of `orderByFields` or `orderByExpression`. `ts-moose-lib` rejects both at once (`Provide either orderByFields or orderByExpression, not both.`).
- **Identifier validity**: table/database identifiers must be valid (non-empty, allowed characters, no invalid prefix). CLI surfaces identifier validation errors during planning/apply.

Do not continue until you see the table creation success message in the `moose dev` logs.

Example (adapt to your component — do not copy names literally):

If your parity query selects `merchant_id, merchant_name, day, total_orders, fulfilled_orders, fulfillment_rate`, define the serving table first with those columns and the chosen `orderByFields`:

```ts filename="moosestack/app/models/<SERVING_TABLE_NAME>-mv.ts" copy
import { ClickHouseEngines, Int64, OlapTable } from "@514labs/moose-lib";

interface ServingTableSchema {
  merchant_id: string;
  merchant_name: string;
  day: Date;
  total_orders: Int64;
  fulfilled_orders: Int64;
  fulfillment_rate: number;
}

export const ServingTable = new OlapTable<ServingTableSchema>(
  "<ServingTable>",
  {
    orderByFields: ["merchant_id", "day"], // This is based on the most common filter/group-by fields from your access patterns.
    engine: ClickHouseEngines.MergeTree, // Use `ClickHouseEngines.MergeTree` by default for immutable aggregates; choose another `ClickHouseEngines.*` value only when your workload needs different semantics (for example, dedup/update behavior).
  },
);
```

Once the table is created, record these design decisions as concise inline comments in `moosestack/app/models/<SERVING_TABLE_NAME>-mv.ts`: schema intent, grain, `orderByFields` rationale, selected `ClickHouseEngines.*` value, and any assumptions/tradeoffs.

</GuideStepper.Checkpoint>

<GuideStepper.Checkpoint
  id="phase-2-materialized-view-plan"
  title="Materialized View plan"
>
Goal: produce a concrete MV implementation plan (before coding) for how data will flow into the serving table.

Decision rule:

- **Single MV**: use when the pipeline is simple (one source table, minimal joins, straightforward aggregation).
- **Staged pipeline**: use when logic is complex (multiple CTEs, 3+ joined tables, heavy pre-aggregation, or transformations that are hard to reason about in one statement).

Design principle:
Move non-request-driven work to write-time MVs. Keep only truly dynamic, request-time filters in the final read query.

Steps:

1. Start from the Phase 1 parity query and list which parts are static (precomputable) vs request-time dynamic.
2. Choose **single MV** or **staged pipeline** using the rule above. If uncertain, write both options with tradeoffs and explicitly request a decision before implementing.
3. List every source table model required for `selectTables`.
4. Draft the planned `selectStatement` flow in plain language: joins, aggregations, derived columns, and where each transformation happens.
5. In `moosestack/app/models/<SERVING_TABLE_NAME>-mv.ts`, add a `TODO` comment block above the future `MaterializedView` definition that captures:
   - chosen approach (`single` or `staged`)
   - planned source tables (`selectTables`)
   - planned transformation flow summary
   - assumptions/tradeoffs

**Done when:** `context-map.md` contains an implementation-ready MV plan that another engineer (or copilot) can follow without re-deriving architecture decisions.

</GuideStepper.Checkpoint>

<GuideStepper.Checkpoint
  id="phase-2-implement-serving-table-mv"
  title="Create + verify MV"
>
Goal: implement the MV plan in `moosestack/app/models/<SERVING_TABLE_NAME>-mv.ts`, register the `MaterializedView`, and verify it creates and populates the serving table.

Steps:

1. In `moosestack/app/models/<SERVING_TABLE_NAME>-mv.ts`, keep the existing serving table and add a new `MaterializedView` object in the same file. Use the same name for the `MaterializedView` object as the serving table name, but append `_mv` to the end.
2. Wire `targetTable` to the serving table from Checkpoint 1. The serving table is already defined in the file, so you can reference it directly.
3. Add `selectTables` with every source model listed in the MV plan from Checkpoint 2. Ensure each source model is imported in the file.
4. Implement `selectStatement` using `sql` with the exact transformation flow you planned (joins, aggregations, derived columns, aliases). Use the `sql` tagged template literal from `@514labs/moose-lib` to build the SQL statement.
5. Make the `SELECT` output a strict contract match to the serving table schema: same column names, same order, and compatible data types.
6. If using a staged pipeline, define intermediate resources first and ensure each stage's output schema matches the next stage's input.
7. `export` the instantiated `MaterializedView` object from `moosestack/app/models/<SERVING_TABLE_NAME>-mv.ts`.
8. Save your files and monitor `moose dev` logs for MV creation:

```
[INFO] Created materialized view: <SERVING_TABLE_NAME>_mv
```

9. Verify the serving table is populated. `moose dev` automatically runs the MV `selectStatement` on creation (do not backfill manually at this stage).

```bash
# Row count
moose query -q "SELECT count() FROM <SERVING_TABLE_NAME> FINAL"

# Spot-check a slice that matches a Phase 1 test case
moose query -q "SELECT * FROM <SERVING_TABLE_NAME> FINAL WHERE <filter_from_test_case> LIMIT 5"
```

10. If MV creation/population fails, check:

- **Schema contract mismatch**: `selectStatement` output must match the serving table exactly (column names, order, and compatible types).
- **MV naming and target wiring**: `materializedViewName` must differ from the serving table name and `targetTable` must be set correctly (`Materialized view name cannot be the same as the target table name.` / `Name of targetTable is not specified.`).
- **Source dependency registration/order**: every table in `selectTables` must exist, be imported, and be registered before MV creation. Ordering issues can surface as `Cyclic dependency detected in OLAP changes`.
- **Static SQL requirement**: MV `selectStatement` must resolve to static SQL at build time. Dynamic SQL fails with `Dynamic SQL is not allowed in the select statement in view creation.`

This checkpoint is complete when the serving table is populated with data for every Phase 1 test case time window. If rows are missing, check MV logic and source table data coverage.

Reference Example:

```ts filename="moosestack/app/models/<SERVING_TABLE_NAME>-mv.ts" copy
import { Int64, MaterializedView, OlapTable, sql } from "@514labs/moose-lib";
import { SourceTableA } from "./SourceTableA.model";
import { SourceTableB } from "./SourceTableB.model";

// ... serving table interface and OlapTable definition from Checkpoint 1 ...

export const ServingMV = new MaterializedView<ServingTableSchema>({
  selectStatement: sql`
    SELECT
      a.id,
      b.name,
      toDate(a.created_at) AS day,
      count() AS total,
      sumIf(1, a.status = 'complete') AS completed
    FROM ${SourceTableA} a
    JOIN ${SourceTableB} b ON b.id = a.ref_id
    GROUP BY a.id, b.name, day
  `,
  targetTable: ServingTable,
  materializedViewName: "<ServingTable>MV",
  selectTables: [SourceTableA, SourceTableB],
});
```

**Done when:** `SERVING_TABLE_NAME_mv` is defined, exported, imported in `index.ts`, `moose dev` shows `[INFO] Created materialized view: <SERVING_TABLE_NAME>_mv`, and serving table spot-checks return data for your Phase 1 windows.

</GuideStepper.Checkpoint>
</GuideStepper.Step>
