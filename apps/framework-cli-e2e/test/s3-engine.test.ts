/// <reference types="node" />
/// <reference types="mocha" />
/// <reference types="chai" />
/**
 * End-to-end tests for S3 engine runtime environment variable resolution
 *
 * These tests verify that:
 * 1. mooseRuntimeEnv markers are correctly generated by TypeScript/Python libraries for S3 engine
 * 2. Rust CLI correctly resolves the markers from environment variables at startup
 * 3. Error messages include field names when environment variables are missing
 * 4. Tables without credentials (public buckets with noSign) work correctly
 * 5. System fails startup with clear error messages when env vars are missing
 * 6. Resolved environment variable values are correctly used in infrastructure
 */

import { spawn, ChildProcess } from "child_process";
import { expect } from "chai";
import * as path from "path";

// Import test utilities
import { TIMEOUTS, TEMPLATE_NAMES, APP_NAMES } from "./constants";

import {
  stopDevProcess,
  waitForServerStart,
  createTempTestDirectory,
  setupTypeScriptProject,
  setupPythonProject,
  removeTestProject,
} from "./utils";

const CLI_PATH = path.resolve(__dirname, "../../../target/debug/moose-cli");
const MOOSE_LIB_PATH = path.resolve(
  __dirname,
  "../../../packages/ts-moose-lib",
);
const MOOSE_PY_LIB_PATH = path.resolve(
  __dirname,
  "../../../packages/py-moose-lib",
);

describe("typescript template tests - S3 Engine Runtime Environment Variable Resolution", () => {
  describe("With Environment Variables", () => {
    let devProcess: ChildProcess | null = null;
    let TEST_PROJECT_DIR: string;

    before(async function () {
      this.timeout(TIMEOUTS.TEST_SETUP_MS);

      // Create temporary directory
      TEST_PROJECT_DIR = createTempTestDirectory("ts-s3-engine-set");

      // Setup TypeScript project
      await setupTypeScriptProject(
        TEST_PROJECT_DIR,
        TEMPLATE_NAMES.TYPESCRIPT_TESTS,
        CLI_PATH,
        MOOSE_LIB_PATH,
        APP_NAMES.TYPESCRIPT_TESTS,
        "npm",
      );

      // Start dev server WITH the required environment variables set
      devProcess = spawn(CLI_PATH, ["dev"], {
        stdio: "pipe",
        cwd: TEST_PROJECT_DIR,
        env: {
          ...process.env,
          // Set dummy credentials for S3 engine testing
          TEST_S3_AWS_ACCESS_KEY_ID: "test-s3-access-key-id",
          TEST_S3_AWS_SECRET_ACCESS_KEY: "test-s3-secret-access-key",
          // Also set S3Queue env vars so those tests don't fail
          TEST_AWS_ACCESS_KEY_ID: "test-access-key-id",
          TEST_AWS_SECRET_ACCESS_KEY: "test-secret-access-key",
        },
      });

      await waitForServerStart(
        devProcess,
        TIMEOUTS.SERVER_STARTUP_MS,
        "started successfully",
        "http://localhost:4000",
      );
    });

    after(async function () {
      this.timeout(TIMEOUTS.CLEANUP_MS);
      await stopDevProcess(devProcess);
      removeTestProject(TEST_PROJECT_DIR);
    });

    it("should start successfully and resolve S3 engine environment variables correctly", async function () {
      this.timeout(TIMEOUTS.TEST_SETUP_MS);

      // If we got here, the server started successfully with the environment variables set
      // This verifies that:
      // 1. mooseRuntimeEnv.get() markers were correctly generated by the TypeScript library
      // 2. The Rust CLI successfully resolved the markers from environment variables
      // 3. The resolved values were used to create the S3 engine table without errors
      //
      // If the environment variables were not resolved correctly, the server would have
      // failed to start with an error message containing the table name and field name.
      expect(devProcess?.killed).to.be.false;
    });
  });

  describe("Without Environment Variables", () => {
    let devProcess: ChildProcess | null = null;

    it("should fail to start when required S3 engine environment variables are missing", async function () {
      this.timeout(TIMEOUTS.TEST_SETUP_MS);

      // Create temporary directory
      const TEST_PROJECT_DIR = createTempTestDirectory("ts-s3-engine-unset");

      // Setup TypeScript project
      await setupTypeScriptProject(
        TEST_PROJECT_DIR,
        TEMPLATE_NAMES.TYPESCRIPT_TESTS,
        CLI_PATH,
        MOOSE_LIB_PATH,
        APP_NAMES.TYPESCRIPT_TESTS,
        "npm",
      );

      // Start dev server WITHOUT the S3 engine environment variables set
      // Only set S3Queue env vars to isolate S3 engine failures
      devProcess = spawn(CLI_PATH, ["dev"], {
        stdio: "pipe",
        cwd: TEST_PROJECT_DIR,
        env: {
          ...process.env,
          // Set S3Queue env vars so those tests don't fail
          TEST_AWS_ACCESS_KEY_ID: "test-access-key-id",
          TEST_AWS_SECRET_ACCESS_KEY: "test-secret-access-key",
          // Explicitly unset S3 engine env vars
          TEST_S3_AWS_ACCESS_KEY_ID: undefined,
          TEST_S3_AWS_SECRET_ACCESS_KEY: undefined,
        },
      });

      let stdoutOutput = "";
      let stderrOutput = "";

      devProcess.stdout?.on("data", (data) => {
        stdoutOutput += data.toString();
      });

      devProcess.stderr?.on("data", (data) => {
        stderrOutput += data.toString();
      });

      const exitPromise = new Promise<number>((resolve, reject) => {
        devProcess!.on("exit", (code) => {
          resolve(code || 0);
        });

        // Add timeout in case process doesn't exit
        setTimeout(() => {
          reject(new Error("Process did not exit within expected time"));
        }, TIMEOUTS.SERVER_STARTUP_MS);
      });

      try {
        const exitCode = await exitPromise;

        // Process should exit with non-zero code
        expect(exitCode).to.not.equal(0);

        // Combine stdout and stderr for checking
        const output = stdoutOutput + stderrOutput;

        // Log captured output for debugging
        console.log("=== Captured stdout ===");
        console.log(stdoutOutput);
        console.log("=== Captured stderr ===");
        console.log(stderrOutput);

        // Verify error message includes table name, field name, and env var name
        expect(output).to.include("S3WithSecrets");
        expect(output).to.match(/awsAccessKeyId|awsSecretAccessKey/);
        expect(output).to.match(
          /TEST_S3_AWS_ACCESS_KEY_ID|TEST_S3_AWS_SECRET_ACCESS_KEY/,
        );

        console.log("Process exited with expected error message");
      } catch (error) {
        // Log captured output even on timeout
        console.log("=== Process timed out - captured stdout ===");
        console.log(stdoutOutput);
        console.log("=== Process timed out - captured stderr ===");
        console.log(stderrOutput);
        throw error;
      } finally {
        // Cleanup
        if (devProcess && !devProcess.killed) {
          devProcess.kill("SIGKILL");
        }
        removeTestProject(TEST_PROJECT_DIR);
      }
    });
  });
});

describe("python template tests - S3 Engine Runtime Environment Variable Resolution", () => {
  describe("With Environment Variables", () => {
    let devProcess: ChildProcess | null = null;
    let TEST_PROJECT_DIR: string;

    before(async function () {
      this.timeout(TIMEOUTS.TEST_SETUP_MS);

      // Create temporary directory
      TEST_PROJECT_DIR = createTempTestDirectory("py-s3-engine-set");

      // Setup Python project
      await setupPythonProject(
        TEST_PROJECT_DIR,
        TEMPLATE_NAMES.PYTHON_TESTS,
        CLI_PATH,
        MOOSE_PY_LIB_PATH,
        APP_NAMES.PYTHON_TESTS,
      );

      // Start dev server WITH the required environment variables set
      devProcess = spawn(CLI_PATH, ["dev"], {
        stdio: "pipe",
        cwd: TEST_PROJECT_DIR,
        env: {
          ...process.env,
          VIRTUAL_ENV: path.join(TEST_PROJECT_DIR, ".venv"),
          PATH: `${path.join(TEST_PROJECT_DIR, ".venv", "bin")}:${process.env.PATH}`,
          // Set dummy credentials for S3 engine testing
          TEST_S3_AWS_ACCESS_KEY_ID: "test-s3-access-key-id",
          TEST_S3_AWS_SECRET_ACCESS_KEY: "test-s3-secret-access-key",
          // Also set S3Queue env vars so those tests don't fail
          TEST_AWS_ACCESS_KEY_ID: "test-access-key-id",
          TEST_AWS_SECRET_ACCESS_KEY: "test-secret-access-key",
        },
      });

      await waitForServerStart(
        devProcess,
        TIMEOUTS.SERVER_STARTUP_MS,
        "started successfully",
        "http://localhost:4000",
      );
    });

    after(async function () {
      this.timeout(TIMEOUTS.CLEANUP_MS);
      await stopDevProcess(devProcess);
      removeTestProject(TEST_PROJECT_DIR);
    });

    it("should start successfully and resolve S3 engine environment variables correctly", async function () {
      this.timeout(TIMEOUTS.TEST_SETUP_MS);

      // If we got here, the server started successfully with the environment variables set
      // This verifies that:
      // 1. moose_runtime_env.get() markers were correctly generated by the Python library
      // 2. The Rust CLI successfully resolved the markers from environment variables
      // 3. The resolved values were used to create the S3 engine table without errors
      expect(devProcess?.killed).to.be.false;
    });
  });

  describe("Without Environment Variables", () => {
    let devProcess: ChildProcess | null = null;

    it("should fail to start when required S3 engine environment variables are missing", async function () {
      this.timeout(TIMEOUTS.TEST_SETUP_MS);

      // Create temporary directory
      const TEST_PROJECT_DIR = createTempTestDirectory("py-s3-engine-unset");

      // Setup Python project
      await setupPythonProject(
        TEST_PROJECT_DIR,
        TEMPLATE_NAMES.PYTHON_TESTS,
        CLI_PATH,
        MOOSE_PY_LIB_PATH,
        APP_NAMES.PYTHON_TESTS,
      );

      // Start dev server WITHOUT the S3 engine environment variables set
      // Only set S3Queue env vars to isolate S3 engine failures
      devProcess = spawn(CLI_PATH, ["dev"], {
        stdio: "pipe",
        cwd: TEST_PROJECT_DIR,
        env: {
          ...process.env,
          VIRTUAL_ENV: path.join(TEST_PROJECT_DIR, ".venv"),
          PATH: `${path.join(TEST_PROJECT_DIR, ".venv", "bin")}:${process.env.PATH}`,
          // Set S3Queue env vars so those tests don't fail
          TEST_AWS_ACCESS_KEY_ID: "test-access-key-id",
          TEST_AWS_SECRET_ACCESS_KEY: "test-secret-access-key",
          // Explicitly unset S3 engine env vars
          TEST_S3_AWS_ACCESS_KEY_ID: undefined,
          TEST_S3_AWS_SECRET_ACCESS_KEY: undefined,
        },
      });

      let stdoutOutput = "";
      let stderrOutput = "";

      devProcess.stdout?.on("data", (data) => {
        stdoutOutput += data.toString();
      });

      devProcess.stderr?.on("data", (data) => {
        stderrOutput += data.toString();
      });

      const exitPromise = new Promise<number>((resolve, reject) => {
        devProcess!.on("exit", (code) => {
          resolve(code || 0);
        });

        // Add timeout in case process doesn't exit
        setTimeout(() => {
          reject(new Error("Process did not exit within expected time"));
        }, TIMEOUTS.SERVER_STARTUP_MS);
      });

      try {
        const exitCode = await exitPromise;

        // Process should exit with non-zero code
        expect(exitCode).to.not.equal(0);

        // Combine stdout and stderr for checking
        const output = stdoutOutput + stderrOutput;

        // Log captured output for debugging
        console.log("=== Captured stdout ===");
        console.log(stdoutOutput);
        console.log("=== Captured stderr ===");
        console.log(stderrOutput);

        // Verify error message includes table name, field name, and env var name
        expect(output).to.include("S3WithSecrets");
        expect(output).to.match(/awsAccessKeyId|awsSecretAccessKey/);
        expect(output).to.match(
          /TEST_S3_AWS_ACCESS_KEY_ID|TEST_S3_AWS_SECRET_ACCESS_KEY/,
        );

        console.log("Process exited with expected error message");
      } catch (error) {
        // Log captured output even on timeout
        console.log("=== Process timed out - captured stdout ===");
        console.log(stdoutOutput);
        console.log("=== Process timed out - captured stderr ===");
        console.log(stderrOutput);
        throw error;
      } finally {
        // Cleanup
        if (devProcess && !devProcess.killed) {
          devProcess.kill("SIGKILL");
        }
        removeTestProject(TEST_PROJECT_DIR);
      }
    });
  });
});
