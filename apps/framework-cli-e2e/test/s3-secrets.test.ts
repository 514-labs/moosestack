/// <reference types="node" />
/// <reference types="mocha" />
/// <reference types="chai" />
/**
 * End-to-end tests for S3Queue runtime environment variable resolution
 *
 * These tests verify that:
 * 1. mooseRuntimeEnv markers are correctly generated by TypeScript/Python libraries
 * 2. Rust CLI correctly resolves the markers from environment variables at startup
 * 3. Error messages include field names when environment variables are missing
 * 4. Tables without credentials (public buckets) work correctly
 * 5. System fails startup with clear error messages when env vars are missing
 * 6. Resolved environment variable values are correctly used in infrastructure
 */

import { spawn, ChildProcess } from "child_process";
import { expect } from "chai";
import * as path from "path";

// Import test utilities
import { TIMEOUTS, TEMPLATE_NAMES, APP_NAMES } from "./constants";

import {
  stopDevProcess,
  waitForServerStart,
  createTempTestDirectory,
  setupTypeScriptProject,
  setupPythonProject,
  removeTestProject,
  cleanupDocker,
} from "./utils";

const CLI_PATH = path.resolve(__dirname, "../../../target/debug/moose-cli");
const MOOSE_LIB_PATH = path.resolve(
  __dirname,
  "../../../packages/ts-moose-lib",
);
const MOOSE_PY_LIB_PATH = path.resolve(
  __dirname,
  "../../../packages/py-moose-lib",
);

describe("typescript template tests - S3Queue Runtime Environment Variable Resolution", () => {
  describe("With Environment Variables", () => {
    let devProcess: ChildProcess | null = null;
    let TEST_PROJECT_DIR: string;

    before(async function () {
      this.timeout(TIMEOUTS.TEST_SETUP_MS);

      // Create temporary directory
      TEST_PROJECT_DIR = createTempTestDirectory("ts-s3-secrets-set");

      // Setup TypeScript project
      await setupTypeScriptProject(
        TEST_PROJECT_DIR,
        TEMPLATE_NAMES.TYPESCRIPT_TESTS,
        CLI_PATH,
        MOOSE_LIB_PATH,
        APP_NAMES.TYPESCRIPT_TESTS,
        "npm",
      );

      // Start dev server WITH the required environment variables set
      devProcess = spawn(CLI_PATH, ["dev"], {
        stdio: "pipe",
        cwd: TEST_PROJECT_DIR,
        env: {
          ...process.env,
          // Set dummy credentials for both S3Queue and S3 engine testing
          // Both use the same env vars for consistency
          TEST_AWS_ACCESS_KEY_ID: "test-access-key-id",
          TEST_AWS_SECRET_ACCESS_KEY: "test-secret-access-key",
        },
      });

      await waitForServerStart(
        devProcess,
        TIMEOUTS.SERVER_STARTUP_MS,
        "started successfully",
        "http://localhost:4000",
      );
    });

    after(async function () {
      this.timeout(TIMEOUTS.CLEANUP_MS);
      try {
        await stopDevProcess(devProcess);
        await cleanupDocker(TEST_PROJECT_DIR, APP_NAMES.TYPESCRIPT_TESTS);
        removeTestProject(TEST_PROJECT_DIR);
      } catch (error) {
        console.error("Error during cleanup:", error);
        // Force cleanup even if some steps fail
        try {
          if (devProcess && !devProcess.killed) {
            devProcess.kill("SIGKILL");
          }
        } catch (killError) {
          console.error("Error killing process:", killError);
        }
        removeTestProject(TEST_PROJECT_DIR);
      }
    });

    it("should start successfully and resolve environment variables correctly", async function () {
      this.timeout(TIMEOUTS.TEST_SETUP_MS);

      // If we got here, the server started successfully with the environment variables set
      // This verifies that:
      // 1. mooseRuntimeEnv.get() markers were correctly generated by the TypeScript library
      // 2. The Rust CLI successfully resolved the markers from environment variables
      // 3. The resolved values were used to create the S3Queue table without errors
      //
      // If the environment variables were not resolved correctly, the server would have
      // failed to start with an error message containing the table name and field name.
      expect(devProcess?.killed).to.be.false;
    });
  });

  describe("Without Environment Variables", () => {
    let devProcess: ChildProcess | null = null;
    let TEST_PROJECT_DIR: string;

    it("should fail startup with clear error message when environment variables are missing", async function () {
      this.timeout(TIMEOUTS.TEST_SETUP_MS);

      // Create temporary directory
      TEST_PROJECT_DIR = createTempTestDirectory("ts-s3-secrets-missing");

      // Setup TypeScript project
      await setupTypeScriptProject(
        TEST_PROJECT_DIR,
        TEMPLATE_NAMES.TYPESCRIPT_TESTS,
        CLI_PATH,
        MOOSE_LIB_PATH,
        APP_NAMES.TYPESCRIPT_TESTS,
        "npm",
      );

      // Start dev server WITHOUT the required environment variables
      // Create a clean environment without the test credentials
      const envWithoutCredentials = { ...process.env };
      delete envWithoutCredentials.TEST_AWS_ACCESS_KEY_ID;
      delete envWithoutCredentials.TEST_AWS_SECRET_ACCESS_KEY;

      devProcess = spawn(CLI_PATH, ["dev"], {
        stdio: "pipe",
        cwd: TEST_PROJECT_DIR,
        env: envWithoutCredentials,
      });

      // Capture both stdout and stderr to check for error messages
      let stdoutOutput = "";
      let stderrOutput = "";

      devProcess.stdout?.on("data", (data) => {
        stdoutOutput += data.toString();
      });

      devProcess.stderr?.on("data", (data) => {
        stderrOutput += data.toString();
      });

      // Wait for the process to exit with a timeout
      const exitPromise = new Promise<number>((resolve, reject) => {
        const timeout = setTimeout(() => {
          devProcess?.kill("SIGKILL");
          reject(new Error("Process did not exit within timeout"));
        }, 30000); // 30 second timeout

        devProcess!.on("exit", (code) => {
          clearTimeout(timeout);
          resolve(code || 0);
        });
      });

      try {
        const exitCode = await exitPromise;

        // Process should exit with non-zero code
        expect(exitCode).to.not.equal(0);

        // Combine stdout and stderr for checking
        const output = stdoutOutput + stderrOutput;

        // Log captured output for debugging
        console.log("=== Captured stdout ===");
        console.log(stdoutOutput);
        console.log("=== Captured stderr ===");
        console.log(stderrOutput);

        // Verify error message includes table name, field name, and env var name
        expect(output).to.include("S3QueueWithSecrets");
        expect(output).to.match(/awsAccessKeyId|awsSecretAccessKey/);
        expect(output).to.match(
          /TEST_AWS_ACCESS_KEY_ID|TEST_AWS_SECRET_ACCESS_KEY/,
        );

        console.log("Process exited with expected error message");
      } catch (error) {
        // Log captured output even on timeout
        console.log("=== Process timed out - captured stdout ===");
        console.log(stdoutOutput);
        console.log("=== Process timed out - captured stderr ===");
        console.log(stderrOutput);
        throw error;
      } finally {
        // Cleanup
        if (devProcess && !devProcess.killed) {
          devProcess.kill("SIGKILL");
        }
        removeTestProject(TEST_PROJECT_DIR);
      }
    });
  });
});

describe("python template tests - S3Queue Runtime Environment Variable Resolution", () => {
  describe("With Environment Variables", () => {
    let devProcess: ChildProcess | null = null;
    let TEST_PROJECT_DIR: string;

    before(async function () {
      this.timeout(TIMEOUTS.TEST_SETUP_MS);

      // Create temporary directory
      TEST_PROJECT_DIR = createTempTestDirectory("py-s3-secrets-set");

      // Setup Python project
      await setupPythonProject(
        TEST_PROJECT_DIR,
        TEMPLATE_NAMES.PYTHON_TESTS,
        CLI_PATH,
        MOOSE_PY_LIB_PATH,
        APP_NAMES.PYTHON_TESTS,
      );

      // Start dev server WITH the required environment variables set
      devProcess = spawn(CLI_PATH, ["dev"], {
        stdio: "pipe",
        cwd: TEST_PROJECT_DIR,
        env: {
          ...process.env,
          VIRTUAL_ENV: path.join(TEST_PROJECT_DIR, ".venv"),
          PATH: `${path.join(TEST_PROJECT_DIR, ".venv", "bin")}:${process.env.PATH}`,
          // Set dummy credentials for both S3Queue and S3 engine testing
          // Both use the same env vars for consistency
          TEST_AWS_ACCESS_KEY_ID: "test-access-key-id",
          TEST_AWS_SECRET_ACCESS_KEY: "test-secret-access-key",
        },
      });

      await waitForServerStart(
        devProcess,
        TIMEOUTS.SERVER_STARTUP_MS,
        "started successfully",
        "http://localhost:4000",
      );
    });

    after(async function () {
      this.timeout(TIMEOUTS.CLEANUP_MS);
      try {
        await stopDevProcess(devProcess);
        await cleanupDocker(TEST_PROJECT_DIR, APP_NAMES.PYTHON_TESTS);
        removeTestProject(TEST_PROJECT_DIR);
      } catch (error) {
        console.error("Error during cleanup:", error);
        // Force cleanup even if some steps fail
        try {
          if (devProcess && !devProcess.killed) {
            devProcess.kill("SIGKILL");
          }
        } catch (killError) {
          console.error("Error killing process:", killError);
        }
        removeTestProject(TEST_PROJECT_DIR);
      }
    });

    it("should start successfully and resolve environment variables correctly", async function () {
      this.timeout(TIMEOUTS.TEST_SETUP_MS);

      // If we got here, the server started successfully with the environment variables set
      // This verifies that:
      // 1. moose_runtime_env.get() markers were correctly generated by the Python library
      // 2. The Rust CLI successfully resolved the markers from environment variables
      // 3. The resolved values were used to create the S3Queue table without errors
      //
      // If the environment variables were not resolved correctly, the server would have
      // failed to start with an error message containing the table name and field name.
      expect(devProcess?.killed).to.be.false;
    });
  });

  describe("Without Environment Variables", () => {
    let devProcess: ChildProcess | null = null;
    let TEST_PROJECT_DIR: string;

    it("should fail startup with clear error message when environment variables are missing", async function () {
      this.timeout(TIMEOUTS.TEST_SETUP_MS);

      // Create temporary directory
      TEST_PROJECT_DIR = createTempTestDirectory("py-s3-secrets-missing");

      // Setup Python project
      await setupPythonProject(
        TEST_PROJECT_DIR,
        TEMPLATE_NAMES.PYTHON_TESTS,
        CLI_PATH,
        MOOSE_PY_LIB_PATH,
        APP_NAMES.PYTHON_TESTS,
      );

      // Start dev server WITHOUT the required environment variables
      // Create a clean environment without the test credentials
      const envWithoutCredentials: NodeJS.ProcessEnv = {
        ...process.env,
        VIRTUAL_ENV: path.join(TEST_PROJECT_DIR, ".venv"),
        PATH: `${path.join(TEST_PROJECT_DIR, ".venv", "bin")}:${process.env.PATH}`,
      };
      delete envWithoutCredentials.TEST_AWS_ACCESS_KEY_ID;
      delete envWithoutCredentials.TEST_AWS_SECRET_ACCESS_KEY;

      devProcess = spawn(CLI_PATH, ["dev"], {
        stdio: "pipe",
        cwd: TEST_PROJECT_DIR,
        env: envWithoutCredentials,
      });

      // Capture both stdout and stderr to check for error messages
      let stdoutOutput = "";
      let stderrOutput = "";

      devProcess.stdout?.on("data", (data) => {
        stdoutOutput += data.toString();
      });

      devProcess.stderr?.on("data", (data) => {
        stderrOutput += data.toString();
      });

      // Wait for the process to exit with a timeout
      const exitPromise = new Promise<number>((resolve, reject) => {
        const timeout = setTimeout(() => {
          devProcess?.kill("SIGKILL");
          reject(new Error("Process did not exit within timeout"));
        }, 30000); // 30 second timeout

        devProcess!.on("exit", (code) => {
          clearTimeout(timeout);
          resolve(code || 0);
        });
      });

      try {
        const exitCode = await exitPromise;

        // Process should exit with non-zero code
        expect(exitCode).to.not.equal(0);

        // Combine stdout and stderr for checking
        const output = stdoutOutput + stderrOutput;

        // Log captured output for debugging
        console.log("=== Captured stdout ===");
        console.log(stdoutOutput);
        console.log("=== Captured stderr ===");
        console.log(stderrOutput);

        // Verify error message includes table name, field name, and env var name
        expect(output).to.include("S3QueueWithSecrets");
        expect(output).to.match(/awsAccessKeyId|awsSecretAccessKey/);
        expect(output).to.match(
          /TEST_AWS_ACCESS_KEY_ID|TEST_AWS_SECRET_ACCESS_KEY/,
        );

        console.log("Process exited with expected error message");
      } catch (error) {
        // Log captured output even on timeout
        console.log("=== Process timed out - captured stdout ===");
        console.log(stdoutOutput);
        console.log("=== Process timed out - captured stderr ===");
        console.log(stderrOutput);
        throw error;
      } finally {
        // Cleanup
        if (devProcess && !devProcess.killed) {
          devProcess.kill("SIGKILL");
        }
        removeTestProject(TEST_PROJECT_DIR);
      }
    });
  });
});
