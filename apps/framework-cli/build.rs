use regex::Regex;
use serde::{Deserialize, Serialize};
use std::fs;
use std::io::{Result, Write};
use std::path::Path;
use walkdir::WalkDir;

#[derive(Debug, Serialize, Deserialize)]
struct DocMetadata {
    title: String,
    description: String,
    priority: f32,
    category: String,
    language: String,
}

struct DocResource {
    relative_path: String,
    metadata: DocMetadata,
}

fn main() -> Result<()> {
    println!("cargo:rerun-if-changed=../../packages/protobuf");
    println!("cargo:rerun-if-changed=../framework-docs/llm-docs");

    // Pass PostHog API key from environment variable at build time
    if let Ok(posthog_api_key) = std::env::var("POSTHOG_API_KEY") {
        println!("cargo:rustc-env=POSTHOG_API_KEY={posthog_api_key}");
    }
    println!("cargo:rerun-if-env-changed=POSTHOG_API_KEY");

    // Generate protobuf code
    std::fs::create_dir_all("src/proto/")?;
    protobuf_codegen::Codegen::new()
        .pure()
        .includes(["../../packages/protobuf"])
        .input("../../packages/protobuf/infrastructure_map.proto")
        .out_dir("src/proto/")
        .run_from_script();

    // Generate embedded documentation
    generate_embedded_docs()?;

    Ok(())
}

fn generate_embedded_docs() -> Result<()> {
    // Try multiple possible paths since cargo might run from different directories
    let possible_paths = vec![
        Path::new("../framework-docs/llm-docs"),
        Path::new("./apps/framework-docs/llm-docs"),
        Path::new("../../apps/framework-docs/llm-docs"),
    ];

    let docs_dir = possible_paths.iter().find(|p| p.exists()).ok_or_else(|| {
        std::io::Error::new(
            std::io::ErrorKind::NotFound,
            format!(
                "Could not find llm-docs directory. Tried: {:?}. Current dir: {:?}",
                possible_paths,
                std::env::current_dir()
            ),
        )
    })?;

    eprintln!("[build] Using docs_dir: {:?}", docs_dir);
    eprintln!("[build] Current directory: {:?}", std::env::current_dir()?);

    if !docs_dir.exists() {
        eprintln!(
            "[build] WARNING: llm-docs directory not found at {:?}",
            docs_dir
        );
        // Create empty generated file
        let out_path = Path::new("src/mcp/generated_docs.rs");
        std::fs::create_dir_all("src/mcp")?;
        let mut file = fs::File::create(out_path)?;
        writeln!(file, "// No documentation files found")?;
        writeln!(file, "pub const EMBEDDED_DOCS: &[EmbeddedDoc] = &[];")?;
        return Ok(());
    }

    // Discover all markdown files
    let mut docs = Vec::new();
    let mut processed_count = 0;
    let mut failed_count = 0;

    for entry in WalkDir::new(docs_dir)
        .follow_links(true)
        .into_iter()
        .filter_map(|e| e.ok())
    {
        let path = entry.path();
        if path.extension().and_then(|s| s.to_str()) == Some("md") {
            processed_count += 1;

            if let Ok(relative_path) = path.strip_prefix(docs_dir) {
                let relative_str = relative_path.to_string_lossy().to_string();

                // Skip the index file
                if relative_str == "llms.txt" {
                    continue;
                }

                // Parse frontmatter
                match parse_frontmatter(path) {
                    Ok(metadata) => {
                        docs.push(DocResource {
                            relative_path: relative_str,
                            metadata,
                        });
                    }
                    Err(e) => {
                        eprintln!("[build] Failed to parse {:?}: {}", path, e);
                        failed_count += 1;
                    }
                }
            }
        }
    }

    eprintln!(
        "[build] Processed {} markdown files, {} succeeded, {} failed",
        processed_count,
        docs.len(),
        failed_count
    );

    // Sort by priority (highest first)
    docs.sort_by(|a, b| {
        b.metadata
            .priority
            .partial_cmp(&a.metadata.priority)
            .unwrap_or(std::cmp::Ordering::Equal)
    });

    // Generate Rust code
    let out_path = Path::new("src/mcp/generated_docs.rs");
    std::fs::create_dir_all("src/mcp")?;
    let mut file = fs::File::create(out_path)?;

    writeln!(file, "// This file is automatically generated by build.rs")?;
    writeln!(file, "// Do not edit manually\n")?;
    writeln!(file, "#[derive(Debug, Clone)]")?;
    writeln!(file, "#[allow(dead_code)]")?;
    writeln!(file, "pub struct EmbeddedDoc {{")?;
    writeln!(file, "    pub uri: &'static str,")?;
    writeln!(file, "    pub name: &'static str,")?;
    writeln!(file, "    pub title: &'static str,")?;
    writeln!(file, "    pub description: &'static str,")?;
    writeln!(file, "    pub content: &'static str,")?;
    writeln!(file, "    pub priority: f32,")?;
    writeln!(file, "    pub category: &'static str,")?;
    writeln!(file, "    pub language: &'static str,")?;
    writeln!(file, "}}\n")?;

    writeln!(file, "pub const EMBEDDED_DOCS: &[EmbeddedDoc] = &[")?;

    for doc in &docs {
        let uri = format!(
            "moose://docs/{}",
            doc.relative_path.trim_end_matches(".md").replace('\\', "/")
        );
        let name = doc.relative_path.trim_end_matches(".md").replace('\\', "/");

        // Calculate path relative to the generated file location (src/mcp/)
        // Generated file: apps/framework-cli/src/mcp/generated_docs.rs
        // Docs location: apps/framework-docs/llm-docs/...
        // Relative path: ../../../framework-docs/llm-docs/...
        let relative_include_path =
            format!("../../../framework-docs/llm-docs/{}", doc.relative_path);

        writeln!(file, "    EmbeddedDoc {{")?;
        writeln!(file, "        uri: {:?},", uri)?;
        writeln!(file, "        name: {:?},", name)?;
        writeln!(file, "        title: {:?},", doc.metadata.title)?;
        writeln!(file, "        description: {:?},", doc.metadata.description)?;
        writeln!(
            file,
            "        content: include_str!({:?}),",
            relative_include_path
        )?;
        writeln!(file, "        priority: {},", doc.metadata.priority)?;
        writeln!(file, "        category: {:?},", doc.metadata.category)?;
        writeln!(file, "        language: {:?},", doc.metadata.language)?;
        writeln!(file, "    }},")?;
    }

    writeln!(file, "];")?;

    eprintln!(
        "[build] Generated {} embedded documentation files",
        docs.len()
    );

    Ok(())
}

fn parse_frontmatter(path: &Path) -> Result<DocMetadata> {
    let content = fs::read_to_string(path)?;

    // Regex to match YAML frontmatter between --- delimiters (with multiline support)
    let frontmatter_re = Regex::new(r"(?s)^---\s*\n(.*?)\n---\s*\n").unwrap();

    if let Some(captures) = frontmatter_re.captures(&content) {
        let yaml_content = captures.get(1).map_or("", |m| m.as_str());

        match serde_yaml::from_str::<DocMetadata>(yaml_content) {
            Ok(metadata) => Ok(metadata),
            Err(e) => Err(std::io::Error::new(
                std::io::ErrorKind::InvalidData,
                format!("Failed to parse YAML in {:?}: {}", path, e),
            )),
        }
    } else {
        Err(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            "No frontmatter found",
        ))
    }
}
