# This file was auto-generated by the framework. You can add data models or change the existing ones

from moose_lib import Point, Ring, LineString, MultiLineString, Polygon, MultiPolygon
from moose_lib import Key, IngestPipeline, IngestPipelineConfig, StringToEnumMixin, clickhouse_default, OlapTable, OlapConfig, MergeTreeEngine, ReplacingMergeTreeEngine, AggregatingMergeTreeEngine, simple_aggregated, ClickhouseSize
from datetime import datetime, date
from typing import Optional, Annotated, Any
from pydantic import BaseModel, BeforeValidator, ConfigDict
from moose_lib.data_models import ClickHouseJson
from enum import IntEnum, auto



class Baz(StringToEnumMixin, IntEnum):
    QUX = auto()
    QUUX = auto()


class Foo(BaseModel):
    primary_key: Key[str]
    timestamp: float
    baz: Baz
    optional_text: Optional[str] = None


class Bar(BaseModel):
    primary_key: Key[str]
    utc_timestamp: datetime
    baz: Baz
    has_text: bool
    text_length: int


fooModel = IngestPipeline[Foo]("Foo", IngestPipelineConfig(
    ingest_api=True,
    stream=True,
    table=False,
    dead_letter_queue=True
))

barModel = IngestPipeline[Bar]("Bar", IngestPipelineConfig(
    ingest_api=False,
    stream=True,
    table=True,
    dead_letter_queue=True
))

# =======Comprehensive Type Testing Data Models=========

from typing import List, Tuple
from pydantic import Field

# Test 1: Basic primitive types
class BasicTypes(BaseModel):
    id: Key[str]
    timestamp: datetime
    string_field: str
    number_field: float
    boolean_field: bool
    optional_string: Optional[str] = None
    nullable_number: Optional[float] = None

# Test 2: Simple arrays of primitives
class SimpleArrays(BaseModel):
    id: Key[str]
    timestamp: datetime
    string_array: List[str]
    number_array: List[float]
    boolean_array: List[bool]
    optional_string_array: Optional[List[str]] = None
    mixed_optional_array: Optional[List[str]] = None

# Test 3: Nested objects
class Coordinates(BaseModel):
    lat: float
    lng: float

class Address(BaseModel):
    street: str
    city: str
    coordinates: Coordinates

class Settings(BaseModel):
    theme: str
    notifications: bool

class Config(BaseModel):
    enabled: bool
    settings: Settings

class Metadata(BaseModel):
    tags: List[str]
    priority: int
    config: Config

class NestedObjects(BaseModel):
    id: Key[str]
    timestamp: datetime
    address: Address
    metadata: Metadata

# Test 4: Arrays of objects
class User(BaseModel):
    name: str
    age: int
    active: bool

class TransactionMetadata(BaseModel):
    category: str
    tags: List[str]

class Transaction(BaseModel):
    id: str
    amount: float
    currency: str
    metadata: TransactionMetadata

class ArraysOfObjects(BaseModel):
    id: Key[str]
    timestamp: datetime
    users: List[User]
    transactions: List[Transaction]

# Test 5: Deeply nested arrays (main focus for ENG-875) - ClickHouse compatible
class SimplifiedItem(BaseModel):
    name: str
    values: List[float]
    data: List[str]
    # Flattened structure instead of deeply nested objects
    metric_names: List[str]
    metric_values: List[float]

class ComplexNestedCategory(BaseModel):
    category: str
    items: List[SimplifiedItem]

class DeeplyNestedArrays(BaseModel):
    id: Key[str]
    timestamp: datetime
    # Level 1: Array of arrays (safe)
    matrix_2d: List[List[float]]
    # Level 2: Array of arrays of arrays (safe)
    matrix_3d: List[List[List[float]]]
    # Level 3: Array of arrays of arrays of arrays (pushing limits but should work)
    matrix_4d: List[List[List[List[float]]]]
    # Simplified nested: Reduce nesting depth to avoid ClickHouse issues
    complex_nested: List[ComplexNestedCategory]

# Test 6: Mixed complex types (ClickHouse-safe)
class ClickEvent(BaseModel):
    type: str = Field(default="click")
    target: str
    coordinate_x: float
    coordinate_y: float

class FlattenedData(BaseModel):
    required: str
    optional_data: List[str]  # Flattened, no nested optionals
    tags: List[str]
    values: List[float]

class Column(BaseModel):
    col: int
    values: List[str]

class ComplexMatrixRow(BaseModel):
    row: int
    columns: List[Column]

class MixedComplexTypes(BaseModel):
    id: Key[str]
    timestamp: datetime
    # Arrays with click events (safe)
    events: List[ClickEvent]
    # Flattened optional structures (avoid nested optionals)
    nested_data: List[FlattenedData]
    # Multi-dimensional with objects (safe)
    complex_matrix: List[ComplexMatrixRow]

# Test 7: Edge cases and boundary conditions (ClickHouse-compatible)
class EmptyObject(BaseModel):
    id: str

class Property(BaseModel):
    key: str
    value: str
    tags: List[str]

class Metric(BaseModel):
    name: str
    values: List[float]

class ModerateLevel2(BaseModel):
    data: List[str]
    values: List[float]

class ModerateLevel1(BaseModel):
    level2: List[ModerateLevel2]

class ModerateNesting(BaseModel):
    level1: List[ModerateLevel1]

class SimplifiedComplexItem(BaseModel):
    id: str
    properties: List[Property]
    metrics: List[Metric]

class EdgeCases(BaseModel):
    id: Key[str]
    timestamp: datetime
    # Empty arrays (safe)
    empty_string_array: List[str]
    empty_object_array: List[EmptyObject]
    # Simplified nullable structures (avoid nested nullables)
    nullable_string: Optional[str] = None
    nullable_number: Optional[float] = None
    # Moderate depth nesting (3 levels max for safety)
    moderate_nesting: ModerateNesting
    # Simplified complex arrays
    complex_array: List[SimplifiedComplexItem]

# =======JSON Types Test=========
class JsonInner(BaseModel):
    name: str
    count: int

class JsonTest(BaseModel):
    model_config = ConfigDict(extra='allow')
    id: Key[str]
    timestamp: datetime
    # Test JSON with full configuration (max_dynamic_paths, max_dynamic_types, skip_paths, skip_regexps)
    payload_with_config: Annotated[JsonInner, ClickHouseJson(
        max_dynamic_paths=256,
        max_dynamic_types=16,
        skip_paths=("skip.me",),
        skip_regexps=(r"^tmp\\.",)
    )]
    # Test JSON with paths but without configuration
    payload_basic: Annotated[JsonInner, ClickHouseJson()]

# =======Pipeline Configurations for Test Models=========

basic_types_model = IngestPipeline[BasicTypes]("BasicTypes", IngestPipelineConfig(
    ingest_api=True,
    stream=True,
    table=True,
    dead_letter_queue=True
))

simple_arrays_model = IngestPipeline[SimpleArrays]("SimpleArrays", IngestPipelineConfig(
    ingest_api=True,
    stream=True,
    table=True,
    dead_letter_queue=True
))

nested_objects_model = IngestPipeline[NestedObjects]("NestedObjects", IngestPipelineConfig(
    ingest_api=True,
    stream=True,
    table=True,
    dead_letter_queue=True
))

arrays_of_objects_model = IngestPipeline[ArraysOfObjects]("ArraysOfObjects", IngestPipelineConfig(
    ingest_api=True,
    stream=True,
    table=True,
    dead_letter_queue=True
))

deeply_nested_arrays_model = IngestPipeline[DeeplyNestedArrays]("DeeplyNestedArrays", IngestPipelineConfig(
    ingest_api=True,
    stream=True,
    table=True,
    dead_letter_queue=True
))

mixed_complex_types_model = IngestPipeline[MixedComplexTypes]("MixedComplexTypes", IngestPipelineConfig(
    ingest_api=True,
    stream=True,
    table=True,
    dead_letter_queue=True
))

edge_cases_model = IngestPipeline[EdgeCases]("EdgeCases", IngestPipelineConfig(
    ingest_api=True,
    stream=True,
    table=True,
    dead_letter_queue=True
))

json_test_model = IngestPipeline[JsonTest]("JsonTest", IngestPipelineConfig(
    ingest_api=True,
    stream=True,
    table=True,
    dead_letter_queue=True
))

# =======Optional Nested Fields with ClickHouse Defaults Test=========

# Test class with optional nested fields and ClickHouse defaults
class TestNested(BaseModel):
    name: Optional[str] = None
    age: Optional[float] = None

class OptionalNestedTest(BaseModel):
    id: Key[str]
    timestamp: datetime
    nested: List[TestNested]
    other: Annotated[str, clickhouse_default("")] = ""

optional_nested_test_model = IngestPipeline[OptionalNestedTest]("OptionalNestedTest", IngestPipelineConfig(
    ingest_api=True,
    stream=True,
    table=True,
    dead_letter_queue=True
))

# =======Geometry Types=========

class GeoTypes(BaseModel):
    id: Key[str]
    timestamp: datetime
    point: Point
    ring: Ring
    line_string: LineString
    multi_line_string: MultiLineString
    polygon: Polygon
    multi_polygon: MultiPolygon


geo_types_model = IngestPipeline[GeoTypes]("GeoTypes", IngestPipelineConfig(
    ingest_api=True,
    stream=True,
    table=True,
    dead_letter_queue=True
))

# =======Versioned OlapTables Test=========
# Test versioned OlapTables - same name, different versions
# This demonstrates the OlapTable versioning functionality

class UserEventV1(BaseModel):
    """Version 1.0 of user events - basic structure."""
    user_id: Key[str]
    event_type: str
    timestamp: float
    metadata: Optional[str] = None

class UserEventV2(BaseModel):
    """Version 2.0 of user events - enhanced with session tracking."""
    user_id: Key[str]
    event_type: str
    timestamp: float
    metadata: Optional[str] = None
    session_id: str
    user_agent: Optional[str] = None

# Version 1.0 - MergeTree engine
user_events_v1 = OlapTable[UserEventV1](
    "UserEvents",
    OlapConfig(
        version="1.0",
        engine=MergeTreeEngine(),
        order_by_fields=["user_id", "timestamp"]
    )
)

# Version 2.0 - ReplacingMergeTree engine with enhanced schema
user_events_v2 = OlapTable[UserEventV2](
    "UserEvents",
    OlapConfig(
        version="2.0",
        engine=ReplacingMergeTreeEngine(),
        order_by_fields=["user_id", "session_id", "timestamp"]
    )
)

# =======SimpleAggregateFunction Test=========
# Test SimpleAggregateFunction support for aggregated metrics
# This demonstrates using SimpleAggregateFunction with AggregatingMergeTree

class SimpleAggTest(BaseModel):
    """Test model for SimpleAggregateFunction support."""
    date_stamp: Key[Annotated[date, ClickhouseSize(2)]]
    table_name: Key[str]
    row_count: simple_aggregated('sum', Annotated[int, "uint64"])
    max_value: simple_aggregated('max', int)
    min_value: simple_aggregated('min', int)
    last_updated: simple_aggregated('anyLast', datetime)

simple_agg_test_table = OlapTable[SimpleAggTest](
    "SimpleAggTest",
    OlapConfig(
        engine=AggregatingMergeTreeEngine(),
        order_by_fields=["date_stamp", "table_name"]
    )
)

# =======Index Extraction Test Table=======
class IndexTest(BaseModel):
    u64: Key[Annotated[int, "uint64"]]
    i32: Annotated[int, "i32"]
    s: str

index_test_table = OlapTable[IndexTest](
    "IndexTest",
    OlapConfig(
        engine=MergeTreeEngine(),
        order_by_fields=["u64"],
        indexes=[
            OlapConfig.TableIndex(name="idx1", expression="u64", type="bloom_filter", arguments=[], granularity=3),
            OlapConfig.TableIndex(name="idx2", expression="u64 * i32", type="minmax", arguments=[], granularity=3),
            OlapConfig.TableIndex(name="idx3", expression="u64 * length(s)", type="set", arguments=["1000"], granularity=4),
            OlapConfig.TableIndex(name="idx4", expression="(u64, i32)", type="MinMax", arguments=[], granularity=1),
            OlapConfig.TableIndex(name="idx5", expression="(u64, i32)", type="minmax", arguments=[], granularity=1),
            OlapConfig.TableIndex(name="idx6", expression="toString(i32)", type="ngrambf_v1", arguments=["2", "256", "1", "123"], granularity=1),
            OlapConfig.TableIndex(name="idx7", expression="s", type="nGraMbf_v1", arguments=["3", "256", "1", "123"], granularity=1),
        ],
    ),
)

# =======Real-World Production Patterns (District Cannabis Inspired)=========

# Test 8: Complex discount structure with mixed nullability
class DiscountInfo(BaseModel):
    discount_id: Optional[int] = None
    discount_name: Optional[str] = None  # Explicit null
    discount_reason: Optional[str] = None
    amount: float  # Required field

# Test 9: Transaction item with complex nested structure
class ProductItem(BaseModel):
    product_id: Optional[int] = None
    product_name: Optional[str] = None
    quantity: float
    unit_price: float
    unit_cost: Optional[float] = None
    package_id: Optional[str] = None

# Test 10: Complex transaction with multiple array types and ReplacingMergeTree
class ComplexTransaction(BaseModel):
    transaction_id: Key[int]  # Primary key
    customer_id: Optional[int] = None
    transaction_date: datetime
    location: str  # Part of order by
    subtotal: float
    tax: float
    total: float
    # Multiple complex array fields
    items: List[ProductItem]
    discounts: List[DiscountInfo]
    order_ids: List[int]  # Simple array
    # Mixed nullability patterns
    tip_amount: Optional[float] = None
    invoice_number: Optional[str] = None
    terminal_name: Optional[str] = None  # Optional without explicit null
    # Boolean fields
    is_void: bool
    is_tax_inclusive: Optional[bool] = None

# Test 11: Base type pattern with extension (common pattern)
class BaseProduct(BaseModel):
    product_id: Optional[int] = None
    product_name: Optional[str] = None
    description: Optional[str] = None
    category_id: Optional[int] = None
    tags: List[str]  # Remove optional - arrays cannot be nullable in ClickHouse

class ProductWithLocation(BaseModel):
    # Simulate Omit pattern by redefining fields
    product_id: int  # Make required (was optional in base)
    product_name: Optional[str] = None
    description: Optional[str] = None
    category_id: Optional[int] = None
    tags: List[str]  # Remove optional - arrays cannot be nullable in ClickHouse
    # Extension fields
    location: str
    inventory_id: Key[int]

# Test 12: Engine and ordering configuration test
class EngineTest(BaseModel):
    id: Key[str]
    timestamp: datetime
    location: str
    category: str
    value: float

# =======Pipeline Configurations for Production Patterns=========

from moose_lib import OlapConfig, ReplacingMergeTreeEngine, MergeTreeEngine

complex_transaction_model = IngestPipeline[ComplexTransaction]("ComplexTransaction", IngestPipelineConfig(
    ingest_api=True,
    stream=True,
    table=OlapConfig(
        engine=ReplacingMergeTreeEngine(),
        order_by_fields=["transaction_id", "location", "transaction_date"]  # Primary key must be first
    ),
    dead_letter_queue=True
))

product_with_location_model = IngestPipeline[ProductWithLocation]("ProductWithLocation", IngestPipelineConfig(
    ingest_api=True,
    stream=True,
    table=OlapConfig(
        engine=ReplacingMergeTreeEngine(),
        order_by_fields=["inventory_id", "location"]
    ),
    dead_letter_queue=True
))

engine_test_model = IngestPipeline[EngineTest]("EngineTest", IngestPipelineConfig(
    ingest_api=True,
    stream=True,
    table=OlapConfig(
        engine=MergeTreeEngine(),
        order_by_fields=["id", "location", "category"]
    ),
    dead_letter_queue=True
))

# =======Array Transform Test Models=========
# Test models for verifying that transforms returning arrays produce multiple Kafka messages

class ArrayInput(BaseModel):
    """Input model for array transform test - contains an array to explode."""
    id: Key[str]
    data: List[str]  # Array of strings to explode into individual records


class ArrayOutput(BaseModel):
    """Output model for array transform test - one record per array item."""
    input_id: Key[str]  # Reference to source ArrayInput.id
    value: str  # From array element
    index: int  # Position in original array
    timestamp: datetime


array_input_model = IngestPipeline[ArrayInput]("ArrayInput", IngestPipelineConfig(
    ingest_api=True,
    stream=True,
    table=False,  # No table for input
    dead_letter_queue=True
))

# Use OlapTable for output table
array_output_table = OlapTable[ArrayOutput](
    "ArrayOutput",
    OlapConfig(
        order_by_fields=["input_id", "timestamp"]
    )
)

# Create a Stream that writes to the OlapTable
from moose_lib import Stream, StreamConfig
array_output_stream = Stream[ArrayOutput](
    "ArrayOutput",
    StreamConfig(destination=array_output_table)
)
