# This file was auto-generated by the framework. You can add data models or change the existing ones

from moose_lib import Point, Ring, LineString, MultiLineString, Polygon, MultiPolygon
from moose_lib import Key, IngestPipeline, IngestPipelineConfig, StringToEnumMixin, clickhouse_default, ClickHouseCodec, OlapTable, \
    OlapConfig, MergeTreeEngine, ReplacingMergeTreeEngine, AggregatingMergeTreeEngine, simple_aggregated, \
    ClickhouseSize, UInt8, UInt16, UInt32, UInt64, Int8, Int16, Int32, Int64, Float32, Float64, ClickhousePrecision
from datetime import datetime, date
from typing import Optional, Annotated, Any
from pydantic import BaseModel, BeforeValidator, ConfigDict
from moose_lib.data_models import ClickHouseJson
from enum import IntEnum, auto


class Baz(StringToEnumMixin, IntEnum):
    QUX = auto()
    QUUX = auto()


class Foo(BaseModel):
    primary_key: Key[str]
    timestamp: float
    baz: Baz
    optional_text: Optional[str] = None


class Bar(BaseModel):
    primary_key: Key[str]
    utc_timestamp: datetime
    baz: Baz
    has_text: bool
    text_length: int


fooModel = IngestPipeline[Foo]("Foo", IngestPipelineConfig(
    ingest_api=True,
    stream=True,
    table=False,
    dead_letter_queue=True
))

barModel = IngestPipeline[Bar]("Bar", IngestPipelineConfig(
    ingest_api=False,
    stream=True,
    table=True,
    dead_letter_queue=True
))

# =======Comprehensive Type Testing Data Models=========

from typing import List, Tuple
from pydantic import Field


# Test 1: Basic primitive types
class BasicTypes(BaseModel):
    id: Key[str]
    timestamp: datetime
    string_field: str
    number_field: float
    boolean_field: bool
    optional_string: Optional[str] = None
    nullable_number: Optional[float] = None


# Test 2: Simple arrays of primitives
class SimpleArrays(BaseModel):
    id: Key[str]
    timestamp: datetime
    string_array: List[str]
    number_array: List[float]
    boolean_array: List[bool]
    optional_string_array: Optional[List[str]] = None
    mixed_optional_array: Optional[List[str]] = None


# Test 3: Nested objects
class Coordinates(BaseModel):
    lat: float
    lng: float


class Address(BaseModel):
    street: str
    city: str
    coordinates: Coordinates


class Settings(BaseModel):
    theme: str
    notifications: bool


class Config(BaseModel):
    enabled: bool
    settings: Settings


class Metadata(BaseModel):
    tags: List[str]
    priority: int
    config: Config


class NestedObjects(BaseModel):
    id: Key[str]
    timestamp: datetime
    address: Address
    metadata: Metadata


# Test 4: Arrays of objects
class User(BaseModel):
    name: str
    age: int
    active: bool


class TransactionMetadata(BaseModel):
    category: str
    tags: List[str]


class Transaction(BaseModel):
    id: str
    amount: float
    currency: str
    metadata: TransactionMetadata


class ArraysOfObjects(BaseModel):
    id: Key[str]
    timestamp: datetime
    users: List[User]
    transactions: List[Transaction]


# Test 5: Deeply nested arrays (main focus for ENG-875) - ClickHouse compatible
class SimplifiedItem(BaseModel):
    name: str
    values: List[float]
    data: List[str]
    # Flattened structure instead of deeply nested objects
    metric_names: List[str]
    metric_values: List[float]


class ComplexNestedCategory(BaseModel):
    category: str
    items: List[SimplifiedItem]


class DeeplyNestedArrays(BaseModel):
    id: Key[str]
    timestamp: datetime
    # Level 1: Array of arrays (safe)
    matrix_2d: List[List[float]]
    # Level 2: Array of arrays of arrays (safe)
    matrix_3d: List[List[List[float]]]
    # Level 3: Array of arrays of arrays of arrays (pushing limits but should work)
    matrix_4d: List[List[List[List[float]]]]
    # Simplified nested: Reduce nesting depth to avoid ClickHouse issues
    complex_nested: List[ComplexNestedCategory]


# Test 6: Mixed complex types (ClickHouse-safe)
class ClickEvent(BaseModel):
    type: str = Field(default="click")
    target: str
    coordinate_x: float
    coordinate_y: float


class FlattenedData(BaseModel):
    required: str
    optional_data: List[str]  # Flattened, no nested optionals
    tags: List[str]
    values: List[float]


class Column(BaseModel):
    col: int
    values: List[str]


class ComplexMatrixRow(BaseModel):
    row: int
    columns: List[Column]


class MixedComplexTypes(BaseModel):
    id: Key[str]
    timestamp: datetime
    # Arrays with click events (safe)
    events: List[ClickEvent]
    # Flattened optional structures (avoid nested optionals)
    nested_data: List[FlattenedData]
    # Multi-dimensional with objects (safe)
    complex_matrix: List[ComplexMatrixRow]


# Test 7: Edge cases and boundary conditions (ClickHouse-compatible)
class EmptyObject(BaseModel):
    id: str


class Property(BaseModel):
    key: str
    value: str
    tags: List[str]


class Metric(BaseModel):
    name: str
    values: List[float]


class ModerateLevel2(BaseModel):
    data: List[str]
    values: List[float]


class ModerateLevel1(BaseModel):
    level2: List[ModerateLevel2]


class ModerateNesting(BaseModel):
    level1: List[ModerateLevel1]


class SimplifiedComplexItem(BaseModel):
    id: str
    properties: List[Property]
    metrics: List[Metric]


class EdgeCases(BaseModel):
    id: Key[str]
    timestamp: datetime
    # Empty arrays (safe)
    empty_string_array: List[str]
    empty_object_array: List[EmptyObject]
    # Simplified nullable structures (avoid nested nullables)
    nullable_string: Optional[str] = None
    nullable_number: Optional[float] = None
    # Moderate depth nesting (3 levels max for safety)
    moderate_nesting: ModerateNesting
    # Simplified complex arrays
    complex_array: List[SimplifiedComplexItem]


# =======JSON Types Test=========
class JsonInner(BaseModel):
    model_config = ConfigDict(extra='allow')

    name: str
    count: int


class JsonTest(BaseModel):
    id: Key[str]
    timestamp: datetime
    # Test JSON with full configuration (max_dynamic_paths, max_dynamic_types, skip_paths, skip_regexps)
    payload_with_config: Annotated[JsonInner, ClickHouseJson(
        max_dynamic_paths=256,
        max_dynamic_types=16,
        skip_paths=("skip.me",),
        skip_regexps=("^tmp\\.",)
    )]
    # Test JSON with paths but without configuration
    payload_basic: Annotated[JsonInner, ClickHouseJson()]


# =======Pipeline Configurations for Test Models=========

basic_types_model = IngestPipeline[BasicTypes]("BasicTypes", IngestPipelineConfig(
    ingest_api=True,
    stream=True,
    table=True,
    dead_letter_queue=True
))

simple_arrays_model = IngestPipeline[SimpleArrays]("SimpleArrays", IngestPipelineConfig(
    ingest_api=True,
    stream=True,
    table=True,
    dead_letter_queue=True
))

nested_objects_model = IngestPipeline[NestedObjects]("NestedObjects", IngestPipelineConfig(
    ingest_api=True,
    stream=True,
    table=True,
    dead_letter_queue=True
))

arrays_of_objects_model = IngestPipeline[ArraysOfObjects]("ArraysOfObjects", IngestPipelineConfig(
    ingest_api=True,
    stream=True,
    table=True,
    dead_letter_queue=True
))

deeply_nested_arrays_model = IngestPipeline[DeeplyNestedArrays]("DeeplyNestedArrays", IngestPipelineConfig(
    ingest_api=True,
    stream=True,
    table=True,
    dead_letter_queue=True
))

mixed_complex_types_model = IngestPipeline[MixedComplexTypes]("MixedComplexTypes", IngestPipelineConfig(
    ingest_api=True,
    stream=True,
    table=True,
    dead_letter_queue=True
))

edge_cases_model = IngestPipeline[EdgeCases]("EdgeCases", IngestPipelineConfig(
    ingest_api=True,
    stream=True,
    table=True,
    dead_letter_queue=True
))

json_test_model = IngestPipeline[JsonTest]("JsonTest", IngestPipelineConfig(
    ingest_api=True,
    stream=True,
    table=True,
    dead_letter_queue=True
))


# =======Optional Nested Fields with ClickHouse Defaults Test=========

# Test class with optional nested fields and ClickHouse defaults
class TestNested(BaseModel):
    name: Optional[str] = None
    age: Optional[float] = None


class OptionalNestedTest(BaseModel):
    id: Key[str]
    timestamp: datetime
    nested: List[TestNested]
    other: Annotated[str, clickhouse_default("''")] = ""


optional_nested_test_model = IngestPipeline[OptionalNestedTest]("OptionalNestedTest", IngestPipelineConfig(
    ingest_api=True,
    stream=True,
    table=True,
    dead_letter_queue=True
))


# =======Geometry Types=========

class GeoTypes(BaseModel):
    id: Key[str]
    timestamp: datetime
    point: Point
    ring: Ring
    line_string: LineString
    multi_line_string: MultiLineString
    polygon: Polygon
    multi_polygon: MultiPolygon


geo_types_model = IngestPipeline[GeoTypes]("GeoTypes", IngestPipelineConfig(
    ingest_api=True,
    stream=True,
    table=True,
    dead_letter_queue=True
))


# =======Versioned OlapTables Test=========
# Test versioned OlapTables - same name, different versions
# This demonstrates the OlapTable versioning functionality

class UserEventV1(BaseModel):
    """Version 1.0 of user events - basic structure."""
    user_id: Key[str]
    event_type: str
    timestamp: float
    metadata: Optional[str] = None


class UserEventV2(BaseModel):
    """Version 2.0 of user events - enhanced with session tracking."""
    user_id: Key[str]
    event_type: str
    timestamp: float
    metadata: Optional[str] = None
    session_id: str
    user_agent: Optional[str] = None


# Version 1.0 - MergeTree engine
user_events_v1 = OlapTable[UserEventV1](
    "UserEvents",
    OlapConfig(
        version="1.0",
        engine=MergeTreeEngine(),
        order_by_fields=["user_id", "timestamp"]
    )
)

# Version 2.0 - ReplacingMergeTree engine with enhanced schema
user_events_v2 = OlapTable[UserEventV2](
    "UserEvents",
    OlapConfig(
        version="2.0",
        engine=ReplacingMergeTreeEngine(),
        order_by_fields=["user_id", "session_id", "timestamp"]
    )
)


# =======SimpleAggregateFunction Test=========
# Test SimpleAggregateFunction support for aggregated metrics
# This demonstrates using SimpleAggregateFunction with AggregatingMergeTree

class SimpleAggTest(BaseModel):
    """Test model for SimpleAggregateFunction support."""
    date_stamp: Key[Annotated[date, ClickhouseSize(2)]]
    table_name: Key[str]
    row_count: simple_aggregated('sum', UInt64)
    max_value: simple_aggregated('max', int)
    min_value: simple_aggregated('min', int)
    last_updated: simple_aggregated('anyLast', datetime)


simple_agg_test_table = OlapTable[SimpleAggTest](
    "SimpleAggTest",
    OlapConfig(
        engine=AggregatingMergeTreeEngine(),
        order_by_fields=["date_stamp", "table_name"]
    )
)


# =======Index Extraction Test Table=======
class IndexTest(BaseModel):
    u64: Key[UInt64]
    i32: Int32
    s: str


index_test_table = OlapTable[IndexTest](
    "IndexTest",
    OlapConfig(
        engine=MergeTreeEngine(),
        order_by_fields=["u64"],
        indexes=[
            OlapConfig.TableIndex(name="idx1", expression="u64", type="bloom_filter", arguments=[], granularity=3),
            OlapConfig.TableIndex(name="idx2", expression="u64 * i32", type="minmax", arguments=[], granularity=3),
            OlapConfig.TableIndex(name="idx3", expression="u64 * length(s)", type="set", arguments=["1000"],
                                  granularity=4),
            OlapConfig.TableIndex(name="idx4", expression="(u64, i32)", type="MinMax", arguments=[], granularity=1),
            OlapConfig.TableIndex(name="idx5", expression="(u64, i32)", type="minmax", arguments=[], granularity=1),
            OlapConfig.TableIndex(name="idx6", expression="toString(i32)", type="ngrambf_v1",
                                  arguments=["2", "256", "1", "123"], granularity=1),
            OlapConfig.TableIndex(name="idx7", expression="s", type="nGraMbf_v1", arguments=["3", "256", "1", "123"],
                                  granularity=1),
        ],
    ),
)


# =======Numeric Type Aliases Test=========
# Demonstrates usage of Int8, Int16, Int32, Int64, UInt8, UInt16, UInt32, UInt64, Float32, Float64

class NumericTypesTest(BaseModel):
    """Test model showcasing all numeric type aliases."""
    # Primary key
    id: Key[str]
    timestamp: datetime

    # Unsigned integers - for values that are always positive
    user_count: UInt32  # User counts (0 to 4B)
    page_views: UInt64  # Large counters
    status_code: UInt8  # HTTP status codes (0-255)
    port: UInt16  # Network ports (0-65535)

    # Signed integers - for values that can be negative
    temperature: Int16  # Temperature in celsius (-32K to +32K)
    balance: Int64  # Financial balances (can be negative)
    offset: Int8  # Small offsets (-128 to +127)
    delta: Int32  # Deltas/differences

    # Float types
    latitude: Float64  # High precision coordinates
    confidence_score: Float32  # ML confidence scores (lower precision ok)
    price: Float64  # Financial amounts need precision


numeric_types_test_model = IngestPipeline[NumericTypesTest]("NumericTypesTest", IngestPipelineConfig(
    ingest_api=True,
    stream=True,
    table=True,
    dead_letter_queue=True
))


# =======Real-World Production Patterns (District Cannabis Inspired)=========

# Test 8: Complex discount structure with mixed nullability
class DiscountInfo(BaseModel):
    discount_id: Optional[int] = None
    discount_name: Optional[str] = None  # Explicit null
    discount_reason: Optional[str] = None
    amount: float  # Required field


# Test 9: Transaction item with complex nested structure
class ProductItem(BaseModel):
    product_id: Optional[int] = None
    product_name: Optional[str] = None
    quantity: float
    unit_price: float
    unit_cost: Optional[float] = None
    package_id: Optional[str] = None


# Test 10: Complex transaction with multiple array types and ReplacingMergeTree
class ComplexTransaction(BaseModel):
    transaction_id: Key[int]  # Primary key
    customer_id: Optional[int] = None
    transaction_date: datetime
    location: str  # Part of order by
    subtotal: float
    tax: float
    total: float
    # Multiple complex array fields
    items: List[ProductItem]
    discounts: List[DiscountInfo]
    order_ids: List[int]  # Simple array
    # Mixed nullability patterns
    tip_amount: Optional[float] = None
    invoice_number: Optional[str] = None
    terminal_name: Optional[str] = None  # Optional without explicit null
    # Boolean fields
    is_void: bool
    is_tax_inclusive: Optional[bool] = None


# Test 11: Base type pattern with extension (common pattern)
class BaseProduct(BaseModel):
    product_id: Optional[int] = None
    product_name: Optional[str] = None
    description: Optional[str] = None
    category_id: Optional[int] = None
    tags: List[str]  # Remove optional - arrays cannot be nullable in ClickHouse


class ProductWithLocation(BaseModel):
    # Simulate Omit pattern by redefining fields
    product_id: int  # Make required (was optional in base)
    product_name: Optional[str] = None
    description: Optional[str] = None
    category_id: Optional[int] = None
    tags: List[str]  # Remove optional - arrays cannot be nullable in ClickHouse
    # Extension fields
    location: str
    inventory_id: Key[int]


# Test 12: Engine and ordering configuration test
class EngineTest(BaseModel):
    id: Key[str]
    timestamp: datetime
    location: str
    category: str
    value: float


# =======Pipeline Configurations for Production Patterns=========

from moose_lib import OlapConfig, ReplacingMergeTreeEngine, MergeTreeEngine

complex_transaction_model = IngestPipeline[ComplexTransaction]("ComplexTransaction", IngestPipelineConfig(
    ingest_api=True,
    stream=True,
    table=OlapConfig(
        engine=ReplacingMergeTreeEngine(),
        order_by_fields=["transaction_id", "location", "transaction_date"]  # Primary key must be first
    ),
    dead_letter_queue=True
))

product_with_location_model = IngestPipeline[ProductWithLocation]("ProductWithLocation", IngestPipelineConfig(
    ingest_api=True,
    stream=True,
    table=OlapConfig(
        engine=ReplacingMergeTreeEngine(),
        order_by_fields=["inventory_id", "location"]
    ),
    dead_letter_queue=True
))

engine_test_model = IngestPipeline[EngineTest]("EngineTest", IngestPipelineConfig(
    ingest_api=True,
    stream=True,
    table=OlapConfig(
        engine=MergeTreeEngine(),
        order_by_fields=["id", "location", "category"]
    ),
    dead_letter_queue=True
))


# =======Array Transform Test Models=========
# Test models for verifying that transforms returning arrays produce multiple Kafka messages

class ArrayInput(BaseModel):
    """Input model for array transform test - contains an array to explode."""
    id: Key[str]
    data: List[str]  # Array of strings to explode into individual records


class ArrayOutput(BaseModel):
    """Output model for array transform test - one record per array item."""
    input_id: Key[str]  # Reference to source ArrayInput.id
    value: str  # From array element
    index: int  # Position in original array
    timestamp: datetime


array_input_model = IngestPipeline[ArrayInput]("ArrayInput", IngestPipelineConfig(
    ingest_api=True,
    stream=True,
    table=False,  # No table for input
    dead_letter_queue=True
))

# Use OlapTable for output table
array_output_table = OlapTable[ArrayOutput](
    "ArrayOutput",
    OlapConfig(
        order_by_fields=["input_id", "timestamp"]
    )
)

# Create a Stream that writes to the OlapTable
from moose_lib import Stream, StreamConfig

array_output_stream = Stream[ArrayOutput](
    "ArrayOutput",
    StreamConfig(destination=array_output_table)
)


# =======DateTime Precision Test Models=========
# Test models for verifying DateTime precision handling (microseconds)
# Tests ENG-1453: Ensure microsecond precision is preserved

class DateTimePrecisionTestData(BaseModel):
    """Input model with datetime fields."""
    id: Key[str]
    created_at: datetime
    timestamp_ms: Annotated[datetime, ClickhousePrecision(3)]
    timestamp_us: Annotated[datetime, ClickhousePrecision(6)]
    timestamp_ns: Annotated[datetime, ClickhousePrecision(9)]


# Input pipeline (no table, just stream)
datetime_precision_input_model = IngestPipeline[DateTimePrecisionTestData](
    "DateTimePrecisionInput",
    IngestPipelineConfig(
        ingest_api=True,
        stream=True,
        table=False,
        dead_letter_queue=True
    ))

# Output table
datetime_precision_output_table = OlapTable[DateTimePrecisionTestData](
    "DateTimePrecisionOutput",
    OlapConfig(order_by_fields=["id"])
)

# Output stream
datetime_precision_output_stream = Stream[DateTimePrecisionTestData](
    "DateTimePrecisionOutput",
    StreamConfig(destination=datetime_precision_output_table)
)

# =======Primary Key Expression Tests=========

# Test: Primary Key Expression with hash function
class PrimaryKeyExpressionTest(BaseModel):
    user_id: str
    event_id: str
    timestamp: datetime
    category: str


# Table using primary_key_expression with hash function for better distribution
# Note: PRIMARY KEY must be a prefix of ORDER BY in ClickHouse
primary_key_expression_table = OlapTable[PrimaryKeyExpressionTest](
    "PrimaryKeyExpressionTest",
    OlapConfig(
        # Primary key uses hash function for better distribution
        primary_key_expression="(user_id, cityHash64(event_id))",
        # Order by must start with the same columns as primary key
        order_by_expression="(user_id, cityHash64(event_id), timestamp)",
    )
)


# Test: Primary Key Expression with different column ordering
class PrimaryKeyOrderingTest(BaseModel):
    product_id: str
    category: str
    brand: str
    timestamp: datetime


# Table where primary key order differs from schema order
# Note: ORDER BY must start with PRIMARY KEY columns
primary_key_ordering_table = OlapTable[PrimaryKeyOrderingTest](
    "PrimaryKeyOrderingTest",
    OlapConfig(
        # Primary key optimized for uniqueness
        primary_key_expression="(product_id)",
        # Order by starts with primary key, then adds other columns for query optimization
        order_by_fields=["product_id", "category", "brand"],
    )
)

# =======Codec Compression Test=======
class CodecTest(BaseModel):
    """Test model for codec compression support."""
    id: Key[str]
    timestamp: Annotated[datetime, ClickHouseCodec("Delta, LZ4")]
    log_blob: Annotated[Any, ClickHouseCodec("ZSTD(3)")]
    combination_hash: Annotated[list[UInt64], ClickHouseCodec("ZSTD(1)")]
    temperature: Annotated[float, ClickHouseCodec("Gorilla, ZSTD(3)")]
    request_count: Annotated[float, ClickHouseCodec("DoubleDelta, LZ4")]
    user_agent: Annotated[str, ClickHouseCodec("ZSTD(3)")]
    tags: Annotated[list[str], ClickHouseCodec("LZ4")]
    status_code: float


codec_test_model = IngestPipeline[CodecTest]("CodecTest", IngestPipelineConfig(
    ingest_api=True,
    stream=True,
    table=True,
    dead_letter_queue=True
))
