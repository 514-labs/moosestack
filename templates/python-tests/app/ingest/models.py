# This file was auto-generated by the framework. You can add data models or change the existing ones

from moose_lib import Key, IngestPipeline, IngestPipelineConfig, StringToEnumMixin, clickhouse_default
from datetime import datetime
from typing import Optional, Annotated, Any
from pydantic import BaseModel, BeforeValidator
from enum import IntEnum, auto



class Baz(StringToEnumMixin, IntEnum):
    QUX = auto()
    QUUX = auto()


class Foo(BaseModel):
    primary_key: Key[str]
    timestamp: float
    baz: Baz
    optional_text: Optional[str] = None


class Bar(BaseModel):
    primary_key: Key[str]
    utc_timestamp: datetime
    baz: Baz
    has_text: bool
    text_length: int


fooModel = IngestPipeline[Foo]("Foo", IngestPipelineConfig(
    ingest=True,
    stream=True,
    table=False,
    dead_letter_queue=True
))

barModel = IngestPipeline[Bar]("Bar", IngestPipelineConfig(
    ingest=False,
    stream=True,
    table=True,
    dead_letter_queue=True
))

# =======Comprehensive Type Testing Data Models=========

from typing import List, Tuple
from pydantic import Field

# Test 1: Basic primitive types
class BasicTypes(BaseModel):
    id: Key[str]
    timestamp: datetime
    string_field: str
    number_field: float
    boolean_field: bool
    optional_string: Optional[str] = None
    nullable_number: Optional[float] = None

# Test 2: Simple arrays of primitives
class SimpleArrays(BaseModel):
    id: Key[str]
    timestamp: datetime
    string_array: List[str]
    number_array: List[float]
    boolean_array: List[bool]
    optional_string_array: Optional[List[str]] = None
    mixed_optional_array: Optional[List[str]] = None

# Test 3: Nested objects
class Coordinates(BaseModel):
    lat: float
    lng: float

class Address(BaseModel):
    street: str
    city: str
    coordinates: Coordinates

class Settings(BaseModel):
    theme: str
    notifications: bool

class Config(BaseModel):
    enabled: bool
    settings: Settings

class Metadata(BaseModel):
    tags: List[str]
    priority: int
    config: Config

class NestedObjects(BaseModel):
    id: Key[str]
    timestamp: datetime
    address: Address
    metadata: Metadata

# Test 4: Arrays of objects
class User(BaseModel):
    name: str
    age: int
    active: bool

class TransactionMetadata(BaseModel):
    category: str
    tags: List[str]

class Transaction(BaseModel):
    id: str
    amount: float
    currency: str
    metadata: TransactionMetadata

class ArraysOfObjects(BaseModel):
    id: Key[str]
    timestamp: datetime
    users: List[User]
    transactions: List[Transaction]

# Test 5: Deeply nested arrays (main focus for ENG-875) - ClickHouse compatible
class SimplifiedItem(BaseModel):
    name: str
    values: List[float]
    data: List[str]
    # Flattened structure instead of deeply nested objects
    metric_names: List[str]
    metric_values: List[float]

class ComplexNestedCategory(BaseModel):
    category: str
    items: List[SimplifiedItem]

class DeeplyNestedArrays(BaseModel):
    id: Key[str]
    timestamp: datetime
    # Level 1: Array of arrays (safe)
    matrix_2d: List[List[float]]
    # Level 2: Array of arrays of arrays (safe)
    matrix_3d: List[List[List[float]]]
    # Level 3: Array of arrays of arrays of arrays (pushing limits but should work)
    matrix_4d: List[List[List[List[float]]]]
    # Simplified nested: Reduce nesting depth to avoid ClickHouse issues
    complex_nested: List[ComplexNestedCategory]

# Test 6: Mixed complex types (ClickHouse-safe)
class ClickEvent(BaseModel):
    type: str = Field(default="click")
    target: str
    coordinate_x: float
    coordinate_y: float

class FlattenedData(BaseModel):
    required: str
    optional_data: List[str]  # Flattened, no nested optionals
    tags: List[str]
    values: List[float]

class Column(BaseModel):
    col: int
    values: List[str]

class ComplexMatrixRow(BaseModel):
    row: int
    columns: List[Column]

class MixedComplexTypes(BaseModel):
    id: Key[str]
    timestamp: datetime
    # Arrays with click events (safe)
    events: List[ClickEvent]
    # Flattened optional structures (avoid nested optionals)
    nested_data: List[FlattenedData]
    # Multi-dimensional with objects (safe)
    complex_matrix: List[ComplexMatrixRow]

# Test 7: Edge cases and boundary conditions (ClickHouse-compatible)
class EmptyObject(BaseModel):
    id: str

class Property(BaseModel):
    key: str
    value: str
    tags: List[str]

class Metric(BaseModel):
    name: str
    values: List[float]

class ModerateLevel2(BaseModel):
    data: List[str]
    values: List[float]

class ModerateLevel1(BaseModel):
    level2: List[ModerateLevel2]

class ModerateNesting(BaseModel):
    level1: List[ModerateLevel1]

class SimplifiedComplexItem(BaseModel):
    id: str
    properties: List[Property]
    metrics: List[Metric]

class EdgeCases(BaseModel):
    id: Key[str]
    timestamp: datetime
    # Empty arrays (safe)
    empty_string_array: List[str]
    empty_object_array: List[EmptyObject]
    # Simplified nullable structures (avoid nested nullables)
    nullable_string: Optional[str] = None
    nullable_number: Optional[float] = None
    # Moderate depth nesting (3 levels max for safety)
    moderate_nesting: ModerateNesting
    # Simplified complex arrays
    complex_array: List[SimplifiedComplexItem]

# =======Pipeline Configurations for Test Models=========

basic_types_model = IngestPipeline[BasicTypes]("BasicTypes", IngestPipelineConfig(
    ingest=True,
    stream=True,
    table=True,
    dead_letter_queue=True
))

simple_arrays_model = IngestPipeline[SimpleArrays]("SimpleArrays", IngestPipelineConfig(
    ingest=True,
    stream=True,
    table=True,
    dead_letter_queue=True
))

nested_objects_model = IngestPipeline[NestedObjects]("NestedObjects", IngestPipelineConfig(
    ingest=True,
    stream=True,
    table=True,
    dead_letter_queue=True
))

arrays_of_objects_model = IngestPipeline[ArraysOfObjects]("ArraysOfObjects", IngestPipelineConfig(
    ingest=True,
    stream=True,
    table=True,
    dead_letter_queue=True
))

deeply_nested_arrays_model = IngestPipeline[DeeplyNestedArrays]("DeeplyNestedArrays", IngestPipelineConfig(
    ingest=True,
    stream=True,
    table=True,
    dead_letter_queue=True
))

mixed_complex_types_model = IngestPipeline[MixedComplexTypes]("MixedComplexTypes", IngestPipelineConfig(
    ingest=True,
    stream=True,
    table=True,
    dead_letter_queue=True
))

edge_cases_model = IngestPipeline[EdgeCases]("EdgeCases", IngestPipelineConfig(
    ingest=True,
    stream=True,
    table=True,
    dead_letter_queue=True
))

# =======Optional Nested Fields with ClickHouse Defaults Test=========

# Test class with optional nested fields and ClickHouse defaults
class TestNested(BaseModel):
    name: Optional[str] = None
    age: Optional[float] = None

class OptionalNestedTest(BaseModel):
    id: Key[str]
    timestamp: datetime
    nested: List[TestNested]
    other: Optional[Annotated[str, clickhouse_default("''")]] = None

optional_nested_test_model = IngestPipeline[OptionalNestedTest]("OptionalNestedTest", IngestPipelineConfig(
    ingest=True,
    stream=True,
    table=True,
    dead_letter_queue=True
))

# =======Real-World Production Patterns (District Cannabis Inspired)=========

# Test 8: Complex discount structure with mixed nullability
class DiscountInfo(BaseModel):
    discount_id: Optional[int] = None
    discount_name: Optional[str] = None  # Explicit null
    discount_reason: Optional[str] = None
    amount: float  # Required field

# Test 9: Transaction item with complex nested structure
class ProductItem(BaseModel):
    product_id: Optional[int] = None
    product_name: Optional[str] = None
    quantity: float
    unit_price: float
    unit_cost: Optional[float] = None
    package_id: Optional[str] = None

# Test 10: Complex transaction with multiple array types and ReplacingMergeTree
class ComplexTransaction(BaseModel):
    transaction_id: Key[int]  # Primary key
    customer_id: Optional[int] = None
    transaction_date: datetime
    location: str  # Part of order by
    subtotal: float
    tax: float
    total: float
    # Multiple complex array fields
    items: List[ProductItem]
    discounts: List[DiscountInfo]
    order_ids: List[int]  # Simple array
    # Mixed nullability patterns
    tip_amount: Optional[float] = None
    invoice_number: Optional[str] = None
    terminal_name: Optional[str] = None  # Optional without explicit null
    # Boolean fields
    is_void: bool
    is_tax_inclusive: Optional[bool] = None

# Test 11: Base type pattern with extension (common pattern)
class BaseProduct(BaseModel):
    product_id: Optional[int] = None
    product_name: Optional[str] = None
    description: Optional[str] = None
    category_id: Optional[int] = None
    tags: List[str]  # Remove optional - arrays cannot be nullable in ClickHouse

class ProductWithLocation(BaseModel):
    # Simulate Omit pattern by redefining fields
    product_id: int  # Make required (was optional in base)
    product_name: Optional[str] = None
    description: Optional[str] = None
    category_id: Optional[int] = None
    tags: List[str]  # Remove optional - arrays cannot be nullable in ClickHouse
    # Extension fields
    location: str
    inventory_id: Key[int]

# Test 12: Engine and ordering configuration test
class EngineTest(BaseModel):
    id: Key[str]
    timestamp: datetime
    location: str
    category: str
    value: float

# =======Pipeline Configurations for Production Patterns=========

from moose_lib import EngineConfig, ClickHouseEngines

complex_transaction_model = IngestPipeline[ComplexTransaction]("ComplexTransaction", IngestPipelineConfig(
    ingest=True,
    stream=True,
    table=EngineConfig(
        engine=ClickHouseEngines.ReplacingMergeTree,
        order_by_fields=["location", "transaction_id", "transaction_date"]
    ),
    dead_letter_queue=True
))

product_with_location_model = IngestPipeline[ProductWithLocation]("ProductWithLocation", IngestPipelineConfig(
    ingest=True,
    stream=True,
    table=EngineConfig(
        engine=ClickHouseEngines.ReplacingMergeTree,
        order_by_fields=["inventory_id", "location"]
    ),
    dead_letter_queue=True
))

engine_test_model = IngestPipeline[EngineTest]("EngineTest", IngestPipelineConfig(
    ingest=True,
    stream=True,
    table=EngineConfig(
        engine=ClickHouseEngines.MergeTree,
        order_by_fields=["id", "location", "category"]
    ),
    dead_letter_queue=True
))
