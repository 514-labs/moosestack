{"version":3,"file":"getBooksByYearSortedByRating.js","sourceRoot":"","sources":["../../app/apis/getBooksByYearSortedByRating.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,gDAAuC;AACvC,gDAAoD;AAsBpD;;;GAGG;AACU,QAAA,4BAA4B,GAAG,IAAI,0BAAc,CAAoB,8BAA8B,EAAE,UAAC,MAAM,EAAE,KAAK;IAC5H,IAAM,WAAW;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;sGAAiE,CAAC;IACnF,IAAM,YAAY,GAAG,IAAI,eAAe,CAAC,MAAa,CAAC,CAAC;IACxD,IAAM,eAAe,GAAG,WAAW,CAAC,YAAY,CAAC,CAAC;IAClD,OAAO,CAAC,UAAO,MAAM,EAAE,KAAK;;;;;oBAChB,MAAM,GAAU,KAAK,OAAf,EAAE,GAAG,GAAK,KAAK,IAAV,CAAW;;;;oBAGX,qBAAM,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,GAAG,ssBAAC,oeAYc,EAAW,6JAM5E,KANiE,MAAM,CAAC,IAAI,EAM3E,EAAA;;oBAlBU,MAAM,GAAG,SAkBnB;oBAE0B,qBAAM,MAAM,CAAC,IAAI,EAAE,EAAA;;oBAAnC,KAAK,GAAW,SAAmB;oBACzC,sBAAO;4BACH,OAAO,EAAE,IAAI;4BACb,KAAK,EAAE,KAAK,CAAC,MAAM;4BACnB,KAAK,EAAE,KAAK;yBACf,EAAC;;;oBAGF,uBAAuB;oBACvB,OAAO,CAAC,KAAK,CAAC,+BAA+B,EAAE,OAAK,CAAC,CAAC;oBACtD,sBAAO;4BACH,OAAO,EAAE,KAAK;4BACd,KAAK,EAAE,uBAAuB;4BAC9B,OAAO,EAAE,OAAK,YAAY,KAAK,CAAC,CAAC,CAAC,OAAK,CAAC,OAAO,CAAC,CAAC,CAAC,eAAe;yBACpE,EAAC;;;;SAET,CAAC,CAAC,eAAe,EAAE,KAAK,CAAC,CAAC;AAC/B,CAAC,EAAE,EAAE;;;;;;;;;;;;;;;;;;;;;;;;;;GAEC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAQ,CAAC,CAAC","sourcesContent":["import ____moose____typia from \"typia\";\nimport { ConsumptionApi } from \"@514labs/moose-lib\";\nimport { tags } from \"typia\";\n/**\n * Parameters for the getBooksByYearSortedByRating API\n */\ninterface BooksByYearParams {\n    /** The publication year to filter by (e.g., 2006) */\n    year: number & tags.Type<\"int32\"> & tags.Minimum<1800> & tags.Maximum<2100>;\n}\n/**\n * Book data structure returned by the API\n */\ninterface Book {\n    title: string;\n    authors: string;\n    rating: number;\n    ratings_count: number;\n    reviews_count: number;\n    publication_date: string;\n    publisher: string;\n    pages: number;\n}\n/**\n * API that returns a list of books for a given year, sorted by their average rating in descending order.\n * Only includes books with a significant number of ratings (>1000) to ensure reliability.\n */\nexport const getBooksByYearSortedByRating = new ConsumptionApi<BooksByYearParams>(\"getBooksByYearSortedByRating\", (params, utils) => {\n    const assertGuard = ____moose____typia.http.createAssertQuery<BooksByYearParams>();\n    const searchParams = new URLSearchParams(params as any);\n    const processedParams = assertGuard(searchParams);\n    return (async (params, utils) => {\n        const { client, sql } = utils;\n        try {\n            // Execute the query with parameterized input to prevent SQL injection\n            const result = await client.query.execute(sql `\n        WITH filtered_books AS (\n          SELECT \n            title,\n            authors,\n            ROUND(CAST(average_rating AS Float64), 2) as rating,\n            CAST(ratings_count AS Int64) as ratings_count,\n            CAST(text_reviews_count AS Int64) as reviews_count,\n            publication_date,\n            publisher,\n            CAST(num_pages AS Int32) as pages\n          FROM books\n          WHERE toYear(parseDateTime64BestEffort(publication_date)) = ${params.year}\n            AND ratings_count >= 1000\n        )\n        SELECT *\n        FROM filtered_books\n        ORDER BY rating DESC, ratings_count DESC\n      `);\n            // Process the result set and convert to the expected format\n            const books: Book[] = await result.json();\n            return {\n                success: true,\n                count: books.length,\n                books: books,\n            };\n        }\n        catch (error) {\n            // Basic error handling\n            console.error(\"Error fetching books by year:\", error);\n            return {\n                success: false,\n                error: \"Failed to fetch books\",\n                details: error instanceof Error ? error.message : \"Unknown error\",\n            };\n        }\n    })(processedParams, utils);\n}, {}, ____moose____typia.json.schemas<[\n    BooksByYearParams\n]>(), JSON.parse(\"[]\") as any);\n"]}