syntax = "proto3";

package moose.proto;

import "google/protobuf/duration.proto";
import "google/protobuf/wrappers.proto";

message InfrastructureMap {
  map<string, Topic> topics = 1;
  map<string, ApiEndpoint> api_endpoints = 2;
  map<string, Table> tables = 3;
  map<string, Dmv1View> dmv1_views = 4;
  map<string, TopicToTableSyncProcess> topic_to_table_sync_processes = 5;
  map<string, TopicToTopicSyncProcess> topic_to_topic_sync_processes = 6;
  map<string, FunctionProcess> function_processes = 7;

  //  add then when they have fields in rust
  //  OlapProcess block_db_processes = 8;
  //  ConsumptionApiWebServer consumption_api_web_server = 9;
  map<string, InitialDataLoad> initial_data_loads = 10;
  map<string, OrchestrationWorker> orchestration_workers = 11;

  map<string, SqlResource> sql_resources = 12;
  map<string, WebApp> web_apps = 13;

  // Version of Moose CLI that created or last updated this infrastructure map
  // Helps with debugging, compatibility tracking, and migration planning
  string moose_version = 19;

  string default_database = 15;

  // Structured materialized views (replaces SqlResource for MVs)
  map<string, MaterializedView> materialized_views = 16;
  // Structured views (replaces SqlResource for views)
  map<string, View> views = 17;
  // Workflow definitions
  map<string, Workflow> workflows = 18;
}

message SourceLocation {
  string file = 1;
}

message Metadata {
  string description = 1;
  optional SourceLocation source = 2;
}

message Topic {
  optional string version = 1;
  string name = 2;
  google.protobuf.Duration retention_period = 3;
  repeated Column columns = 4;
  PrimitiveSignature source_primitive = 5;
  optional int32 partition_count = 6;
  optional int32 max_message_bytes = 7;
  Metadata metadata = 8;
  LifeCycle life_cycle = 9;
  // Optional Schema Registry configuration
  optional SchemaRegistry schema_registry = 10;
}

// Encodes schema reference used for Schema Registry integration
message SchemaRegistry {
  enum Encoding {
    JSON = 0;
    AVRO = 1;
    PROTOBUF = 2;
  }
  // Encoding/wire format; avoid reserved names in generators
  Encoding encoding = 1;
  oneof schema_ref {
    // Use a concrete schema ID
    int32 schema_id = 2;
    // Use subject name (latest version)
    string subject = 3;
    // Use subject name with explicit version
    SubjectVersion subject_version = 4;
  }
}

message SubjectVersion {
  string subject = 1;
  int32 version = 2;
}

message ApiEndpoint {
  string name = 1;
  oneof api_type {
    IngressDetails ingress = 2;
    EgressDetails egress = 3;
  }
  string path = 4;
  Method method = 5;
  optional string version = 6;
  PrimitiveSignature source_primitive = 7;
  Metadata metadata = 8;
}

message IngressDetails {
  string target_topic = 1;
  optional EndpointIngestionFormat format = 2 [deprecated = true];
  optional string dead_letter_queue = 3;
}

message EgressDetails {
  repeated ConsumptionQueryParam query_params = 1;
  // might be worth it to use google.protobuf.Value
  string output_schema = 2;
}

message ConsumptionQueryParam {
  string name = 1;
  ColumnType data_type = 2;
  bool required = 3;
}

enum EndpointIngestionFormat {
  option deprecated = true;
  JSON = 0;
  JSON_ARRAY = 1;
}

enum Method {
  GET = 0;
  POST = 1;
  PUT = 2;
  DELETE = 3;
}

message Table {
  string name = 1;
  repeated Column columns = 2;
  repeated string order_by = 3;
  optional string version = 4;
  PrimitiveSignature source_primitive = 5;

  bool deduplicate = 6 [deprecated = true];
  google.protobuf.StringValue engine = 7;
  Metadata metadata = 8;
  LifeCycle life_cycle = 9;

  // Hash of non-alterable engine parameters for change detection
  optional string engine_params_hash = 10;
  // Alterable table settings (can be changed with ALTER TABLE MODIFY SETTING)
  map<string, string> table_settings = 11;
  // Optional PARTITION BY expression for ClickHouse tables
  optional string partition_by = 12;

  // Next-version ORDER BY representation to match Rust enum
  // Non-breaking: keeps legacy order_by (field 3) while adding a structured variant
  optional OrderBy order_by2 = 13;
  // Optional secondary/data-skipping indexes
  repeated TableIndex indexes = 14;

  // Optional SAMPLE BY expression for ClickHouse tables
  optional string sample_by_expression = 15;

  // Optional TTL expression at table level (without leading 'TTL')
  optional string table_ttl_setting = 16;

  // Optional database name for multi-database support
  // When not specified, uses the global ClickHouse config database
  optional string database = 17;

  // Optional cluster name for ON CLUSTER support in ClickHouse
  optional string cluster_name = 18;

  // Optional PRIMARY KEY expression
  // When specified, overrides primary_key boolean flags on columns
  optional string primary_key_expression = 19;

  // Hash of table settings for change detection (including sensitive settings)
  // Used to detect settings changes without storing plaintext sensitive values
  optional string table_settings_hash = 20;
}

// Structured representation of ORDER BY to support either explicit fields
// or an arbitrary ClickHouse SQL expression.
message OrderBy {
  oneof t {
    // Explicit ordered list of fields
    OrderByFields fields = 1;
    // Arbitrary ClickHouse expression, e.g. "tuple()" or "(id, name)"
    string expression = 2;
  }
}

message OrderByFields {
  repeated string field = 1;
}

// DB-neutral representation of a table index
message TableIndex {
  string name = 1;
  string expression = 2;
  string type = 3;
  repeated string arguments = 4;
  uint64 granularity = 5;
}

message Dmv1View {
  string name = 1;
  string version = 2;
  oneof view_type {
    TableAlias table_alias = 3;
  }
}

message TableAlias {
  string source_table_name = 1;
}

// Reference to a table, optionally qualified with database
message TableReference {
  // Database name (empty means use default database)
  optional string database = 1;
  // Table name
  string table = 2;
}

// Represents a SELECT query with semantic information
message SelectQuery {
  // The raw SELECT SQL statement
  string sql = 1;
  // Tables/views referenced in the FROM clause(s)
  repeated TableReference source_tables = 2;
}

// User-defined ClickHouse View with an arbitrary SELECT query.
// Views are virtual tables that compute results on-demand.
message View {
  // Name of the view
  string name = 1;
  // Database where the view is created (empty = default database)
  optional string database = 2;
  // The SELECT query that defines the view
  SelectQuery select_query = 3;
  // Optional metadata for the view (e.g., description, source file)
  optional Metadata metadata = 4;
}

// Duration for refresh intervals (value + unit)
message RefreshDuration {
  uint64 value = 1;
  string unit = 2;
}

// Refresh interval specification for refreshable MVs
message RefreshInterval {
  oneof interval_type {
    RefreshDuration every = 1;  // REFRESH EVERY - periodic refresh
    RefreshDuration after = 2;  // REFRESH AFTER - refresh after interval since last
  }
}

// Configuration for refreshable materialized views
message RefreshableConfig {
  RefreshInterval interval = 1;
  optional RefreshDuration offset = 2;
  optional RefreshDuration randomize = 3;
  repeated string depends_on = 4;
  bool append = 5;
}

// Configuration for incremental (trigger-based) materialized views.
// Incremental MVs execute their SELECT on every insert to source tables.
//
// Note: Source tables are stored in select_query.source_tables for BOTH
// incremental and refreshable MVs. This provides consistent data lineage
// tracking - for incremental MVs these tables trigger the MV, for refreshable
// MVs they represent what tables are read during scheduled refresh.
message IncrementalConfig {
  // Legacy field - source_tables are now in select_query.source_tables.
  // Kept for backward wire compatibility. Do not use for new code.
  message SourceTable {
    string name = 1;
  }
  repeated SourceTable source_tables = 1 [deprecated = true];
}

// MV kind discriminator
message MaterializedViewKind {
  oneof kind {
    IncrementalConfig incremental = 1;
    RefreshableConfig refreshable = 2;
  }
}

// ClickHouse Materialized View that writes transformed data to a target table.
// MVs can be either incremental (triggered on insert) or refreshable (scheduled).
message MaterializedView {
  // Name of the materialized view
  string name = 1;
  // Database where the MV is created (empty = default database)
  optional string database = 2;
  // The SELECT query that defines the transformation
  SelectQuery select_query = 3;
  // Target table where transformed data is written (the TO clause)
  TableReference target_table = 4;
  // Optional metadata for the materialized view (e.g., description, source file)
  optional Metadata metadata = 5;
  // MV kind: incremental or refreshable (new in v2)
  MaterializedViewKind kind = 6;
}

message TopicToTableSyncProcess {
  string source_topic_id = 1;
  string target_table_id = 2;
  repeated Column columns = 3;
  optional string version = 4;
  PrimitiveSignature source_primitive = 5;
}

message TopicToTopicSyncProcess {
  string source_topic_id = 1;
  string target_topic_id = 2;
  PrimitiveSignature source_primitive = 3;
}

message FunctionProcess {
  string name = 1;
  string source_topic = 2;
  repeated Column source_columns = 3;
  optional string target_topic = 4;
  map<string, string> target_topic_config = 5;
  repeated Column target_columns = 6;
  string executable = 7;
  optional string version = 8;
  PrimitiveSignature source_primitive = 9;
  optional int32 parallel_process_count = 10;
  optional Metadata metadata = 11;
}

message InitialDataLoad {
  Table table = 1;
  string topic = 2;
  optional uint64 progress = 3;
}

message Column {
  string name = 1;
  ColumnType data_type = 2;
  bool required = 3;
  bool unique = 4;
  bool primary_key = 5;
  // was an enum that we never used
  int32 default = 6 [deprecated = true];
  // Column default is now a free-form SQL expression passed as a string
  google.protobuf.StringValue default_expr = 9;

  map<string, string> annotations = 7;
  optional string comment = 8; // Column comment for metadata storage
  // Optional column-level TTL expression (without leading 'TTL')
  optional string ttl = 10;
  // Compression codec expression (e.g., "ZSTD(3)", "Delta, LZ4")
  optional string codec = 11;
  // Materialized expression
  optional string materialized = 12;
}

enum SimpleColumnType {
  STRING = 0;
  BOOLEAN = 1;
  INT = 2  [deprecated = true];
  BIGINT = 3;
  FLOAT = 4 [deprecated = true];
  DECIMAL = 5 [deprecated = true];
  // in clickhouse, this is the 32-bit date
  // otherwise, see DateType where the precision can be specified
  DATETIME = 6;
  // Framework Date (standard) -> ClickHouse Date32 (4 bytes)
  DATE = 7;
  // Framework Date16 (memory-optimized) -> ClickHouse Date (2 bytes)
  DATE16 = 8;
  IPV4 = 9;
  IPV6 = 10;

  UUID_TYPE = 13;
  JSON_COLUMN = 14;
  BYTES = 15;

  // Geometry types
  POINT = 16;
  RING = 17;
  LINE_STRING = 18;
  MULTI_LINE_STRING = 19;
  POLYGON = 20;
  MULTI_POLYGON = 21;
}

enum IntType {
  INT64 = 0; // this is what we defaulted to

  INT8 = 1;
  INT16 = 2;
  INT32 = 3;
  INT128 = 4;
  INT256 = 5;
  UINT8 = 6;
  UINT16 = 7;
  UINT32 = 8;
  UINT64 = 9;
  UINT128 = 10;
  UINT256 = 11;
}

enum FloatType {
  FLOAT64 = 0;
  FLOAT32 = 1;
}

message Decimal {
    int32 precision = 1;
    int32 scale = 2;
}

message Tuple {
  repeated string names = 1;
  repeated ColumnType types = 2;
}

message Map {
  ColumnType key_type = 1;
  ColumnType value_type = 2;
}

// JSON type with optional settings
message JsonTypedPath {
  // JSON path like "a.b[0].c"
  string path = 1;
  // Concrete type for the value at the path
  ColumnType type = 2;
}

message Json {
  // Limits for dynamic discovery
  optional uint64 max_dynamic_paths = 1;
  optional uint64 max_dynamic_types = 2;
  // List of typed paths (path, type)
  repeated JsonTypedPath typed_paths = 3;
  // Paths to skip during ingestion
  repeated string skip_paths = 4;
  // Regex patterns of paths to skip
  repeated string skip_regexps = 5;
}

// TODO: nullable not being a type, relying on `bool required`
// is causing some mess e.g. the special case array_of_nullable
message ColumnType {
  oneof t {
    SimpleColumnType simple = 1;
    DataEnum enum = 2;
    ColumnType array = 3;
    Nested nested = 4;

    ColumnType array_of_nullable = 5;
    Tuple tuple = 6;
    ColumnType nullable = 7;
    Map map = 8;

    // JSON with settings (non-breaking addition). Keep legacy `simple = JSON_COLUMN` for back-compat.
    Json json = 9;

    uint64 fixed_string = 11;

    DateType date_time = 12;
    Decimal decimal = 13;
    FloatType float = 14;
    IntType int = 15;
  }
}

message DateType {
  int32 precision = 1;
}

message DataEnum {
  string name = 1;
  repeated EnumMember values = 2;
}

message Nested {
  string name = 1;
  repeated Column columns = 2;
  bool jwt = 3;
}

message EnumMember {
  string name = 1;
  EnumValue value = 2;
}

message EnumValue {
  oneof value {
    int32 int_value = 1;
    string string_value = 2;
  }
}

message PrimitiveSignature {
  string name = 1;
  PrimitiveTypes primitive_type = 2;
}

enum PrimitiveTypes {
  DATA_MODEL = 0;
  FUNCTION = 1;
  DB_BLOCK = 2;
  CONSUMPTION_API = 3;
}

enum LifeCycle {
  FULLY_MANAGED = 0;
  DELETION_PROTECTED = 1;
  EXTERNALLY_MANAGED = 2;
}



message OrchestrationWorker {
  string supported_language = 1;
}

message SqlResource {
  string name = 1;
  repeated string setup = 2;
  repeated string teardown = 3;
  repeated InfrastructureSignature pulls_data_from = 5;
  repeated InfrastructureSignature pushes_data_to = 6;
  // Optional database name for multi-database support
  // When not specified, uses the global ClickHouse config database
  optional string database = 7;
  // Optional source file path where this SQL resource is defined
  string source_file = 8;
}

message InfrastructureSignature {
  oneof signature {
    string topic_id = 1;
    string table_id = 2;
    string dmv1_view_id = 3;
    string sql_resource_id = 4;
    string api_endpoint_id = 5;
    string topic_to_table_sync_process_id = 6;
    string materialized_view_id = 7;
    string view_id = 8;
  }
}

message WebApp {
  string name = 1;
  string mount_path = 2;
  optional WebAppMetadata metadata = 3;
}

message WebAppMetadata {
  optional string description = 1;
}

message Workflow {
  // Unique workflow identifier
  string name = 1;
  // Cron schedule for automatic execution
  string schedule = 2;
  // Number of retry attempts on failure
  uint32 retries = 3;
  // Workflow timeout
  string timeout = 4;
  // Programming language of the workflow
  string language = 5;
}
