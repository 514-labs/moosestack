import ts, { factory } from "typescript";
import {
  avoidTypiaNameClash,
  createTransformer,
  type TransformContext,
} from "./compilerPluginHelper";
import {
  isNewMooseResourceWithTypeParam,
  transformNewMooseResource,
} from "./dmv2/dataModelMetadata";
import {
  isCreateApi,
  isCreateApiV2,
  transformCreateApi,
  transformLegacyApi,
} from "./consumption-apis/typiaValidation";
import { createTypiaContext, getTypiaImports } from "./typiaDirectIntegration";

/**
 * Creates the typia import statement to avoid name clashes
 */
export const createTypiaImport = () =>
  factory.createImportDeclaration(
    undefined,
    factory.createImportClause(
      false,
      factory.createIdentifier(avoidTypiaNameClash),
      undefined,
    ),
    factory.createStringLiteral("typia"),
    undefined,
  );

/**
 * Applies the appropriate transformation based on node type
 * Returns both the transformed node and whether a transformation occurred
 */
const applyTransformation = (
  node: ts.Node,
  ctx: TransformContext,
): { transformed: ts.Node; wasTransformed: boolean } => {
  if (isCreateApi(node, ctx.typeChecker)) {
    return {
      transformed: transformLegacyApi(node, ctx.typeChecker),
      wasTransformed: true,
    };
  }

  if (isCreateApiV2(node, ctx.typeChecker)) {
    return {
      transformed: transformCreateApi(node, ctx.typeChecker),
      wasTransformed: true,
    };
  }

  if (isNewMooseResourceWithTypeParam(node, ctx.typeChecker)) {
    return {
      transformed: transformNewMooseResource(node, ctx.typeChecker, ctx),
      wasTransformed: true,
    };
  }

  return { transformed: node, wasTransformed: false };
};

/**
 * Checks if typia import already exists in the source file
 */
const hasExistingTypiaImport = (sourceFile: ts.SourceFile): boolean => {
  return sourceFile.statements.some((stmt) => {
    if (
      !ts.isImportDeclaration(stmt) ||
      !ts.isStringLiteral(stmt.moduleSpecifier)
    ) {
      return false;
    }

    if (stmt.moduleSpecifier.text !== "typia") {
      return false;
    }

    // Check if it has our specific aliased import
    const importClause = stmt.importClause;
    if (
      importClause &&
      importClause.name &&
      importClause.name.text === avoidTypiaNameClash
    ) {
      return true;
    }

    return false;
  });
};

/**
 * Adds typia imports to the source file if not already present
 * This includes both the main typia import and any internal helper imports
 * generated by typia's ImportProgrammer during direct code generation.
 */
const addTypiaImports = (
  sourceFile: ts.SourceFile,
  ctx: TransformContext,
): ts.SourceFile => {
  const imports: ts.Statement[] = [];

  // Add main typia import if not present
  if (!hasExistingTypiaImport(sourceFile)) {
    imports.push(createTypiaImport());
  }

  // Add typia's internal helper imports from direct code generation
  if (ctx.typiaContext) {
    const typiaInternalImports = getTypiaImports(ctx.typiaContext);
    imports.push(...typiaInternalImports);
  }

  if (imports.length === 0) {
    return sourceFile;
  }

  const statementsWithImport = factory.createNodeArray([
    ...imports,
    ...sourceFile.statements,
  ]);

  return factory.updateSourceFile(sourceFile, statementsWithImport);
};

/**
 * Main transformation function that processes TypeScript source files
 */
const transform =
  (ctx: TransformContext) =>
  (transformationContext: ts.TransformationContext) =>
  (sourceFile: ts.SourceFile): ts.SourceFile => {
    let hasTransformations = false;

    // Create a per-file typia context for direct code generation
    // This shares the ImportProgrammer across all transformations in this file
    const typiaContext = createTypiaContext(ctx.program, transformationContext);

    // Add transformer and typia context to the transformation context
    const ctxWithTransformer: TransformContext = {
      ...ctx,
      transformer: transformationContext,
      typiaContext,
    };

    const visitNode = (node: ts.Node): ts.Node => {
      const { transformed, wasTransformed } = applyTransformation(
        node,
        ctxWithTransformer,
      );

      if (wasTransformed) {
        hasTransformations = true;
      }

      return ts.visitEachChild(transformed, visitNode, transformationContext);
    };

    const transformedSourceFile = ts.visitEachChild(
      sourceFile,
      visitNode,
      transformationContext,
    );

    if (hasTransformations) {
      return addTypiaImports(transformedSourceFile, ctxWithTransformer);
    }

    return transformedSourceFile;
  };

export default createTransformer(transform);
